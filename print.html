<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pense em Python</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Pense como um cientista da computação">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="introducao.html">Pense em Python</a></li><li class="expanded affix "><a href="prefacio.html">Prefácio</a></li><li class="expanded "><a href="01-a-jornada-do-programa/00-a-jornada-do-programa.html"><strong aria-hidden="true">1.</strong> A jornada do programa</a></li><li><ol class="section"><li class="expanded "><a href="01-a-jornada-do-programa/01-o-que-e-um-programa.html"><strong aria-hidden="true">1.1.</strong> O que é um programa?</a></li><li class="expanded "><a href="01-a-jornada-do-programa/02-execucao-do-python.html"><strong aria-hidden="true">1.2.</strong> Execução do Python</a></li><li class="expanded "><a href="01-a-jornada-do-programa/03-o-primeiro-programa.html"><strong aria-hidden="true">1.3.</strong> O primeiro programa</a></li><li class="expanded "><a href="01-a-jornada-do-programa/04-operadores-aritmeticos.html"><strong aria-hidden="true">1.4.</strong> Operadores aritméticos</a></li><li class="expanded "><a href="01-a-jornada-do-programa/05-valores-e-tipos.html"><strong aria-hidden="true">1.5.</strong> Valores e tipos</a></li><li class="expanded "><a href="01-a-jornada-do-programa/06-linguagens-formais-e-naturais.html"><strong aria-hidden="true">1.6.</strong> Linguagens formais e naturais</a></li><li class="expanded "><a href="01-a-jornada-do-programa/07-depuracao.html"><strong aria-hidden="true">1.7.</strong> Depuração</a></li><li class="expanded "><a href="01-a-jornada-do-programa/08-glossario.html"><strong aria-hidden="true">1.8.</strong> Glossário</a></li><li class="expanded "><a href="01-a-jornada-do-programa/09-exercicios.html"><strong aria-hidden="true">1.9.</strong> Exercícios</a></li></ol></li><li class="expanded "><a href="02-variaveis-expressoes-e-instrucoes/00-variaveis-expressoes-e-instrucoes.html"><strong aria-hidden="true">2.</strong> Variáveis, expressões e instruções</a></li><li><ol class="section"><li class="expanded "><a href="02-variaveis-expressoes-e-instrucoes/01-instrucoes-de-atribuicao.html"><strong aria-hidden="true">2.1.</strong> Instruções de atribuição</a></li><li class="expanded "><a href="02-variaveis-expressoes-e-instrucoes/02-nomes-de-variaveis.html"><strong aria-hidden="true">2.2.</strong> Nomes de variáveis</a></li><li class="expanded "><a href="02-variaveis-expressoes-e-instrucoes/03-expressoes-e-instrucoes.html"><strong aria-hidden="true">2.3.</strong> Expressões e instruções</a></li><li class="expanded "><a href="02-variaveis-expressoes-e-instrucoes/04-modo-script.html"><strong aria-hidden="true">2.4.</strong> Modo script</a></li><li class="expanded "><a href="02-variaveis-expressoes-e-instrucoes/05-ordem-das-operacoes.html"><strong aria-hidden="true">2.5.</strong> Ordem das operações</a></li><li class="expanded "><a href="02-variaveis-expressoes-e-instrucoes/06-operacoes-com-strings.html"><strong aria-hidden="true">2.6.</strong> Operações com strings</a></li><li class="expanded "><a href="02-variaveis-expressoes-e-instrucoes/07-comentarios.html"><strong aria-hidden="true">2.7.</strong> Comentários</a></li><li class="expanded "><a href="02-variaveis-expressoes-e-instrucoes/08-depuracao.html"><strong aria-hidden="true">2.8.</strong> Depuração</a></li><li class="expanded "><a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html"><strong aria-hidden="true">2.9.</strong> Glossário</a></li><li class="expanded "><a href="02-variaveis-expressoes-e-instrucoes/10-exercicios.html"><strong aria-hidden="true">2.10.</strong> Exercícios</a></li></ol></li><li class="expanded "><a href="03-funcoes/00-funcoes.html"><strong aria-hidden="true">3.</strong> Funções</a></li><li><ol class="section"><li class="expanded "><a href="03-funcoes/01-chamada-de-funcao.html"><strong aria-hidden="true">3.1.</strong> Chamada de função</a></li><li class="expanded "><a href="03-funcoes/02-funcoes-matematicas.html"><strong aria-hidden="true">3.2.</strong> Funções matemáticas</a></li><li class="expanded "><a href="03-funcoes/03-composicao.html"><strong aria-hidden="true">3.3.</strong> Composição</a></li><li class="expanded "><a href="03-funcoes/04-como-acrescentar-novas-funcoes.html"><strong aria-hidden="true">3.4.</strong> Como acrescentar novas funções</a></li><li class="expanded "><a href="03-funcoes/05-uso-e-definicoes.html"><strong aria-hidden="true">3.5.</strong> Uso e definições</a></li><li class="expanded "><a href="03-funcoes/06-fluxo-de-execucao.html"><strong aria-hidden="true">3.6.</strong> Fluxo de execução</a></li><li class="expanded "><a href="03-funcoes/07-parametros-e-argumentos.html"><strong aria-hidden="true">3.7.</strong> Parâmetros e argumentos</a></li><li class="expanded "><a href="03-funcoes/08-as-variaveis-e-os-parametros-sao-locais.html"><strong aria-hidden="true">3.8.</strong> As variáveis e os parâmetros são locais</a></li><li class="expanded "><a href="03-funcoes/09-diagrama-da-pilha.html"><strong aria-hidden="true">3.9.</strong> Diagrama da pilha</a></li><li class="expanded "><a href="03-funcoes/10-funcoes-com-resultado-e-funcoes-nulas.html"><strong aria-hidden="true">3.10.</strong> Funções com resultado e funções nulas</a></li><li class="expanded "><a href="03-funcoes/11-por-que-funcoes.html"><strong aria-hidden="true">3.11.</strong> Por que funções?</a></li><li class="expanded "><a href="03-funcoes/12-depuracao.html"><strong aria-hidden="true">3.12.</strong> Depuração</a></li><li class="expanded "><a href="03-funcoes/13-glossario.html"><strong aria-hidden="true">3.13.</strong> Glossário</a></li><li class="expanded "><a href="03-funcoes/14-exercicios.html"><strong aria-hidden="true">3.14.</strong> Exercícios</a></li></ol></li><li class="expanded "><a href="04-estudo-de-caso-projeto-de-interface/00-estudo-de-caso-projeto-de-interface.html"><strong aria-hidden="true">4.</strong> Estudo de caso: projeto de interface</a></li><li><ol class="section"><li class="expanded "><a href="04-estudo-de-caso-projeto-de-interface/01-modulo-turtle.html"><strong aria-hidden="true">4.1.</strong> Módulo turtle</a></li><li class="expanded "><a href="04-estudo-de-caso-projeto-de-interface/02-repeticao-simples.html"><strong aria-hidden="true">4.2.</strong> Repetição simples</a></li><li class="expanded "><a href="04-estudo-de-caso-projeto-de-interface/03-exercicios.html"><strong aria-hidden="true">4.3.</strong> Exercícios</a></li><li class="expanded "><a href="04-estudo-de-caso-projeto-de-interface/04-encapsulamento.html"><strong aria-hidden="true">4.4.</strong> Encapsulamento</a></li><li class="expanded "><a href="04-estudo-de-caso-projeto-de-interface/05-generalizacao.html"><strong aria-hidden="true">4.5.</strong> Generalização</a></li><li class="expanded "><a href="04-estudo-de-caso-projeto-de-interface/06-projeto-da-interface.html"><strong aria-hidden="true">4.6.</strong> Projeto da interface</a></li><li class="expanded "><a href="04-estudo-de-caso-projeto-de-interface/07-refatoracao.html"><strong aria-hidden="true">4.7.</strong> Refatoração</a></li><li class="expanded "><a href="04-estudo-de-caso-projeto-de-interface/08-um-plano-de-desenvolvimento.html"><strong aria-hidden="true">4.8.</strong> Um plano de desenvolvimento</a></li><li class="expanded "><a href="04-estudo-de-caso-projeto-de-interface/09-docstring.html"><strong aria-hidden="true">4.9.</strong> docstring</a></li><li class="expanded "><a href="04-estudo-de-caso-projeto-de-interface/10-depuracao.html"><strong aria-hidden="true">4.10.</strong> Depuração</a></li><li class="expanded "><a href="04-estudo-de-caso-projeto-de-interface/11-glossario.html"><strong aria-hidden="true">4.11.</strong> Glossário</a></li><li class="expanded "><a href="04-estudo-de-caso-projeto-de-interface/12-exercicios.html"><strong aria-hidden="true">4.12.</strong> Exercícios</a></li></ol></li><li class="expanded "><a href="05-condicionais-e-recursividade/00-condicionais-e-recursividade.html"><strong aria-hidden="true">5.</strong> Condicionais e recursividade</a></li><li><ol class="section"><li class="expanded "><a href="05-condicionais-e-recursividade/01-divisao-pelo-piso-e-modulo.html"><strong aria-hidden="true">5.1.</strong> Divisão pelo piso e módulo</a></li><li class="expanded "><a href="05-condicionais-e-recursividade/02-expressoes-booleanas.html"><strong aria-hidden="true">5.2.</strong> Expressões booleanas</a></li><li class="expanded "><a href="05-condicionais-e-recursividade/03-operadores-logicos.html"><strong aria-hidden="true">5.3.</strong> Operadores lógicos</a></li><li class="expanded "><a href="05-condicionais-e-recursividade/04-execucao-condicional.html"><strong aria-hidden="true">5.4.</strong> Execução condicional</a></li><li class="expanded "><a href="05-condicionais-e-recursividade/05-execucao-alternativa.html"><strong aria-hidden="true">5.5.</strong> Execução alternativa</a></li><li class="expanded "><a href="05-condicionais-e-recursividade/06-condicionais-encadeadas.html"><strong aria-hidden="true">5.6.</strong> Condicionais encadeadas</a></li><li class="expanded "><a href="05-condicionais-e-recursividade/07-condicionais-aninhadas.html"><strong aria-hidden="true">5.7.</strong> Condicionais aninhadas</a></li><li class="expanded "><a href="05-condicionais-e-recursividade/08-recursividade.html"><strong aria-hidden="true">5.8.</strong> Recursividade</a></li><li class="expanded "><a href="05-condicionais-e-recursividade/09-diagramas-da-pilha-para-funcoes-recursivas.html"><strong aria-hidden="true">5.9.</strong> Diagramas da pilha para funções recursivas</a></li><li class="expanded "><a href="05-condicionais-e-recursividade/10-recursividade-infinita.html"><strong aria-hidden="true">5.10.</strong> Recursividade infinita</a></li><li class="expanded "><a href="05-condicionais-e-recursividade/11-entrada-de-teclado.html"><strong aria-hidden="true">5.11.</strong> Entrada de teclado</a></li><li class="expanded "><a href="05-condicionais-e-recursividade/12-depuracao.html"><strong aria-hidden="true">5.12.</strong> Depuração</a></li><li class="expanded "><a href="05-condicionais-e-recursividade/13-glossario.html"><strong aria-hidden="true">5.13.</strong> Glossário</a></li><li class="expanded "><a href="05-condicionais-e-recursividade/14-exercicios.html"><strong aria-hidden="true">5.14.</strong> Exercícios</a></li></ol></li><li class="expanded "><a href="06-funcoes-com-resultado/00-funcoes-com-resultado.html"><strong aria-hidden="true">6.</strong> Funções com resultado</a></li><li><ol class="section"><li class="expanded "><a href="06-funcoes-com-resultado/01-valores-de-retorno.html"><strong aria-hidden="true">6.1.</strong> Valores de retorno</a></li><li class="expanded "><a href="06-funcoes-com-resultado/02-desenvolvimento-incremental.html"><strong aria-hidden="true">6.2.</strong> Desenvolvimento incremental</a></li><li class="expanded "><a href="06-funcoes-com-resultado/03-composicao.html"><strong aria-hidden="true">6.3.</strong> Composição</a></li><li class="expanded "><a href="06-funcoes-com-resultado/04-funcoes-booleanas.html"><strong aria-hidden="true">6.4.</strong> Funções booleanas</a></li><li class="expanded "><a href="06-funcoes-com-resultado/05-mais-recursividade.html"><strong aria-hidden="true">6.5.</strong> Mais recursividade</a></li><li class="expanded "><a href="06-funcoes-com-resultado/06-salto-de-fe.html"><strong aria-hidden="true">6.6.</strong> Salto de fé</a></li><li class="expanded "><a href="06-funcoes-com-resultado/07-mais-um-exemplo.html"><strong aria-hidden="true">6.7.</strong> Mais um exemplo</a></li><li class="expanded "><a href="06-funcoes-com-resultado/08-verificacao-de-tipos.html"><strong aria-hidden="true">6.8.</strong> Verificação de tipos</a></li><li class="expanded "><a href="06-funcoes-com-resultado/09-depuracao.html"><strong aria-hidden="true">6.9.</strong> Depuração</a></li><li class="expanded "><a href="06-funcoes-com-resultado/10-glossario.html"><strong aria-hidden="true">6.10.</strong> Glossário</a></li><li class="expanded "><a href="06-funcoes-com-resultado/11-exercicios.html"><strong aria-hidden="true">6.11.</strong> Exercícios</a></li></ol></li><li class="expanded "><a href="07-iteracao/00-iteracao.html"><strong aria-hidden="true">7.</strong> Iteração</a></li><li><ol class="section"><li class="expanded "><a href="07-iteracao/01-reatribuicao.html"><strong aria-hidden="true">7.1.</strong> Reatribuição</a></li><li class="expanded "><a href="07-iteracao/02-atualizacao-de-variaveis.html"><strong aria-hidden="true">7.2.</strong> Atualização de variáveis</a></li><li class="expanded "><a href="07-iteracao/03-instrucao-while.html"><strong aria-hidden="true">7.3.</strong> Instrução while</a></li><li class="expanded "><a href="07-iteracao/04-break.html"><strong aria-hidden="true">7.4.</strong> break</a></li><li class="expanded "><a href="07-iteracao/05-raizes-quadradas.html"><strong aria-hidden="true">7.5.</strong> Raízes quadradas</a></li><li class="expanded "><a href="07-iteracao/06-algoritmos.html"><strong aria-hidden="true">7.6.</strong> Algoritmos</a></li><li class="expanded "><a href="07-iteracao/07-depuracao.html"><strong aria-hidden="true">7.7.</strong> Depuração</a></li><li class="expanded "><a href="07-iteracao/08-glossario.html"><strong aria-hidden="true">7.8.</strong> Glossário</a></li><li class="expanded "><a href="07-iteracao/09-exercicios.html"><strong aria-hidden="true">7.9.</strong> Exercícios</a></li></ol></li><li class="expanded "><a href="08-strings/00-strings.html"><strong aria-hidden="true">8.</strong> Strings</a></li><li><ol class="section"><li class="expanded "><a href="08-strings/01-uma-string-e-uma-sequencia.html"><strong aria-hidden="true">8.1.</strong> Uma string é uma sequência</a></li><li class="expanded "><a href="08-strings/02-len.html"><strong aria-hidden="true">8.2.</strong> len</a></li><li class="expanded "><a href="08-strings/03-travessia-com-loop-for.html"><strong aria-hidden="true">8.3.</strong> Travessia com loop for</a></li><li class="expanded "><a href="08-strings/04-fatiamento-de-strings.html"><strong aria-hidden="true">8.4.</strong> Fatiamento de strings</a></li><li class="expanded "><a href="08-strings/05-strings-sao-imutaveis.html"><strong aria-hidden="true">8.5.</strong> Strings são imutáveis</a></li><li class="expanded "><a href="08-strings/06-buscando.html"><strong aria-hidden="true">8.6.</strong> Buscando</a></li><li class="expanded "><a href="08-strings/07-loop-e-contagem.html"><strong aria-hidden="true">8.7.</strong> Loop e contagem</a></li><li class="expanded "><a href="08-strings/08-metodos-de-strings.html"><strong aria-hidden="true">8.8.</strong> Métodos de strings</a></li><li class="expanded "><a href="08-strings/09-operador-in.html"><strong aria-hidden="true">8.9.</strong> Operador in</a></li><li class="expanded "><a href="08-strings/10-comparacao-de-strings.html"><strong aria-hidden="true">8.10.</strong> Comparação de strings</a></li><li class="expanded "><a href="08-strings/11-depuracao.html"><strong aria-hidden="true">8.11.</strong> Depuração</a></li><li class="expanded "><a href="08-strings/12-glossario.html"><strong aria-hidden="true">8.12.</strong> Glossário</a></li><li class="expanded "><a href="08-strings/13-exercicios.html"><strong aria-hidden="true">8.13.</strong> Exercícios</a></li></ol></li><li class="expanded "><a href="09-estudo-de-caso-jogos-de-palavras/00-estudo-de-caso-jogos-de-palavras.html"><strong aria-hidden="true">9.</strong> Estudo de caso: jogos de palavras</a></li><li><ol class="section"><li class="expanded "><a href="09-estudo-de-caso-jogos-de-palavras/01-leitura-de-listas-de-palavras.html"><strong aria-hidden="true">9.1.</strong> Leitura de listas de palavras</a></li><li class="expanded "><a href="09-estudo-de-caso-jogos-de-palavras/02-exercicios.html"><strong aria-hidden="true">9.2.</strong> Exercícios</a></li><li class="expanded "><a href="09-estudo-de-caso-jogos-de-palavras/03-busca.html"><strong aria-hidden="true">9.3.</strong> Busca</a></li><li class="expanded "><a href="09-estudo-de-caso-jogos-de-palavras/04-loop-com-indices.html"><strong aria-hidden="true">9.4.</strong> Loop com índices</a></li><li class="expanded "><a href="09-estudo-de-caso-jogos-de-palavras/05-depuracao.html"><strong aria-hidden="true">9.5.</strong> Depuração</a></li><li class="expanded "><a href="09-estudo-de-caso-jogos-de-palavras/06-glossario.html"><strong aria-hidden="true">9.6.</strong> Glossário</a></li><li class="expanded "><a href="09-estudo-de-caso-jogos-de-palavras/07-exercicios.html"><strong aria-hidden="true">9.7.</strong> Exercícios</a></li></ol></li><li class="expanded "><a href="10-listas/00-listas.html"><strong aria-hidden="true">10.</strong> Listas</a></li><li><ol class="section"><li class="expanded "><a href="10-listas/01-uma-lista-e-uma-sequencia.html"><strong aria-hidden="true">10.1.</strong> Uma lista é uma sequência</a></li><li class="expanded "><a href="10-listas/02-listas-sao-mutaveis.html"><strong aria-hidden="true">10.2.</strong> Listas são mutáveis</a></li><li class="expanded "><a href="10-listas/03-percorrendo-uma-lista.html"><strong aria-hidden="true">10.3.</strong> Percorrendo uma lista</a></li><li class="expanded "><a href="10-listas/04-operacoes-com-listas.html"><strong aria-hidden="true">10.4.</strong> Operações com listas</a></li><li class="expanded "><a href="10-listas/05-fatias-de-listas.html"><strong aria-hidden="true">10.5.</strong> Fatias de listas</a></li><li class="expanded "><a href="10-listas/06-metodos-de-listas.html"><strong aria-hidden="true">10.6.</strong> Métodos de listas</a></li><li class="expanded "><a href="10-listas/07-mapeamento-filtragem-e-reducao.html"><strong aria-hidden="true">10.7.</strong> Mapeamento, filtragem e redução</a></li><li class="expanded "><a href="10-listas/08-como-excluir-elementos.html"><strong aria-hidden="true">10.8.</strong> Como excluir elementos</a></li><li class="expanded "><a href="10-listas/09-listas-e-strings.html"><strong aria-hidden="true">10.9.</strong> Listas e strings</a></li><li class="expanded "><a href="10-listas/10-objetos-e-valores.html"><strong aria-hidden="true">10.10.</strong> Objetos e valores</a></li><li class="expanded "><a href="10-listas/11-alias.html"><strong aria-hidden="true">10.11.</strong> Alias</a></li><li class="expanded "><a href="10-listas/12-argumentos-de-listas.html"><strong aria-hidden="true">10.12.</strong> Argumentos de listas</a></li><li class="expanded "><a href="10-listas/13-depuracao.html"><strong aria-hidden="true">10.13.</strong> Depuração</a></li><li class="expanded "><a href="10-listas/14-glossario.html"><strong aria-hidden="true">10.14.</strong> Glossário</a></li><li class="expanded "><a href="10-listas/15-exercicios.html"><strong aria-hidden="true">10.15.</strong> Exercícios</a></li></ol></li><li class="expanded "><a href="11-dicionarios/00-dicionarios.html"><strong aria-hidden="true">11.</strong> Dicionários</a></li><li><ol class="section"><li class="expanded "><a href="11-dicionarios/01-um-dicionario-e-um-mapeamento.html"><strong aria-hidden="true">11.1.</strong> Um dicionário é um mapeamento</a></li><li class="expanded "><a href="11-dicionarios/02-um-dicionario-como-uma-colecao-de-contadores.html"><strong aria-hidden="true">11.2.</strong> Um dicionário como uma coleção de contadores</a></li><li class="expanded "><a href="11-dicionarios/03-loop-e-dicionarios.html"><strong aria-hidden="true">11.3.</strong> Loop e dicionários</a></li><li class="expanded "><a href="11-dicionarios/04-busca-reversa.html"><strong aria-hidden="true">11.4.</strong> Busca reversa</a></li><li class="expanded "><a href="11-dicionarios/05-dicionarios-e-listas.html"><strong aria-hidden="true">11.5.</strong> Dicionários e listas</a></li><li class="expanded "><a href="11-dicionarios/06-memos.html"><strong aria-hidden="true">11.6.</strong> Memos</a></li><li class="expanded "><a href="11-dicionarios/07-variaveis-globais.html"><strong aria-hidden="true">11.7.</strong> Variáveis globais</a></li><li class="expanded "><a href="11-dicionarios/08-depuracao.html"><strong aria-hidden="true">11.8.</strong> Depuração</a></li><li class="expanded "><a href="11-dicionarios/09-glossario.html"><strong aria-hidden="true">11.9.</strong> Glossário</a></li><li class="expanded "><a href="11-dicionarios/10-exercicios.html"><strong aria-hidden="true">11.10.</strong> Exercícios</a></li></ol></li><li class="expanded "><a href="12-tuplas/00-tuplas.html"><strong aria-hidden="true">12.</strong> Tuplas</a></li><li><ol class="section"><li class="expanded "><a href="12-tuplas/01-tuplas-sao-imutaveis.html"><strong aria-hidden="true">12.1.</strong> Tuplas são imutáveis</a></li><li class="expanded "><a href="12-tuplas/02-atribuicao-de-tuplas.html"><strong aria-hidden="true">12.2.</strong> Atribuição de tuplas</a></li><li class="expanded "><a href="12-tuplas/03-tuplas-como-valores-de-retorno.html"><strong aria-hidden="true">12.3.</strong> Tuplas como valores de retorno</a></li><li class="expanded "><a href="12-tuplas/04-tuplas-com-argumentos-de-comprimento-variavel.html"><strong aria-hidden="true">12.4.</strong> Tuplas com argumentos de comprimento variável</a></li><li class="expanded "><a href="12-tuplas/05-listas-e-tuplas.html"><strong aria-hidden="true">12.5.</strong> Listas e tuplas</a></li><li class="expanded "><a href="12-tuplas/06-dicionarios-e-tuplas.html"><strong aria-hidden="true">12.6.</strong> Dicionários e tuplas</a></li><li class="expanded "><a href="12-tuplas/07-sequencias-de-sequencias.html"><strong aria-hidden="true">12.7.</strong> Sequências de sequências</a></li><li class="expanded "><a href="12-tuplas/08-depuracao.html"><strong aria-hidden="true">12.8.</strong> Depuração</a></li><li class="expanded "><a href="12-tuplas/09-glossario.html"><strong aria-hidden="true">12.9.</strong> Glossário</a></li><li class="expanded "><a href="12-tuplas/10-exercicios.html"><strong aria-hidden="true">12.10.</strong> Exercícios</a></li></ol></li><li class="expanded "><a href="13-estudo-de-caso-selecao-de-estrutura-de-dados/00-estudo-de-caso-selecao-de-estrutura-de-dados.html"><strong aria-hidden="true">13.</strong> Estudo de caso: seleção de estrutura de dados</a></li><li><ol class="section"><li class="expanded "><a href="13-estudo-de-caso-selecao-de-estrutura-de-dados/01-analise-de-frequencia-de-palavras.html"><strong aria-hidden="true">13.1.</strong> Análise de frequência de palavras</a></li><li class="expanded "><a href="13-estudo-de-caso-selecao-de-estrutura-de-dados/02-numeros-aleatorios.html"><strong aria-hidden="true">13.2.</strong> Números aleatórios</a></li><li class="expanded "><a href="13-estudo-de-caso-selecao-de-estrutura-de-dados/03-histograma-de-palavras.html"><strong aria-hidden="true">13.3.</strong> Histograma de palavras</a></li><li class="expanded "><a href="13-estudo-de-caso-selecao-de-estrutura-de-dados/04-palavras-mais-comuns.html"><strong aria-hidden="true">13.4.</strong> Palavras mais comuns</a></li><li class="expanded "><a href="13-estudo-de-caso-selecao-de-estrutura-de-dados/05-parametros-opcionais.html"><strong aria-hidden="true">13.5.</strong> Parâmetros opcionais</a></li><li class="expanded "><a href="13-estudo-de-caso-selecao-de-estrutura-de-dados/06-subtracao-de-dicionario.html"><strong aria-hidden="true">13.6.</strong> Subtração de dicionário</a></li><li class="expanded "><a href="13-estudo-de-caso-selecao-de-estrutura-de-dados/07-palavras-aleatorias.html"><strong aria-hidden="true">13.7.</strong> Palavras aleatórias</a></li><li class="expanded "><a href="13-estudo-de-caso-selecao-de-estrutura-de-dados/08-analise-de-markov.html"><strong aria-hidden="true">13.8.</strong> Análise de Markov</a></li><li class="expanded "><a href="13-estudo-de-caso-selecao-de-estrutura-de-dados/09-estruturas-de-dados.html"><strong aria-hidden="true">13.9.</strong> Estruturas de dados</a></li><li class="expanded "><a href="13-estudo-de-caso-selecao-de-estrutura-de-dados/10-depuracao.html"><strong aria-hidden="true">13.10.</strong> Depuração</a></li><li class="expanded "><a href="13-estudo-de-caso-selecao-de-estrutura-de-dados/11-glossario.html"><strong aria-hidden="true">13.11.</strong> Glossário</a></li><li class="expanded "><a href="13-estudo-de-caso-selecao-de-estrutura-de-dados/12-exercicios.html"><strong aria-hidden="true">13.12.</strong> Exercícios</a></li></ol></li><li class="expanded "><a href="14-arquivos/00-arquivos.html"><strong aria-hidden="true">14.</strong> Arquivos</a></li><li><ol class="section"><li class="expanded "><a href="14-arquivos/01-persistencia.html"><strong aria-hidden="true">14.1.</strong> Persistência</a></li><li class="expanded "><a href="14-arquivos/02-leitura-e-escrita.html"><strong aria-hidden="true">14.2.</strong> Leitura e escrita</a></li><li class="expanded "><a href="14-arquivos/03-operador-de-formatacao.html"><strong aria-hidden="true">14.3.</strong> Operador de formatação</a></li><li class="expanded "><a href="14-arquivos/04-nomes-de-arquivo-e-caminhos.html"><strong aria-hidden="true">14.4.</strong> Nomes de arquivo e caminhos</a></li><li class="expanded "><a href="14-arquivos/05-captura-de-excecoes.html"><strong aria-hidden="true">14.5.</strong> Captura de exceções</a></li><li class="expanded "><a href="14-arquivos/06-bancos-de-dados.html"><strong aria-hidden="true">14.6.</strong> Bancos de dados</a></li><li class="expanded "><a href="14-arquivos/07-usando-o-pickle.html"><strong aria-hidden="true">14.7.</strong> Usando o Pickle</a></li><li class="expanded "><a href="14-arquivos/08-pipes.html"><strong aria-hidden="true">14.8.</strong> Pipes</a></li><li class="expanded "><a href="14-arquivos/09-escrevendo-modulos.html"><strong aria-hidden="true">14.9.</strong> Escrevendo módulos</a></li><li class="expanded "><a href="14-arquivos/10-depuracao.html"><strong aria-hidden="true">14.10.</strong> Depuração</a></li><li class="expanded "><a href="14-arquivos/11-glossario.html"><strong aria-hidden="true">14.11.</strong> Glossário</a></li><li class="expanded "><a href="14-arquivos/12-exercicios.html"><strong aria-hidden="true">14.12.</strong> Exercícios</a></li></ol></li><li class="expanded "><a href="15-classes-e-objetos/00-classes-e-objetos.html"><strong aria-hidden="true">15.</strong> Classes e objetos</a></li><li><ol class="section"><li class="expanded "><a href="15-classes-e-objetos/01-tipos-definidos-pelos-programadores.html"><strong aria-hidden="true">15.1.</strong> Tipos definidos pelos programadores</a></li><li class="expanded "><a href="15-classes-e-objetos/02-atributos.html"><strong aria-hidden="true">15.2.</strong> Atributos</a></li><li class="expanded "><a href="15-classes-e-objetos/03-retangulos.html"><strong aria-hidden="true">15.3.</strong> Retângulos</a></li><li class="expanded "><a href="15-classes-e-objetos/04-instancias-como-valores-de-retorno.html"><strong aria-hidden="true">15.4.</strong> Instâncias como valores de retorno</a></li><li class="expanded "><a href="15-classes-e-objetos/05-objetos-sao-mutaveis.html"><strong aria-hidden="true">15.5.</strong> Objetos são mutáveis</a></li><li class="expanded "><a href="15-classes-e-objetos/06-copia.html"><strong aria-hidden="true">15.6.</strong> Cópia</a></li><li class="expanded "><a href="15-classes-e-objetos/07-depuracao.html"><strong aria-hidden="true">15.7.</strong> Depuração</a></li><li class="expanded "><a href="15-classes-e-objetos/08-glossario.html"><strong aria-hidden="true">15.8.</strong> Glossário</a></li><li class="expanded "><a href="15-classes-e-objetos/09-exercicios.html"><strong aria-hidden="true">15.9.</strong> Exercícios</a></li></ol></li><li class="expanded "><a href="16-classes-e-funcoes/00-classes-e-funcoes.html"><strong aria-hidden="true">16.</strong> Classes e funções</a></li><li><ol class="section"><li class="expanded "><a href="16-classes-e-funcoes/01-time.html"><strong aria-hidden="true">16.1.</strong> Time</a></li><li class="expanded "><a href="16-classes-e-funcoes/02-funcoes-puras.html"><strong aria-hidden="true">16.2.</strong> Funções puras</a></li><li class="expanded "><a href="16-classes-e-funcoes/03-modificadores.html"><strong aria-hidden="true">16.3.</strong> Modificadores</a></li><li class="expanded "><a href="16-classes-e-funcoes/04-prototipacao-versus-planejamento.html"><strong aria-hidden="true">16.4.</strong> Prototipação versus planejamento</a></li><li class="expanded "><a href="16-classes-e-funcoes/05-depuracao.html"><strong aria-hidden="true">16.5.</strong> Depuração</a></li><li class="expanded "><a href="16-classes-e-funcoes/06-glossario.html"><strong aria-hidden="true">16.6.</strong> Glossário</a></li><li class="expanded "><a href="16-classes-e-funcoes/07-exercicios.html"><strong aria-hidden="true">16.7.</strong> Exercícios</a></li></ol></li><li class="expanded "><a href="17-classes-e-metodos/00-classes-e-metodos.html"><strong aria-hidden="true">17.</strong> Classes e métodos</a></li><li><ol class="section"><li class="expanded "><a href="17-classes-e-metodos/01-recursos-de-orientacao-a-objeto.html"><strong aria-hidden="true">17.1.</strong> Recursos de orientação a objeto</a></li><li class="expanded "><a href="17-classes-e-metodos/02-exibicao-de-objetos.html"><strong aria-hidden="true">17.2.</strong> Exibição de objetos</a></li><li class="expanded "><a href="17-classes-e-metodos/03-outro-exemplo.html"><strong aria-hidden="true">17.3.</strong> Outro exemplo</a></li><li class="expanded "><a href="17-classes-e-metodos/04-um-exemplo-mais-complicado.html"><strong aria-hidden="true">17.4.</strong> Um exemplo mais complicado</a></li><li class="expanded "><a href="17-classes-e-metodos/05-metodo-init.html"><strong aria-hidden="true">17.5.</strong> Método init</a></li><li class="expanded "><a href="17-classes-e-metodos/06-metodo-__str__.html"><strong aria-hidden="true">17.6.</strong> Método str</a></li><li class="expanded "><a href="17-classes-e-metodos/07-sobrecarga-de-operadores.html"><strong aria-hidden="true">17.7.</strong> Sobrecarga de operadores</a></li><li class="expanded "><a href="17-classes-e-metodos/08-despacho-por-tipo.html"><strong aria-hidden="true">17.8.</strong> Despacho por tipo</a></li><li class="expanded "><a href="17-classes-e-metodos/09-polimorfismo.html"><strong aria-hidden="true">17.9.</strong> Polimorfismo</a></li><li class="expanded "><a href="17-classes-e-metodos/10-interface-e-implementacao.html"><strong aria-hidden="true">17.10.</strong> Interface e implementação</a></li><li class="expanded "><a href="17-classes-e-metodos/11-depuracao.html"><strong aria-hidden="true">17.11.</strong> Depuração</a></li><li class="expanded "><a href="17-classes-e-metodos/12-glossario.html"><strong aria-hidden="true">17.12.</strong> Glossário</a></li><li class="expanded "><a href="17-classes-e-metodos/13-exercicios.html"><strong aria-hidden="true">17.13.</strong> Exercícios</a></li></ol></li><li class="expanded "><a href="18-heranca/00-heranca.html"><strong aria-hidden="true">18.</strong> Herança</a></li><li><ol class="section"><li class="expanded "><a href="18-heranca/01-objetos-card.html"><strong aria-hidden="true">18.1.</strong> Objetos Card</a></li><li class="expanded "><a href="18-heranca/02-atributos-de-classe.html"><strong aria-hidden="true">18.2.</strong> Atributos de classe</a></li><li class="expanded "><a href="18-heranca/03-comparacao-de-cartas.html"><strong aria-hidden="true">18.3.</strong> Comparação de cartas</a></li><li class="expanded "><a href="18-heranca/04-baralhos.html"><strong aria-hidden="true">18.4.</strong> Baralhos</a></li><li class="expanded "><a href="18-heranca/05-exibicao-do-baralho.html"><strong aria-hidden="true">18.5.</strong> Exibição do baralho</a></li><li class="expanded "><a href="18-heranca/06-adicao-remocao-embaralhamento-e-classificacao.html"><strong aria-hidden="true">18.6.</strong> Adição, remoção, embaralhamento e classificação</a></li><li class="expanded "><a href="18-heranca/07-heranca.html"><strong aria-hidden="true">18.7.</strong> Herança</a></li><li class="expanded "><a href="18-heranca/08-diagramas-de-classe.html"><strong aria-hidden="true">18.8.</strong> Diagramas de classe</a></li><li class="expanded "><a href="18-heranca/09-encapsulamento-de-dados.html"><strong aria-hidden="true">18.9.</strong> Encapsulamento de dados</a></li><li class="expanded "><a href="18-heranca/10-depuracao.html"><strong aria-hidden="true">18.10.</strong> Depuração</a></li><li class="expanded "><a href="18-heranca/11-glossario.html"><strong aria-hidden="true">18.11.</strong> Glossário</a></li><li class="expanded "><a href="18-heranca/12-exercicios.html"><strong aria-hidden="true">18.12.</strong> Exercícios</a></li></ol></li><li class="expanded "><a href="19-extra/00-extra.html"><strong aria-hidden="true">19.</strong> Extra</a></li><li><ol class="section"><li class="expanded "><a href="19-extra/01-expressoes-condicionais.html"><strong aria-hidden="true">19.1.</strong> Expressões condicionais</a></li><li class="expanded "><a href="19-extra/02-abrangencia-de-listas.html"><strong aria-hidden="true">19.2.</strong> Abrangência de listas</a></li><li class="expanded "><a href="19-extra/03-expressoes-geradoras.html"><strong aria-hidden="true">19.3.</strong> Expressões geradoras</a></li><li class="expanded "><a href="19-extra/04-any-e-all.html"><strong aria-hidden="true">19.4.</strong> any e all</a></li><li class="expanded "><a href="19-extra/05-conjuntos.html"><strong aria-hidden="true">19.5.</strong> Conjuntos</a></li><li class="expanded "><a href="19-extra/06-contadores.html"><strong aria-hidden="true">19.6.</strong> Contadores</a></li><li class="expanded "><a href="19-extra/07-defaultdict.html"><strong aria-hidden="true">19.7.</strong> defaultdict</a></li><li class="expanded "><a href="19-extra/08-tuplas-nomeadas.html"><strong aria-hidden="true">19.8.</strong> Tuplas nomeadas</a></li><li class="expanded "><a href="19-extra/09-reunindo-argumentos-de-palavra-chave.html"><strong aria-hidden="true">19.9.</strong> Reunindo argumentos de palavra-chave</a></li><li class="expanded "><a href="19-extra/10-glossario.html"><strong aria-hidden="true">19.10.</strong> Glossário</a></li><li class="expanded "><a href="19-extra/11-exercicios.html"><strong aria-hidden="true">19.11.</strong> Exercícios</a></li></ol></li><li class="expanded "><a href="apendice-a-depuracao.html">Apêndice A: Depuração</a></li><li class="expanded affix "><a href="apendice-b-analise-de-algoritmos.html">Apêndice B: Análise de algoritmos</a></li><li class="expanded affix "><a href="colofao-sobre-o-autor.html">Colofão / Sobre o Autor</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Pense em Python</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#pense-em-python" id="pense-em-python">Pense em Python</a></h1>
<h3><a class="header" href="#pense-como-um-cientista-da-computação" id="pense-como-um-cientista-da-computação">Pense como um cientista da computação</a></h3>
<a href="https://novatec.com.br/livros/pense-em-python/">
    <img src="fig/Capa_PenseEmPython167x232.png" align="right" style="margin-left: 20px;">
</a>
<p>Este livro ensina programação para quem nunca programou, usando <a href="https://www.python.org/">Python 3</a> nos exemplos. É aplicado no Olin College, IBMEC e outras faculdades de engenharia de primeira linha.</p>
<blockquote>
<p><strong>DICA</strong>: Você pode comprar um exemplar impresso de <a href="https://novatec.com.br/livros/pense-em-python/"><strong>Pense em Python</strong></a> no site da <a href="https://novatec.com.br/livros/pense-em-python/">Editora Novatec</a> ou em livrarias. <a href="https://novatec.com.br/livros/pense-em-python/">ISBN: 978-85-7522-508-0</a>.</p>
</blockquote>
<p><a href="https://novatec.com.br/livros/pense-em-python/"><strong>Pense em Python</strong></a> é uma tradução do livro <a href="http://shop.oreilly.com/product/0636920045267.do">Think Python</a> (2ª edição), de <strong>Allen B. Downey</strong>, traduzido e publicado no Brasil pela <a href="https://novatec.com.br">Editora Novatec</a> sob licença da O'Reilly Media.</p>
<h2><a class="header" href="#créditos-da-edição-brasileira" id="créditos-da-edição-brasileira">Créditos da edição brasileira</a></h2>
<p>Editor: Rubens Prates<br>
Tradução: Sheila Gomes<br>
Revisão Gramatical: Smirna Cavalheiro<br>
Editoração Eletrônica: Carolina Kuwabata<br>
Assistente Editorial: Priscila A. Yoshimatsu</p>
<h2><a class="header" href="#histórico" id="histórico">Histórico</a></h2>
<p>Allen Downey publicou o <a href="http://greenteapress.com/wp/think-python-2e/">original em inglês</a> sob uma licença Creative Commons Atribuição-NãoComercial <a href="https://github.com/PenseAllen/PensePython2/blob/master/LICENSE.md">CC BY-NC 3.0</a>. A Novatec oferece à comunidade esta tradução nos termos da mesma licença do original, <a href="https://github.com/PenseAllen/PensePython2/blob/master/LICENSE.md">CC BY-NC 3.0</a>, atendendo ao desejo do autor oferecer seu trabalho através de uma licença livre.</p>
<p>Esta versão digital de <strong>Pense em Python</strong> em português foi gerada por <a href="https://twitter.com/ramalhoorg">Luciano Ramalho</a> da <a href="https://www.thoughtworks.com/">ThoughtWorks</a> a partir de arquivos cedidos por <a href="https://novatec.com.br/autores/rprates.php">Rubens Prates</a> da <a href="https://novatec.com.br">Editora Novatec</a>.</p>
<h1><a class="header" href="#prefácio" id="prefácio">Prefácio</a></h1>
<h2><a class="header" href="#a-estranha-história-deste-livro" id="a-estranha-história-deste-livro">A estranha história deste livro</a></h2>
<p>Em janeiro de 1999 eu me preparava para dar aula a uma turma de programação introdutória em Java. Já tinha dado esse curso três vezes e estava ficando frustrado. O índice de aprovação era muito baixo e mesmo entre os alunos aprovados, o nível geral das notas era baixo demais.</p>
<p>Um dos problemas que eu via eram os livros. Eram muito grandes, com detalhes desnecessários sobre o Java, e não havia orientação de alto nível sobre como programar. E todos eles sofriam do efeito alçapão: no início era fácil, os alunos iam aprendendo aos poucos, e lá pelo Capítulo 5, perdiam o chão. Era muito material novo, muito rápido, e eles acabavam engatinhando no resto do semestre.</p>
<p>Duas semanas antes do primeiro dia de aula, eu decidi escrever meu próprio livro. Meus objetivos eram:</p>
<ul>
<li>
<p>que o livro fosse curto. Era melhor os alunos lerem 10 páginas que não lerem 50.</p>
</li>
<li>
<p>abordar o vocabulário com cuidado. Tentei minimizar o jargão e definir cada termo no momento do primeiro uso.</p>
</li>
<li>
<p>construir o aprendizado passo a passo. Para evitar alçapões, dividi os tópicos mais difíceis e em uma série de etapas menores.</p>
</li>
<li>
<p>que o conteúdo fosse concentrado em programar mesmo, não na linguagem de programação. Selecionei um subconjunto mínimo útil do Java e omiti o resto.</p>
</li>
</ul>
<p>Eu precisava de um título, então, por capricho, decidi chamá-lo de <em>Pense como um cientista da computação</em>.</p>
<p>A minha primeira versão era apenas um esboço, mas funcionou. Os alunos liam e entendiam o suficiente para podermos usar o tempo de aula para os tópicos difíceis, interessantes e (o mais importante) para permitir que os alunos praticassem.</p>
<p>Lancei o livro sob uma Licença de Documentação Livre GNU, que permite aos usuários copiar, modificar e distribuir o livro.</p>
<p>E o que aconteceu em seguida foi legal. Jeff Elkner, um professor de ensino médio na Virgínia adotou meu livro e o traduziu para Python. Ele me enviou uma cópia de sua tradução e tive a experiência excepcional de aprender Python lendo o meu próprio livro. Com a editora Green Tea, publiquei a primeira versão em Python em 2001.</p>
<p>Em 2003 comecei a trabalhar no Olin College e a ensinar Python pela primeira vez na vida. O contraste com o Java era notável. Os estudantes tinham menos dificuldades, aprendiam mais, trabalhavam em projetos mais interessantes e geralmente se divertiam muito mais.</p>
<p>Desde então continuei a desenvolver o livro, corrigindo erros, melhorando alguns exemplos e acrescentando material, especialmente exercícios.</p>
<p>O resultado está aqui, agora com o título menos grandioso de <em>Pense em Python</em>. Fiz algumas alterações:</p>
<ul>
<li>
<p>Acrescentei uma seção sobre depuração (debugging) no fim de cada capítulo. Essas seções apresentam técnicas gerais para encontrar e evitar bugs (erros de programação) e avisos sobre armadilhas do Python.</p>
</li>
<li>
<p>Acrescentei exercícios, incluindo testes curtos de compreensão e alguns projetos substanciais. A maior parte dos exercícios tem um link para a minha solução.</p>
</li>
<li>
<p>Acrescentei uma série de estudos de caso – exemplos mais longos com exercícios, soluções e discussões.</p>
</li>
<li>
<p>Expandi a discussão sobre planos de desenvolvimento de programas e padrões de design básicos.</p>
</li>
<li>
<p>Acrescentei apêndices sobre depuração e análise de algoritmos.</p>
</li>
</ul>
<p>Esta edição de <em>Pense em Python</em> tem as seguintes novidades:</p>
<ul>
<li>
<p>O livro e todo o código de apoio foram atualizados para o Python 3.</p>
</li>
<li>
<p>Acrescentei algumas seções e mais detalhes sobre a web, para ajudar os principiantes a executar o Python em um navegador, e não ter que lidar com a instalação do programa até que seja necessário.</p>
</li>
<li>
<p>Para <a href="../04-estudo-de-caso-projeto-de-interface/01-modulo-turtle.html">“Módulo turtle”</a> troquei meu próprio pacote gráfico turtle, chamado Swampy, para um módulo Python mais padronizado, turtle, que é mais fácil de instalar e mais eficiente.</p>
</li>
<li>
<p>Acrescentei um novo capítulo chamado <a href="../19-extra/00-extra.html">“Extra”</a>, que introduz alguns recursos adicionais do Python, não estritamente necessários, mas às vezes práticos.</p>
</li>
</ul>
<p>Espero que goste de trabalhar com este livro, e que ele o ajude a aprender a programar e pensar, pelo menos um pouquinho, como um cientista da computação.</p>
<p><em>Allen B. Downey</em><br>
<em>Olin College</em></p>
<h2><a class="header" href="#convenções-usadas-neste-livro" id="convenções-usadas-neste-livro">Convenções usadas neste livro</a></h2>
<p>As seguintes convenções tipográficas são usadas neste livro:</p>
<p><em>Itálico</em></p>
<p>Indica novos termos, URLs, endereços de email, nomes de arquivo e extensões de arquivo.</p>
<p><strong>Negrito</strong></p>
<p>Indica termos definidos no glossário no final de capítulo.</p>
<p><code>Monoespaçado</code></p>
<p>Usada para código de programa, bem como dentro de parágrafos para referir-se a elementos do programa, como nomes de variáveis ou de funções, bancos de dados, tipos de dados, variáveis de ambiente, instruções e palavras-chave.</p>
<p><strong><code>Monoespaçado negrito</code></strong></p>
<p>Exibe comandos ou outros textos que devem ser digitados literalmente pelo usuário.</p>
<p><em><code>Monoespaçado itálico</code></em></p>
<p>Exibe textos que devem ser substituídos por valores fornecidos pelos usuários ou por valores determinados pelo contexto.</p>
<h2><a class="header" href="#uso-do-código-dos-exemplos-de-acordo-com-a-política-da-oreilly" id="uso-do-código-dos-exemplos-de-acordo-com-a-política-da-oreilly">Uso do código dos exemplos (de acordo com a política da O'Reilly)</a></h2>
<p>Há material suplementar (exemplos de código, exercícios etc) disponível para baixar em <a href="http://www.greenteapress.com/thinkpython2/code">http://www.greenteapress.com/thinkpython2/code</a>.</p>
<p>Este livro serve para ajudar você a fazer o que precisa. Em geral, se o livro oferece exemplos de código, você pode usá-los nos seus programas e documentação. Não é preciso entrar em contato conosco para pedir permissão, a menos que esteja reproduzindo uma porção significativa do código. Por exemplo, escrever um programa que use vários pedaços de código deste livro não exige permissão. Vender ou distribuir um CD-ROM de exemplos dos livros da O’Reilly exige permissão. Responder a uma pergunta citando este livro e reproduzindo exemplos de código não exige permissão. Incorporar uma quantidade significativa de exemplos de código deste livro na documentação do seu produto exige permissão.</p>
<p>Agradecemos, mas não exigimos, crédito. O crédito normalmente inclui o título, o autor, a editora e o ISBN. Por exemplo: “<em>Pense em Python</em>, 2ª edição, por Allen B. Downey (O’Reilly). Copyright 2016 Allen Downey, 978-1-4919-3936-9.”</p>
<p>Se acreditar que o seu uso dos exemplos de código não se ajusta à permissão dada anteriormente, fique à vontade para entrar em contato conosco pelo email <code>permissions@oreilly.com</code>.</p>
<h2><a class="header" href="#como-entrar-em-contato-conosco" id="como-entrar-em-contato-conosco">Como entrar em contato conosco</a></h2>
<p>Envie comentários e dúvidas sobre este livro à editora, escrevendo para: <code>novatec@novatec.com.br</code>.</p>
<p>Temos uma página web para este livro na qual incluímos erratas, exemplos e quaisquer outras informações adicionais.</p>
<ul>
<li>Página da edição em português</li>
</ul>
<p>        <a href="http://www.novatec.com.br/catalogo/7522508-pense-em-python">http://www.novatec.com.br/catalogo/7522508-pense-em-python</a></p>
<ul>
<li>Página da edição original em inglês</li>
</ul>
<p>        <a href="http://bit.ly/think-python_2E">http://bit.ly/think-python_2E</a></p>
<p>Para obter mais informações sobre os livros da Novatec, acesse nosso site em <a href="http://www.novatec.com.br">http://www.novatec.com.br</a>.</p>
<h2><a class="header" href="#agradecimentos" id="agradecimentos">Agradecimentos</a></h2>
<p>Muito obrigado a Jeff Elkner, que traduziu meu livro de Java para o Python, o que deu início a este projeto e me apresentou ao que acabou sendo a minha linguagem favorita.</p>
<p>Agradeço também a Chris Meyers, que contribuiu em várias seções do <em>Pense como um cientista da computação</em>.</p>
<p>Obrigado à Fundação do Software Livre pelo desenvolvimento da Licença de Documentação Livre GNU, que me ajudou a tornar possível a colaboração com Jeff e Chris, e ao Creative Commons pela licença que estou usando agora.</p>
<p>Obrigado aos editores do Lulu, que trabalharam no <em>Pense como um cientista da computação</em>.</p>
<p>Obrigado aos editores da O’Reilly Media, que trabalharam no <em>Pense em Python</em>.</p>
<p>Obrigado a todos os estudantes que trabalharam com versões anteriores deste livro e a todos os contribuidores (listados a seguir) que enviaram correções e sugestões.</p>
<h2><a class="header" href="#lista-de-contribuidores" id="lista-de-contribuidores">Lista de contribuidores</a></h2>
<p>Mais de cem leitores perspicazes e atentos enviaram sugestões e correções nos últimos anos. Suas contribuições e entusiasmo por este projeto foram inestimáveis.</p>
<p>Se tiver alguma sugestão ou correção, por favor, envie um email a <code>feedback@thinkpython.com</code>. Se eu fizer alguma alteração baseada no seu comentário, acrescentarei seu nome à lista de contribuidores (a menos que você peça para eu omitir a informação).</p>
<p>Se você incluir pelo menos uma parte da frase onde o erro aparece, é mais fácil para eu procurá-lo. Também pode ser o número da página e seção, mas aí é um pouquinho mais difícil de encontrar o erro a ser corrigido. Obrigado!</p>
<ul>
<li>
<p>Lloyd Hugh Allen enviou uma correção da Seção 8.4.</p>
</li>
<li>
<p>Yvon Boulianne enviou a correção de um erro semântico no Capítulo 5.</p>
</li>
<li>
<p>Fred Bremmer enviou uma correção da Seção 2.1.</p>
</li>
<li>
<p>Jonah Cohen escreveu os scripts em Perl para converter a fonte de LaTeX deste livro para o belo HTML.</p>
</li>
<li>
<p>Michael Conlon enviou uma correção gramatical do Capítulo 2 e uma melhoria no estilo do Capítulo 1, além de iniciar a discussão sobre os aspectos técnicos de interpretadores.</p>
</li>
<li>
<p>Benoit Girard enviou uma correção a um erro humorístico na Seção 5.6.</p>
</li>
<li>
<p>Courtney Gleason e Katherine Smith escreveram horsebet.py, que foi usado como um estudo de caso em uma versão anterior do livro. O programa agora pode ser encontrado no site.</p>
</li>
<li>
<p>Lee Harr enviou mais correções do que temos espaço para relacionar aqui, e na verdade ele deve ser apontado como um dos editores principais do texto.</p>
</li>
<li>
<p>James Kaylin é um estudante que usa o texto. Ele enviou várias correções.</p>
</li>
<li>
<p>David Kershaw corrigiu a função catTwice defeituosa na Seção 3.10.</p>
</li>
<li>
<p>Eddie Lam entregou diversas correções aos Capítulos 1, 2, e 3. Ele também corrigiu o Makefile para criar um índice na primeira vez que rodar e nos ajudou a estabelecer um esquema de versionamento.</p>
</li>
<li>
<p>Man-Yong Lee enviou uma correção do código de exemplo na Seção 2.4.</p>
</li>
<li>
<p>David Mayo indicou que a palavra “inconscientemente” no Capítulo 1 devia ser alterada para “subconscientemente”.</p>
</li>
<li>
<p>Chris McAloon enviou várias correções para as Seções 3.9 e 3.10.</p>
</li>
<li>
<p>Matthew J. Moelter tem contribuído já há um bom tempo e entregou diversas correções e sugestões para o livro.</p>
</li>
<li>
<p>Simon Dicon Montford informou que havia uma definição de função ausente e vários erros de ortografia no Capítulo 3. Ele também encontrou erros na função increment no Capítulo 13.</p>
</li>
<li>
<p>John Ouzts corrigiu a definição de “valor de retorno” no Capítulo 3.</p>
</li>
<li>
<p>Kevin Parks enviou comentários e sugestões valiosos para melhorar a distribuição do livro.</p>
</li>
<li>
<p>David Pool encontrou um erro de ortografia no glossário do Capítulo 1, e também enviou palavras gentis de encorajamento.</p>
</li>
<li>
<p>Michael Schmitt enviou uma correção ao capítulo sobre arquivos e exceções.</p>
</li>
<li>
<p>Robin Shaw indicou um erro na Seção 13.1, onde a função printTime foi usada em um exemplo sem ser definida.</p>
</li>
<li>
<p>Paul Sleigh encontrou um erro no Capítulo 7 e um bug no script em Perl de Jonah Cohen, que gera o HTML do LaTeX.</p>
</li>
<li>
<p>Craig T. Snydal está testando o texto em um curso na Drew University. Ele contribuiu com várias sugestões valiosas e correções.</p>
</li>
<li>
<p>Ian Thomas e seus alunos estão usando o texto em um curso de programação. Eles são os primeiros a testar os capítulos da segunda metade do livro e fizeram muitas correções e sugestões.</p>
</li>
<li>
<p>Keith Verheyden enviou uma correção no Capítulo 3.</p>
</li>
<li>
<p>Peter Winstanley nos avisou sobre um erro antigo no latim do Capítulo 3.</p>
</li>
<li>
<p>Chris Wrobel fez correções ao código no capítulo sobre arquivos E/S e exceções.</p>
</li>
<li>
<p>Moshe Zadka fez contribuições inestimáveis para este projeto. Além de escrever o primeiro rascunho do capítulo sobre Dicionários, ele forneceu orientação contínua nas primeiras etapas do livro.</p>
</li>
<li>
<p>Christoph Zwerschke enviou várias correções e sugestões pedagógicas, e explicou a diferença entre gleich e selbe.</p>
</li>
<li>
<p>James Mayer enviou-nos um monte de erros tipográficos e ortográficos, inclusive dois da lista de contribuidores.</p>
</li>
<li>
<p>Hayden McAfee percebeu uma inconsistência potencialmente confusa entre dois exemplos.</p>
</li>
<li>
<p>Angel Arnal faz parte de uma equipe internacional de tradutores que trabalhou na versão do texto para o espanhol. Ele também encontrou vários erros na versão em inglês.</p>
</li>
<li>
<p>Tauhidul Hoque e Lex Berezhny criaram as ilustrações do Capítulo 1 e melhoraram muitas das outras ilustrações.</p>
</li>
<li>
<p>O Dr. Michele Alzetta pegou um erro no Capítulo 8 e enviou alguns comentários pedagógicos interessantes e sugestões sobre Fibonacci e o jogo do Mico.</p>
</li>
<li>
<p>Andy Mitchell pegou um erro de ortografia no Capítulo 1 e um exemplo ruim no Capítulo 2.</p>
</li>
<li>
<p>Kalin Harvey sugeriu um esclarecimento no Capítulo 7 e achou alguns erros de ortografia.</p>
</li>
<li>
<p>Christopher P. Smith encontrou vários erros de ortografia e ajudou-nos a atualizar o livro para o Python 2.2.</p>
</li>
<li>
<p>David Hutchins encontrou um erro de ortografia no prefácio.</p>
</li>
<li>
<p>Gregor Lingl é professor de Python em uma escola de Ensino Médio em Viena, na Áustria. Ele está trabalhando em uma tradução do livro para o alemão e encontrou alguns erros feios no Capítulo 5.</p>
</li>
<li>
<p>Julie Peters achou um erro de ortografia no prefácio.</p>
</li>
<li>
<p>Florin Oprina enviou uma melhoria para o makeTime, uma correção no printTime e um belo erro de ortografia.</p>
</li>
<li>
<p>D. J. Webre sugeriu um esclarecimento no Capítulo 3.</p>
</li>
<li>
<p>Ken encontrou um punhado de erros nos Capítulos 8, 9 e 11.</p>
</li>
<li>
<p>Ivo Wever achou um erro de ortografia no Capítulo 5 e sugeriu um esclarecimento no Capítulo 3.</p>
</li>
<li>
<p>Curtis Yanko sugeriu um esclarecimento no Capítulo 2.</p>
</li>
<li>
<p>Ben Logan enviou vários erros de ortografia e problemas com a tradução do livro para HTML.</p>
</li>
<li>
<p>Jason Armstrong percebeu que faltava uma palavra no Capítulo 2.</p>
</li>
<li>
<p>Louis Cordier notou um ponto no Capítulo 16 onde o código não correspondia com o texto.</p>
</li>
<li>
<p>Brian Caim sugeriu vários esclarecimentos nos Capítulos 2 e 3.</p>
</li>
<li>
<p>Rob Black entregou um monte de correções, inclusive algumas alterações para Python 2.2.</p>
</li>
<li>
<p>Jean-Philippe Rey, da École Centrale Paris, enviou uma série de patches, inclusive algumas atualizações do Python 2.2 e outras melhorias bem pensadas.</p>
</li>
<li>
<p>Jason Mader, da George Washington University, fez uma série de sugestões e correções úteis.</p>
</li>
<li>
<p>Jan Gundtofte-Bruun nos lembrou de que “un erro” é um erro.</p>
</li>
<li>
<p>Abel David e Alexis Dinno nos lembraram de que o plural de “matriz” é “matrizes”, não “matrixes”. Este erro esteve no livro por anos, mas dois leitores com as mesmas iniciais informaram a respeito dele no mesmo dia. Bizarro.</p>
</li>
<li>
<p>Charles Thayer nos estimulou a sumir com os pontos e vírgulas que tínhamos posto no final de algumas instruções e a otimizar nosso uso de “argumento” e “parâmetro”.</p>
</li>
<li>
<p>Roger Sperberg indicou uma parte distorcida de lógica no Capítulo 3.</p>
</li>
<li>
<p>Sam Bull indicou um parágrafo confuso no Capítulo 2.</p>
</li>
<li>
<p>Andrew Cheung indicou duas ocorrências de “uso antes da definição”.</p>
</li>
<li>
<p>C. Corey Capel notou uma palavra ausente e um erro de ortografia no Capítulo 4.</p>
</li>
<li>
<p>Alessandra ajudou a eliminar algumas coisas confusas do Turtle.</p>
</li>
<li>
<p>Wim Champagne encontrou uma confusão de palavras em um exemplo de dicionário.</p>
</li>
<li>
<p>Douglas Wright indicou um problema com a divisão pelo piso em arc.</p>
</li>
<li>
<p>Jared Spindor encontrou uma confusão no fim de uma frase.</p>
</li>
<li>
<p>Lin Peiheng enviou várias sugestões muito úteis.</p>
</li>
<li>
<p>Ray Hagtvedt enviou dois erros e um quase erro.</p>
</li>
<li>
<p>Torsten Hübsch indicou uma inconsistência no Swampy.</p>
</li>
<li>
<p>Inga Petuhhov corrigiu um exemplo no Capítulo 14.</p>
</li>
<li>
<p>Arne Babenhauserheide enviou várias correções úteis.</p>
</li>
<li>
<p>Mark E. Casida é é bom em encontrar palavras repetidas.</p>
</li>
<li>
<p>Scott Tyler preencheu um que faltava. E em seguida enviou um monte de correções.</p>
</li>
<li>
<p>Gordon Shephard enviou várias correções, todas em emails separados.</p>
</li>
<li>
<p>Andrew Turner notou um erro no Capítulo 8.</p>
</li>
<li>
<p>Adam Hobart corrigiu um problema com a divisão pelo piso em arc.</p>
</li>
<li>
<p>Daryl Hammond e Sarah Zimmerman indicaram que eu trouxe o math.pi para a mesa cedo demais. E Zim achou um erro de ortografia.</p>
</li>
<li>
<p>George Sass encontrou um bug em uma seção de depuração.</p>
</li>
<li>
<p>Brian Bingham sugeriu o Exercício 11.5.</p>
</li>
<li>
<p>Leah Engelbert-Fenton indicou que usei tuple como um nome de variável, contrariando meu próprio conselho. E, em seguida, encontrou uma porção de erros de ortografia e um “uso antes da definição”.</p>
</li>
<li>
<p>Joe Funke achou um erro de ortografia.</p>
</li>
<li>
<p>Chao-chao Chen encontrou uma inconsistência no exemplo de Fibonacci.</p>
</li>
<li>
<p>Jeff Paine sabe a diferença entre espaço e spam.</p>
</li>
<li>
<p>Lubos Pintes enviou um erro de ortografia.</p>
</li>
<li>
<p>Gregg Lind e Abigail Heithoff sugeriram o Exercício 14.3.</p>
</li>
<li>
<p>Max Hailperin entregou uma série de correções e sugestões. Max é um dos autores das extraordinárias Abstrações Concretas (Tecnologia de curso, 1998), que você pode querer ler quando terminar este livro.</p>
</li>
<li>
<p>Chotipat Pornavalai encontrou um erro em uma mensagem de erro.</p>
</li>
<li>
<p>Stanislaw Antol enviou uma lista com várias sugestões úteis.</p>
</li>
<li>
<p>Eric Pashman enviou uma série de correções para os Capítulos 4-11.</p>
</li>
<li>
<p>Miguel Azevedo encontrou alguns erros de ortografia.</p>
</li>
<li>
<p>Jianhua Liu enviou uma longa lista de correções.</p>
</li>
<li>
<p>Nick King encontrou uma palavra que faltava.</p>
</li>
<li>
<p>Martin Zuther enviou uma longa lista de sugestões.</p>
</li>
<li>
<p>Adam Zimmerman encontrou uma inconsistência em uma ocorrência de “ocorrência” e vários outros erros.</p>
</li>
<li>
<p>Ratnakar Tiwari sugeriu uma nota de rodapé explicando triângulos degenerados.</p>
</li>
<li>
<p>Anurag Goel sugeriu outra solução para is_abecedarian e enviou algumas correções adicionais. E ele sabe soletrar Jane Austen.</p>
</li>
<li>
<p>Kelli Kratzer notou um dos erros de ortografia.</p>
</li>
<li>
<p>Mark Griffiths indicou um exemplo confuso no Capítulo 3.</p>
</li>
<li>
<p>Roydan Ongie encontrou um erro no meu método de Newton.</p>
</li>
<li>
<p>Patryk Wolowiec me ajudou com um problema na versão do HTML.</p>
</li>
<li>
<p>Mark Chonofsky me falou de uma nova palavra-chave no Python 3.</p>
</li>
<li>
<p>Russell Coleman ajudou com a minha geometria.</p>
</li>
<li>
<p>Wei Huang notou vários erros tipográficos.</p>
</li>
<li>
<p>Karen Barber achou o erro de ortografia mais antigo no livro.</p>
</li>
<li>
<p>Nam Nguyen encontrou um erro de ortografia e indicou que usei o Decorator, mas não mencionei o nome.</p>
</li>
<li>
<p>Stéphane Morin enviou várias correções e sugestões.</p>
</li>
<li>
<p>Paul Stoop corrigiu um erro de ortografia em uses_only.</p>
</li>
<li>
<p>Eric Bronner indicou uma confusão na discussão da ordem de operações.</p>
</li>
<li>
<p>Alexandros Gezerlis definiu um novo padrão para o número e a qualidade das sugestões que enviou. Estamos profundamente gratos!</p>
</li>
<li>
<p>Gray Thomas sabe diferenciar a direita da esquerda.</p>
</li>
<li>
<p>Giovanni Escobar Sosa enviou uma longa lista de correções e sugestões.</p>
</li>
<li>
<p>Alix Etienne corrigiu uma das URLs.</p>
</li>
<li>
<p>Kuang He encontrou um erro de ortografia.</p>
</li>
<li>
<p>Daniel Neilson corrigiu um erro sobre a ordem de operações.</p>
</li>
<li>
<p>Will McGinnis indicou que polyline foi definida de forma diferente em dois lugares.</p>
</li>
<li>
<p>Swarup Sahoo notou que faltava um ponto e vírgula.</p>
</li>
<li>
<p>Frank Hecker indicou que um exercício estava mal especificado e encontrou alguns links quebrados.</p>
</li>
<li>
<p>Animesh B me ajudou a esclarecer um exemplo confuso.</p>
</li>
<li>
<p>Martin Caspersen encontrou dois erros de arredondamento.</p>
</li>
<li>
<p>Gregor Ulm enviou várias correções e sugestões.</p>
</li>
<li>
<p>Dimitrios Tsirigkas sugeriu que eu esclarecesse um exercício.</p>
</li>
<li>
<p>Carlos Tafur enviou uma página de correções e sugestões.</p>
</li>
<li>
<p>Martin Nordsletten encontrou um bug na solução de um exercício.</p>
</li>
<li>
<p>Lars O.D. Christensen encontrou uma referência quebrada.</p>
</li>
<li>
<p>Vitor Simeone encontrou um erro de ortografia.</p>
</li>
<li>
<p>Sven Hoexter indicou que uma entrada de uma variável nomeada se sobrepõe a uma função integrada.</p>
</li>
<li>
<p>Viet Le encontrou um erro de ortografia.</p>
</li>
<li>
<p>Stephen Gregory indicou o problema com cmp no Python 3.</p>
</li>
<li>
<p>Matthew Shultz me avisou sobre um link quebrado.</p>
</li>
<li>
<p>Lokesh Kumar Makani me avisou sobre alguns links quebrados e algumas alterações em mensagens de erro.</p>
</li>
<li>
<p>Ishwar Bhat corrigiu minha declaração do último teorema de Fermat.</p>
</li>
<li>
<p>Brian McGhie sugeriu um esclarecimento.</p>
</li>
<li>
<p>Andrea Zanella traduziu o livro para o italiano e enviou uma série de correções ao longo do caminho.</p>
</li>
<li>
<p>Muito, muito obrigado a Melissa Lewis e Luciano Ramalho pelos comentários e sugestões excelentes na segunda edição.</p>
</li>
<li>
<p>Obrigado a Harry Percival do PythonAnywhere por ajudar as pessoas a começar a usar o Python em um navegador.</p>
</li>
<li>
<p>Xavier Van Aubel fez várias correções úteis na segunda edição.</p>
</li>
</ul>
<h1><a class="header" href="#capítulo-1-a-jornada-do-a-href01-a-jornada-do-programa08-glossariohtmlprogramaprogramaa" id="capítulo-1-a-jornada-do-a-href01-a-jornada-do-programa08-glossariohtmlprogramaprogramaa">Capítulo 1: A jornada do <a href="01-a-jornada-do-programa/08-glossario.html#programa">programa</a></a></h1>
<p>O objetivo deste livro é ensinar a pensar como um cientista da computação. Esta forma de pensar combina algumas das melhores características da matemática, da engenharia e das ciências naturais. Assim como os matemáticos, os cientistas da computação usam linguagens formais para denotar ideias (especificamente operações de computação). Como engenheiros, eles projetam coisas, reunindo componentes em sistemas e avaliando as opções de melhor retorno entre as alternativas à disposição. Como cientistas, observam o comportamento de sistemas complexos, formam hipóteses e testam previsões.</p>
<p>A habilidade específica mais importante de um cientista da computação é a <a href="01-a-jornada-do-programa/08-glossario.html#resolu%C3%A7%C3%A3o-de-problemas">resolução de problemas</a>. Resolução de problemas significa a capacidade de formular problemas, pensar criativamente em soluções e expressar uma solução de forma clara e precisa. Assim, o processo de aprender a programar é uma oportunidade excelente para exercitar a habilidade de resolver problemas. É por isso que este capítulo se chama “A jornada do programa”.</p>
<p>Em um nível você aprenderá a programar, uma habilidade útil por si mesma. Em outro nível usará a programação como um meio para um fim. Conforme avançarmos, este fim ficará mais claro.</p>
<h2><a class="header" href="#11---o-que-é-um-a-href01-a-jornada-do-programa08-glossariohtmlprogramaprogramaa" id="11---o-que-é-um-a-href01-a-jornada-do-programa08-glossariohtmlprogramaprogramaa">1.1 - O que é um <a href="01-a-jornada-do-programa/08-glossario.html#programa">programa</a>?</a></h2>
<p>Um <strong>programa</strong> é uma sequência de instruções que especifica como executar uma operação de computação. A operação de computação pode ser algo matemático, como solucionar um sistema de equações ou encontrar as raízes de um polinômio, mas também pode ser uma operação de computação simbólica, como a busca e a substituição de textos em um documento; ou algo gráfico, como o processamento de uma imagem ou a reprodução de um vídeo.</p>
<p>Os detalhes parecem diferentes em linguagens diferentes, mas algumas instruções básicas aparecem em quase todas as linguagens:</p>
<h5><a class="header" href="#entrada" id="entrada">entrada</a></h5>
<p>    Receber dados do teclado, de um arquivo, da rede ou de algum outro dispositivo.</p>
<h5><a class="header" href="#saída" id="saída">saída</a></h5>
<p>    Exibir dados na tela, salvá-los em um arquivo, enviá-los pela rede etc.</p>
<h5><a class="header" href="#matemática" id="matemática">matemática</a></h5>
<p>    Executar operações matemáticas básicas como adição e multiplicação.</p>
<h5><a class="header" href="#execução-condicional" id="execução-condicional">execução condicional</a></h5>
<p>    Verificar a existência de certas condições e executar o código adequado.</p>
<h5><a class="header" href="#repetição" id="repetição">repetição</a></h5>
<p>    Executar várias vezes alguma ação, normalmente com algumas variações.</p>
<p>Acredite ou não, isto é basicamente tudo o que é preciso saber. Cada programa que você já usou, complicado ou não, é composto de instruções muito parecidas com essas. Podemos então chegar à conclusão de que programar é o processo de quebrar uma tarefa grande e complexa em subtarefas cada vez menores, até que estas sejam simples o suficiente para serem executadas por uma dessas instruções básicas.</p>
<h2><a class="header" href="#12---execução-do-python" id="12---execução-do-python">1.2 - Execução do Python</a></h2>
<p>Um dos desafios de começar a usar Python é ter que instalar no seu computador o próprio <a href="01-a-jornada-do-programa/08-glossario.html#programa">programa</a> e outros relacionados. Se tiver familiaridade com o seu sistema operacional, e especialmente se não tiver problemas com a interface de linha de comando, você não terá dificuldade para instalar o Python. Mas para principiantes pode ser trabalhoso aprender sobre administração de sistemas e programação ao mesmo tempo.</p>
<p>Para evitar esse problema, recomendo que comece a executar o Python em um navegador. Depois, quando você já conhecer o Python um pouco mais, darei sugestões para instalá-lo em seu computador.</p>
<p>Há uma série de sites que ajudam a usar e executar o Python. Se já tem um favorito, vá em frente e use-o. Senão, recomendo o PythonAnywhere. Apresento instruções detalhadas sobre os primeiros passos no link <a href="http://tinyurl.com/thinkpython2e">http://tinyurl.com/thinkpython2e</a>.</p>
<p>Há duas versões do Python, o Python 2 e o Python 3. Como elas são muito semelhantes, se você aprender uma versão, é fácil trocar para a outra. Como é iniciante, você encontrará poucas diferenças. Este livro foi escrito para o Python 3, mas também incluí algumas notas sobre o Python 2.</p>
<p>O <strong>interpretador</strong> do Python é um programa que lê e executa o código Python. Dependendo do seu ambiente, é possível iniciar o <a href="01-a-jornada-do-programa/08-glossario.html#interpretador">interpretador</a> clicando em um ícone, ou digitando python em uma linha de comando. Quando ele iniciar, você deverá ver uma saída como esta:</p>
<pre><code class="language-python">Python 3.4.0 (default, Jun 19 2015, 14:20:21)
[GCC 4.8.2] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt;
</code></pre>
<p>As três primeiras linhas contêm informações sobre o interpretador e o sistema operacional em que está sendo executado, portanto podem ser diferentes para você. Mas é preciso conferir se o número da versão, que é 3.4.0 neste exemplo, começa com 3, o que indica que você está executando o Python 3. Se começar com 2, você está executando (adivinhe!) o Python 2.</p>
<p>A última linha é um <a href="01-a-jornada-do-programa/08-glossario.html#prompt">prompt</a> indicando que o interpretador está pronto para você digitar o código. Se digitar uma linha de código e pressionar Enter, o interpretador exibe o resultado:</p>
<pre><code class="language-python">&gt;&gt;&gt; 1 + 1
2
</code></pre>
<p>Agora você está pronto para começar. Daqui em diante, vou supor que você sabe como inicializar o interpretador do Python e executar o código.</p>
<h2><a class="header" href="#13---o-primeiro-a-href01-a-jornada-do-programa08-glossariohtmlprogramaprogramaa" id="13---o-primeiro-a-href01-a-jornada-do-programa08-glossariohtmlprogramaprogramaa">1.3 - O primeiro <a href="01-a-jornada-do-programa/08-glossario.html#programa">programa</a></a></h2>
<p>Tradicionalmente, o primeiro programa que se escreve em uma nova linguagem chama-se “Hello, World!”, porque tudo o que faz é exibir as palavras “Hello, World!” na tela. No Python, ele se parece com isto:</p>
<pre><code class="language-python">&gt;&gt;&gt; print('Hello, World!')
</code></pre>
<p>Este é um exemplo de uma <a href="01-a-jornada-do-programa/08-glossario.html#instru%C3%A7%C3%A3o-print">instrução print</a> (instrução de impressão), embora na realidade ela não imprima nada em papel. Ela exibe um resultado na tela. Nesse caso, o resultado são as palavras:</p>
<pre><code class="language-python">Hello, World!
</code></pre>
<p>As aspas apenas marcam o começo e o fim do texto a ser exibido; elas não aparecem no resultado.</p>
<p>Os parênteses indicam que o print é uma função. Veremos funções no Capítulo 3.</p>
<p>No Python 2, a instrução print é ligeiramente diferente; ela não é uma função, portanto não usa parênteses.</p>
<pre><code class="language-python">&gt;&gt;&gt; print 'Hello, World!'
</code></pre>
<p>Esta distinção fará mais sentido em breve, mas isso é o suficiente para começar.</p>
<h2><a class="header" href="#14---operadores-aritméticos" id="14---operadores-aritméticos">1.4 - Operadores aritméticos</a></h2>
<p>Depois do “Hello, World”, o próximo passo é a aritmética. O Python tem operadores, que são símbolos especiais representando operações de computação, como adição e multiplicação.</p>
<p>Os operadores +, - e * executam a adição, a subtração e a multiplicação, como nos seguintes exemplos:</p>
<pre><code class="language-python">&gt;&gt;&gt; 40 + 2
42
&gt;&gt;&gt; 43 - 1
42
&gt;&gt;&gt; 6 * 7
42
O operador / executa a divisão:
&gt;&gt;&gt; 84 / 2
42.0
</code></pre>
<p>Pode ser que você fique intrigado pelo resultado ser 42.0 em vez de 42. Vou explicar isso na próxima seção.</p>
<p>Finalmente, o operador ** executa a exponenciação; isto é, eleva um número a uma potência:</p>
<pre><code class="language-python">&gt;&gt;&gt; 6 ** 2 + 6
42
</code></pre>
<p>Em algumas outras linguagens, o ^ é usado para a exponenciação, mas no Python é um operador bitwise, chamado XOR. Se não tiver familiaridade com operadores bitwise, o resultado o surpreenderá:</p>
<pre><code class="language-python">&gt;&gt;&gt; 6 ^ 2
4
</code></pre>
<p>Não abordarei operadores bitwise neste livro, mas você pode ler sobre eles em <a href="http://wiki.python.org/moin/BitwiseOperators">http://wiki.python.org/moin/BitwiseOperators</a>.</p>
<h2><a class="header" href="#15---valores-e-tipos" id="15---valores-e-tipos">1.5 - Valores e tipos</a></h2>
<p>Um <a href="01-a-jornada-do-programa/08-glossario.html#valor">valor</a> é uma das coisas básicas com as quais um <a href="01-a-jornada-do-programa/08-glossario.html#programa">programa</a> trabalha, como uma letra ou um número. Alguns valores que vimos até agora foram 2, 42.0 e 'Hello, World!'.</p>
<p>Esses valores pertencem a tipos diferentes: 2 é um número <a href="01-a-jornada-do-programa/08-glossario.html#inteiro">inteiro</a>, 42.0 é um número de <a href="01-a-jornada-do-programa/08-glossario.html#ponto-flutuante">ponto flutuante</a> e 'Hello, World!' é uma <a href="01-a-jornada-do-programa/08-glossario.html#string">string</a>, assim chamada porque as letras que contém estão em uma sequência em cadeia.</p>
<p>Se não tiver certeza sobre qual é o <a href="01-a-jornada-do-programa/08-glossario.html#tipo">tipo</a> de certo valor, o <a href="01-a-jornada-do-programa/08-glossario.html#interpretador">interpretador</a> pode dizer isso a você:</p>
<pre><code class="language-python">&gt;&gt;&gt; type(2)
&lt;class 'int'&gt;
&gt;&gt;&gt; type(42.0)
&lt;class 'float'&gt;
&gt;&gt;&gt; type('Hello, World!')
&lt;class 'str'&gt;
</code></pre>
<p>Nesses resultados, a palavra “class” [classe] é usada no sentido de categoria; um tipo é uma categoria de valores.</p>
<p>Como se poderia esperar, números inteiros pertencem ao tipo int, strings pertencem ao tipo str e os números de ponto flutuante pertencem ao tipo float.</p>
<p>E valores como '2' e '42.0'? Parecem números, mas estão entre aspas como se fossem strings:</p>
<pre><code class="language-python">&gt;&gt;&gt; type('2')
&lt;class 'str'&gt;
&gt;&gt;&gt; type('42.0')
&lt;class 'str'&gt;
</code></pre>
<p>Então são strings.</p>
<p>Ao digitar um número inteiro grande, alguns podem usar a notação americana, com vírgulas entre grupos de dígitos, como em 1,000,000. Este não é um número inteiro legítimo no Python e resultará em:</p>
<pre><code class="language-python">&gt;&gt;&gt; 1,000,000
(1, 0, 0)
</code></pre>
<p>O que não é de modo algum o que esperávamos! O Python interpreta 1,000,000 como uma sequência de números inteiros separados por vírgulas. Aprenderemos mais sobre este tipo de sequência mais adiante.</p>
<h2><a class="header" href="#16---linguagens-formais-e-naturais" id="16---linguagens-formais-e-naturais">1.6 - Linguagens formais e naturais</a></h2>
<p>As linguagens naturais são os idiomas que as pessoas falam, como inglês, espanhol e francês. Elas não foram criadas pelas pessoas (embora as pessoas tentem impor certa ordem a elas); desenvolveram-se naturalmente.</p>
<p>As linguagens formais são linguagens criadas pelas pessoas para aplicações específicas. Por exemplo, a notação que os matemáticos usam é uma <a href="01-a-jornada-do-programa/08-glossario.html#linguagem-formal">linguagem formal</a> especialmente boa para denotar relações entre números e símbolos. Os químicos usam uma linguagem formal para representar a estrutura química de moléculas. E o mais importante:</p>
<p>As linguagens de programação são idiomas formais criados para expressar operações de computação.</p>
<p>As linguagens formais geralmente têm regras de <a href="01-a-jornada-do-programa/08-glossario.html#sintaxe">sintaxe</a> estritas que governam a estrutura de declarações. Por exemplo, na matemática a declaração 3 + 3 = 6 tem uma sintaxe correta, mas não 3 + = 3$6. Na química, H2O é uma fórmula sintaticamente correta, mas 2Zz não é.</p>
<p>As regras de sintaxe vêm em duas categorias relativas a símbolos e estrutura. Os símbolos são os elementos básicos da linguagem, como palavras, números e elementos químicos. Um dos problemas com 3 + = 3$6 é que o $ não é um <a href="01-a-jornada-do-programa/08-glossario.html#s%C3%ADmbolo">símbolo</a> legítimo na matemática (pelo menos até onde eu sei). De forma similar, 2Zz não é legítimo porque não há nenhum elemento com a abreviatura Zz.</p>
<p>O segundo <a href="01-a-jornada-do-programa/08-glossario.html#tipo">tipo</a> de regra de sintaxe refere-se ao modo no qual os símbolos são combinados. A equação 3 + = 3 não é legítima porque, embora + e = sejam símbolos legítimos, não se pode ter um na sequência do outro. De forma similar, em uma fórmula química o subscrito vem depois do nome de elemento, não antes.</p>
<p>Esta é um@ frase bem estruturada em portuguê$, mas com s*mbolos inválidos. Esta frase todos os símbolos válidos tem, mas estrutura válida sem.</p>
<p>Ao ler uma frase em português ou uma declaração em uma linguagem formal, é preciso compreender a estrutura (embora em uma <a href="01-a-jornada-do-programa/08-glossario.html#linguagem-natural">linguagem natural</a> você faça isto de forma subconsciente). Este processo é chamado de <a href="01-a-jornada-do-programa/08-glossario.html#an%C3%A1lise">análise</a>.</p>
<p>Embora as linguagens formais e naturais tenham muitas características em comum – símbolos, estrutura e sintaxe – há algumas diferenças:</p>
<h5><a class="header" href="#ambiguidade" id="ambiguidade">ambiguidade</a></h5>
<p>    As linguagens naturais são cheias de ambiguidade e as pessoas lidam com isso usando pistas contextuais e outras informações. As linguagens formais são criadas para ser quase ou completamente inequívocas, ou seja, qualquer afirmação tem exatamente um significado, independentemente do contexto.</p>
<h5><a class="header" href="#redundância" id="redundância">redundância</a></h5>
<p>    Para compensar a ambiguidade e reduzir equívocos, as linguagens naturais usam muita redundância. Por causa disso, muitas vezes são verborrágicas. As linguagens formais são menos redundantes e mais concisas.</p>
<h5><a class="header" href="#literalidade" id="literalidade">literalidade</a></h5>
<p>    As linguagens naturais são cheias de expressões e metáforas. Se eu digo “Caiu a ficha”, provavelmente não há ficha nenhuma na história, nem nada que tenha caído (esta é uma expressão para dizer que alguém entendeu algo depois de certo período de confusão). As linguagens formais têm significados exatamente iguais ao que expressam.</p>
<p>Como todos nós crescemos falando linguagens naturais, às vezes é difícil se ajustar a linguagens formais. A diferença entre a linguagem natural e a formal é semelhante à diferença entre poesia e prosa, mas vai além:</p>
<h5><a class="header" href="#poesia" id="poesia">Poesia</a></h5>
<p>    As palavras são usadas tanto pelos sons como pelos significados, e o poema <a href="01-a-jornada-do-programa/08-glossario.html#inteiro">inteiro</a> cria um efeito ou resposta emocional. A ambiguidade não é apenas comum, mas muitas vezes proposital.</p>
<h5><a class="header" href="#prosa" id="prosa">Prosa</a></h5>
<p>    O significado literal das palavras é o mais importante e a estrutura contribui para este significado. A prosa é mais acessível à análise que a poesia, mas muitas vezes ainda é ambígua.</p>
<h5><a class="header" href="#programas" id="programas">Programas</a></h5>
<p>    A significado de um <a href="01-a-jornada-do-programa/08-glossario.html#programa">programa</a> de computador é inequívoco e literal e pode ser entendido inteiramente pela análise dos símbolos e da estrutura.</p>
<p>As linguagens formais são mais densas que as naturais, então exigem mais tempo para a leitura. Além disso, a estrutura é importante, então nem sempre é melhor ler de cima para baixo e da esquerda para a direita. Em vez disso, aprenda a analisar o programa primeiro, identificando os símbolos e interpretando a estrutura. E os detalhes fazem diferença. Pequenos erros em ortografia e pontuação, que podem não importar tanto nas linguagens naturais, podem fazer uma grande diferença em uma língua formal.</p>
<h2><a class="header" href="#17---depuração" id="17---depuração">1.7 - Depuração</a></h2>
<p>Os programadores erram. Por um capricho do destino, erros de programação são chamados de bugs (insetos) e o processo de rastreá-los chama-se <a href="01-a-jornada-do-programa/08-glossario.html#depura%C3%A7%C3%A3o">depuração</a> (debugging).</p>
<p>Programar, e especialmente fazer a depuração, às vezes traz emoções fortes. Se tiver dificuldade com certo <a href="01-a-jornada-do-programa/08-glossario.html#bug">bug</a>, você pode ficar zangado, desesperado ou constrangido.</p>
<p>Há evidências de que as pessoas respondem naturalmente a computadores como se fossem pessoas. Quando funcionam bem, pensamos neles como parceiros da equipe, e quando são teimosos ou grosseiros, respondemos a eles do mesmo jeito que fazemos com pessoas grosseiras e teimosas (Reeves e Nass, <a href="https://en.wikipedia.org/wiki/The_Media_Equation"><em>The Media Equation: How People Treat Computers, Television, and New Media Like Real People and Places</em></a> — <em>A equação da mídia: como as pessoas tratam os computadores, a televisão e as novas mídias como se fossem pessoas e lugares reais</em>).</p>
<p>Prepare-se para essas reações, pois isso pode ajudar a lidar com elas. Uma abordagem é pensar no computador como um funcionário com certas vantagens, como velocidade e precisão, e certas desvantagens, como a falta de empatia e a incapacidade de compreender um contexto mais amplo.</p>
<p>Seu trabalho é ser um bom gerente: encontrar formas de aproveitar as vantagens e atenuar as desvantagens. E também encontrar formas de usar suas emoções para lidar com o problema sem deixar suas reações interferirem na sua capacidade de trabalho.</p>
<p>Aprender a depurar erros pode ser frustrante, mas é uma habilidade valiosa, útil para muitas atividades além da programação. No fim de cada capítulo há uma seção como esta, com as minhas sugestões para fazer a depuração. Espero que sejam úteis!</p>
<h2><a class="header" href="#18---glossário" id="18---glossário">1.8 - Glossário</a></h2>
<h5><a class="header" href="#resolução-de-problemas" id="resolução-de-problemas">resolução de problemas</a></h5>
<p>    O processo de formular um problema, encontrar uma solução e expressá-la.</p>
<h5><a class="header" href="#linguagem-de-alto-nível" id="linguagem-de-alto-nível">linguagem de alto nível</a></h5>
<p>    Uma linguagem de programação como Python, que foi criada com o intuito de ser fácil para os humanos escreverem e lerem.</p>
<h5><a class="header" href="#linguagem-de-baixo-nível" id="linguagem-de-baixo-nível">linguagem de baixo nível</a></h5>
<p>    Uma linguagem de programação criada para o computador executar com facilidade; também chamada de “linguagem de máquina” ou “linguagem assembly”.</p>
<h5><a class="header" href="#portabilidade" id="portabilidade">portabilidade</a></h5>
<p>    A propriedade de um programa de poder ser executado em mais de um tipo de computador.</p>
<h5><a class="header" href="#interpretador" id="interpretador">interpretador</a></h5>
<p>    Um programa que lê outro programa e o executa.</p>
<h5><a class="header" href="#prompt" id="prompt">prompt</a></h5>
<p>    Caracteres expostos pelo interpretador para indicar que está pronto para receber entradas do usuário.</p>
<h5><a class="header" href="#programa" id="programa">programa</a></h5>
<p>    Conjunto de instruções que especificam uma operação de computação.</p>
<h5><a class="header" href="#instrução-print" id="instrução-print">instrução print</a></h5>
<p>    Uma instrução que faz o interpretador do Python exibir um valor na tela.</p>
<h5><a class="header" href="#operador" id="operador">operador</a></h5>
<p>    Um símbolo especial que representa uma operação de computação simples como adição, multiplicação ou concatenação de strings.</p>
<h5><a class="header" href="#valor" id="valor">valor</a></h5>
<p>    Uma das unidades básicas de dados, como um número ou string, que um programa manipula.</p>
<h5><a class="header" href="#tipo" id="tipo">tipo</a></h5>
<p>    Uma categoria de valores. Os tipos que vimos por enquanto são números inteiros (tipo int), números de ponto flutuante (tipo float) e strings (tipo str).</p>
<h5><a class="header" href="#inteiro" id="inteiro">inteiro</a></h5>
<p>    Um tipo que representa números inteiros.</p>
<h5><a class="header" href="#ponto-flutuante" id="ponto-flutuante">ponto flutuante</a></h5>
<p>    Um tipo que representa números com partes fracionárias.</p>
<h5><a class="header" href="#string" id="string">string</a></h5>
<p>    Um tipo que representa sequências de caracteres.</p>
<h5><a class="header" href="#linguagem-natural" id="linguagem-natural">linguagem natural</a></h5>
<p>    Qualquer linguagem que as pessoas falam e que se desenvolveu naturalmente.</p>
<h5><a class="header" href="#linguagem-formal" id="linguagem-formal">linguagem formal</a></h5>
<p>    Qualquer linguagem que as pessoas criaram com objetivos específicos, como representar ideias matemáticas ou programas de computador; todas as linguagens de programação são linguagens formais.</p>
<h5><a class="header" href="#símbolo" id="símbolo">símbolo</a></h5>
<p>    Um dos elementos básicos da estrutura sintática de um programa, análogo a uma palavra em linguagem natural.</p>
<h5><a class="header" href="#sintaxe" id="sintaxe">sintaxe</a></h5>
<p>    As regras que governam a estrutura de um programa.</p>
<h5><a class="header" href="#análise" id="análise">análise</a></h5>
<p>    Examinar um programa e sua estrutura sintática.</p>
<h5><a class="header" href="#bug" id="bug">bug</a></h5>
<p>    Um erro em um programa.</p>
<h5><a class="header" href="#depuração" id="depuração">depuração</a></h5>
<p>    O processo de encontrar e corrigir (depurar) bugs.</p>
<h2><a class="header" href="#19---exercícios" id="19---exercícios">1.9 - Exercícios</a></h2>
<h3><a class="header" href="#exercício-11" id="exercício-11">Exercício 1.1</a></h3>
<p>É uma boa ideia ler este livro em frente a um computador para testar os exemplos durante a leitura.</p>
<p>Sempre que estiver testando um novo recurso, você deve tentar fazer erros. Por exemplo, no <a href="01-a-jornada-do-programa/08-glossario.html#programa">programa</a> “Hello, World!”, o que acontece se omitir uma das aspas? E se omitir ambas? E se você soletrar a <a href="01-a-jornada-do-programa/08-glossario.html#instru%C3%A7%C3%A3o-print">instrução print</a> de forma errada?</p>
<p>Este <a href="01-a-jornada-do-programa/08-glossario.html#tipo">tipo</a> de experimento ajuda a lembrar o que foi lido; também ajuda quando você estiver programando, porque assim conhecerá o significado das mensagens de erro. É melhor fazer erros agora e de propósito que depois e acidentalmente.</p>
<ol>
<li>
<p>Em uma instrução print, o que acontece se você omitir um dos parênteses ou ambos?</p>
</li>
<li>
<p>Se estiver tentando imprimir uma <a href="01-a-jornada-do-programa/08-glossario.html#string">string</a>, o que acontece se omitir uma das aspas ou ambas?</p>
</li>
<li>
<p>Você pode usar um sinal de menos para fazer um número negativo como -2. O que acontece se puser um sinal de mais antes de um número? E se escrever assim: 2++2?</p>
</li>
<li>
<p>Na notação matemática, zeros à esquerda são aceitáveis, como em 02. O que acontece se você tentar usar isso no Python?</p>
</li>
<li>
<p>O que acontece se você tiver dois valores sem nenhum <a href="01-a-jornada-do-programa/08-glossario.html#operador">operador</a> entre eles?</p>
</li>
</ol>
<h3><a class="header" href="#exercício-12" id="exercício-12">Exercício 1.2</a></h3>
<p>Inicialize o <a href="01-a-jornada-do-programa/08-glossario.html#interpretador">interpretador</a> do Python e use-o como uma calculadora.</p>
<ol>
<li>
<p>Quantos segundos há em 42 minutos e 42 segundos?</p>
</li>
<li>
<p>Quantas milhas há em 10 quilômetros? Dica: uma milha equivale a 1,61 quilômetro.</p>
</li>
<li>
<p>Se você correr 10 quilômetros em 42 minutos e 42 segundos, qual é o seu passo médio (tempo por milha em minutos e segundos)? Qual é a sua velocidade média em milhas por hora?</p>
</li>
</ol>
<h1><a class="header" href="#capítulo-2-variáveis-expressões-e-instruções" id="capítulo-2-variáveis-expressões-e-instruções">Capítulo 2: Variáveis, expressões e instruções</a></h1>
<p>Um dos recursos mais eficientes de uma linguagem de programação é a capacidade de manipular variáveis. Uma <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#vari%C3%A1vel">variável</a> é um nome que se refere a um valor.</p>
<h2><a class="header" href="#21---instruções-de-a-href02-variaveis-expressoes-e-instrucoes09-glossariohtmlatribuic3a7c3a3oatribuiçãoa" id="21---instruções-de-a-href02-variaveis-expressoes-e-instrucoes09-glossariohtmlatribuic3a7c3a3oatribuiçãoa">2.1 - Instruções de <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#atribui%C3%A7%C3%A3o">atribuição</a></a></h2>
<p>Uma <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#instru%C3%A7%C3%A3o">instrução</a> de atribuição cria uma nova <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#vari%C3%A1vel">variável</a> e dá um valor a ela:</p>
<pre><code class="language-python">&gt;&gt;&gt; message = 'And now for something completely different'
&gt;&gt;&gt; n = 17
&gt;&gt;&gt; pi = 3.141592653589793
</code></pre>
<p>Esse exemplo faz três atribuições. A primeira atribui uma string a uma nova variável chamada message; a segunda dá o número inteiro 17 a n; a terceira atribui o valor (aproximado) de π a pi.</p>
<p>Uma forma comum de representar variáveis por escrito é colocar o nome com uma flecha apontando para o seu valor. Este tipo de número é chamado de <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#diagrama-de-estado">diagrama de estado</a> porque mostra o estado no qual cada uma das variáveis está (pense nele como o estado de espírito da variável). A Figura 2.1 mostra o resultado do exemplo anterior.</p>
<p><img src="02-variaveis-expressoes-e-instrucoes//fig/tnkp_0201.png" alt="Figura 2.1 – Diagrama de estado" />.
<br><em>Figura 2.1 – Diagrama de estado.</em></p>
<h2><a class="header" href="#22---nomes-de-variáveis" id="22---nomes-de-variáveis">2.2 - Nomes de variáveis</a></h2>
<p>Os programadores geralmente escolhem nomes significativos para as suas variáveis – eles documentam o uso da <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#vari%C3%A1vel">variável</a>.</p>
<p>Nomes de variáveis podem ser tão longos quanto você queira. Podem conter tanto letras como números, mas não podem começar com um número. É legal usar letras maiúsculas, mas a convenção é usar apenas letras minúsculas para nomes de variáveis.</p>
<p>O caractere de sublinhar (_) pode aparecer em um nome. Muitas vezes é usado em nomes com várias palavras, como your_name ou airspeed_of_unladen_swallow.</p>
<p>Se você der um nome ilegal a uma variável, recebe um <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#erro-de-sintaxe">erro de sintaxe</a>:</p>
<pre><code>&gt;&gt;&gt; 76trombones = 'big parade'
SyntaxError: invalid syntax
&gt;&gt;&gt; more@ = 1000000
SyntaxError: invalid syntax
&gt;&gt;&gt; class = 'Advanced Theoretical Zymurgy'
SyntaxError: invalid syntax
</code></pre>
<p><code>76trombones</code> é ilegal porque começa com um número. <code>more@</code> é ilegal porque contém um caractere ilegal, o <code>@</code>. Mas o que há de errado com <code>class</code>?</p>
<p>A questão é que class é uma das palavras-chave do Python. O interpretador usa palavras-chave para reconhecer a estrutura do programa e elas não podem ser usadas como nomes de variável.</p>
<p>O Python 3 tem estas palavras-chave:</p>
<pre><code>and         del         from        None        True
as          elif        global      nonlocal    try
assert      else        if          not         while
break       except      import      or          with
class       False       in          pass        yield
continue    finally     is          raise
def         for         lambda      return
</code></pre>
<p>Você não precisa memorizar essa lista. Na maior parte dos ambientes de desenvolvimento, as palavras-chave são exibidas em uma cor diferente; se você tentar usar uma como nome de variável, vai perceber.</p>
<h2><a class="header" href="#23---expressões-e-instruções" id="23---expressões-e-instruções">2.3 - Expressões e instruções</a></h2>
<p>Uma <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#express%C3%A3o">expressão</a> é uma combinação de valores, variáveis e operadores. Um valor por si mesmo é considerado uma expressão, assim como uma <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#vari%C3%A1vel">variável</a>, portanto as expressões seguintes são todas legais:</p>
<pre><code class="language-python">&gt;&gt;&gt; 42
42
&gt;&gt;&gt; n
17
&gt;&gt;&gt; n + 25
42
</code></pre>
<p>Quando você digita uma expressão no prompt, o interpretador a avalia, ou seja, ele encontra o valor da expressão. Neste exemplo, o n tem o valor 17 e n + 25 tem o valor 42.</p>
<p>Uma <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#instru%C3%A7%C3%A3o">instrução</a> é uma unidade de código que tem um efeito, como criar uma variável ou exibir um valor.</p>
<pre><code class="language-python">&gt;&gt;&gt; n = 17
&gt;&gt;&gt; print(n)
</code></pre>
<p>A primeira linha é uma instrução de <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#atribui%C3%A7%C3%A3o">atribuição</a> que dá um valor a n. A segunda linha é uma instrução de exibição que exibe o valor de n.</p>
<p>Quando você digita uma instrução, o interpretador a executa, o que significa que ele faz o que a instrução diz. Em geral, instruções não têm valores.</p>
<h2><a class="header" href="#24---modo-a-href02-variaveis-expressoes-e-instrucoes09-glossariohtmlscriptscripta" id="24---modo-a-href02-variaveis-expressoes-e-instrucoes09-glossariohtmlscriptscripta">2.4 - Modo <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#script">script</a></a></h2>
<p>Até agora executamos o Python no <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#modo-interativo">modo interativo</a>, no qual você interage diretamente com o interpretador. O modo interativo é uma boa forma de começar, mas se estiver trabalhando com mais do que algumas linhas do código, o processo pode ficar desorganizado.</p>
<p>A alternativa é salvar o código em um arquivo chamado script e então <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#executar">executar</a> o interpretador no <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#modo-script">modo script</a> para executá-lo. Por convenção, os scripts no Python têm nomes que terminam com .py.</p>
<p>Se souber como criar e executar um script no seu computador, você está pronto. Senão, recomendo usar o PythonAnywhere novamente. Inseri instruções sobre como executar programas no modo script em <a href="http://tinyurl.com/thinkpython2e">http://tinyurl.com/thinkpython2e</a>.</p>
<p>Como o Python oferece os dois modos, você pode testar pedaços do código no modo interativo antes de colocá-los em um script. Mas há diferenças entre o modo interativo e o modo script que podem confundir as pessoas.</p>
<p>Por exemplo, se estiver usando o Python como uma calculadora, você poderia digitar:</p>
<pre><code class="language-python">&gt;&gt;&gt; miles = 26.2
&gt;&gt;&gt; miles * 1.61
42.182
</code></pre>
<p>A primeira linha atribui um valor a miles, mas não tem efeito visível. A segunda linha é uma <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#express%C3%A3o">expressão</a>, então o interpretador a avalia e exibe o resultado. No fim, chega-se ao resultado de que uma maratona tem aproximadamente 42 quilômetros.</p>
<p>Mas se você digitar o mesmo código em um script e executá-lo, não recebe nenhuma saída. Uma expressão, por conta própria, não tem efeito visível no modo script. O Python, na verdade, avalia a expressão, mas não exibe o valor a menos que você especifique:</p>
<pre><code class="language-python">miles = 26.2
print(miles * 1.61)
</code></pre>
<p>Este comportamento pode confundir um pouco no início.</p>
<p>Um script normalmente contém uma sequência de instruções. Se houver mais de uma <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#instru%C3%A7%C3%A3o">instrução</a>, os resultados aparecem um após o outro, conforme as instruções sejam executadas.</p>
<p>Por exemplo, o script</p>
<pre><code class="language-python">print(1)
x = 2
print(x)
</code></pre>
<p>produz a saída</p>
<pre><code class="language-python">1
2
</code></pre>
<p>A instrução de <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#atribui%C3%A7%C3%A3o">atribuição</a> não produz nenhuma saída.</p>
<p>Para verificar sua compreensão, digite as seguintes instruções no interpretador do Python e veja o que fazem:</p>
<pre><code class="language-python">5
x = 5
x + 1
</code></pre>
<p>Agora ponha as mesmas instruções em um script e o execute. Qual é a saída? Altere o script transformando cada expressão em uma instrução de exibição e então o execute novamente.</p>
<h2><a class="header" href="#25---ordem-das-operações" id="25---ordem-das-operações">2.5 - Ordem das operações</a></h2>
<p>Quando uma <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#express%C3%A3o">expressão</a> contém mais de um operador, a ordem da avaliação depende da <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#ordem-das-opera%C3%A7%C3%B5es">ordem das operações</a>. Para operadores matemáticos, o Python segue a convenção matemática. O acrônimo PEMDAS pode ser útil para lembrar das regras:</p>
<ul>
<li>
<p>Os Parênteses têm a precedência mais alta e podem ser usados para forçar a avaliação de uma expressão na ordem que você quiser. Como as expressões em parênteses são avaliadas primeiro, <code>2 * (3-1)</code> é 4, e <code>(1+1)**(5-2)</code> é 8. Também é possível usar parênteses para facilitar a leitura de uma expressão, como no caso de <code>(minute * 100) / 60</code>, mesmo se o resultado não for alterado.</p>
</li>
<li>
<p>A Exponenciação tem a próxima precedência mais alta, então <code>1 + 2**3</code> é 9, não 27, e <code>2 * 3**2</code> é 18, não 36.</p>
</li>
<li>
<p>A Multiplicação e a Divisão têm precedência mais alta que a Adição e a Subtração. Assim, <code>2 * 3 - 1</code> é 5, não 4, e <code>6 + 4 / 2</code> é 8, não 5.</p>
</li>
<li>
<p>Os operadores com a mesma precedência são avaliados da esquerda para a direita (exceto na exponenciação). Assim, na expressão <code>degrees / 2 * pi</code>, a divisão acontece primeiro e o resultado é multiplicado por <code>pi</code>. Para dividir por 2π, você pode usar parênteses ou escrever <code>degrees / 2 / pi</code>.</p>
</li>
</ul>
<p>Eu não fico sempre tentando lembrar da precedência de operadores. Se a expressão não estiver clara à primeira vista, uso parênteses para fazer isso.</p>
<h2><a class="header" href="#26---operações-com-strings" id="26---operações-com-strings">2.6 - Operações com strings</a></h2>
<p>Em geral, não é possível <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#executar">executar</a> operações matemáticas com strings, mesmo se elas parecerem números, então coisas assim são ilegais:</p>
<pre><code>'2'-'1'    'eggs'/'easy'    'third'*'a charm'
</code></pre>
<p>Mas há duas exceções, <code>+</code> e <code>*</code>.</p>
<p>O operador <code>+</code> executa uma concatenação de strings, ou seja, une as strings pelas extremidades. Por exemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; first = 'throat'
&gt;&gt;&gt; second = 'warbler'
&gt;&gt;&gt; first + second
throatwarbler
</code></pre>
<p>O operador <code>*</code> também funciona em strings; ele executa a repetição. Por exemplo, 'Spam'<code>*</code>3 é 'SpamSpamSpam'. Se um dos valores for uma string, o outro tem de ser um número inteiro.</p>
<p>Este uso de + e <code>*</code> faz sentido por analogia com a adição e a multiplicação. Tal como <code>4 * 3</code> é equivalente a <code>4 + 4 + 4</code>, esperamos que <code>'Spam' * 3</code> seja o mesmo que 'Spam'+'Spam'+'Spam', e assim é. Por outro lado, há uma diferença significativa entre a concatenação de strings e a repetição em relação à adição e à multiplicação de números inteiros. Você consegue pensar em uma propriedade que a adição tem, mas a concatenação de strings não tem?</p>
<h2><a class="header" href="#27---comentários" id="27---comentários">2.7 - Comentários</a></h2>
<p>Conforme os programas ficam maiores e mais complicados, eles são mais difíceis de ler. As linguagens formais são densas e muitas vezes é difícil ver um pedaço de código e compreender o que ele faz ou por que faz isso.</p>
<p>Por essa razão, é uma boa ideia acrescentar notas aos seus programas para explicar em linguagem natural o que o programa está fazendo. Essas notas são chamadas de <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#coment%C3%A1rios">comentários</a>, e começam com o símbolo <code>#</code>:</p>
<pre><code class="language-python"># computa a percentagem da hora que passou
percentage = (minute * 100) / 60
</code></pre>
<p>Nesse caso, o comentário aparece sozinho em uma linha. Você também pode pôr comentários no fim das linhas:</p>
<pre><code class="language-python">percentage = (minute * 100) / 60    # percentagem de uma hora
</code></pre>
<p>Tudo do <code>#</code> ao fim da linha é ignorado – não tem efeito na execução do programa.</p>
<p>Os comentários tornam-se mais úteis quando documentam algo no código que não está óbvio. Podemos supor que o leitor compreenda o que o código faz; assim, é mais útil explicar porque faz o que faz.</p>
<p>Este comentário é redundante em relação ao código, além de inútil:</p>
<pre><code class="language-python">v = 5    # atribui 5 a v
</code></pre>
<p>Este comentário contém informações úteis que não estão no código:</p>
<pre><code class="language-python">v = 5    # velocidade em metros/segundo.
</code></pre>
<p>Bons nomes de variáveis podem reduzir a necessidade de comentários, mas nomes longos podem tornar expressões complexas difíceis de ler, então é preciso analisar o que vale mais a pena.</p>
<h2><a class="header" href="#28---depuração" id="28---depuração">2.8 - Depuração</a></h2>
<p>Há três tipos de erros que podem ocorrer em um programa: erros de sintaxe, erros de tempo de execução e erros semânticos. É útil distinguir entre eles para rastreá-los mais rapidamente.</p>
<h5><a class="header" href="#erro-de-sintaxe" id="erro-de-sintaxe">Erro de sintaxe</a></h5>
<p>    A “sintaxe” refere-se à estrutura de um programa e suas respectivas regras. Por exemplo, os parênteses devem vir em pares correspondentes, então (1 + 2) é legal, mas 8) é um <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#erro-de-sintaxe">erro de sintaxe</a>.
    Se houver um erro de sintaxe em algum lugar no seu programa, o Python exibe uma mensagem de erro e para, e não será possível <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#executar">executar</a> o programa. Nas primeiras poucas semanas da sua carreira em programação, você pode passar muito tempo rastreando erros de sintaxe. Ao adquirir experiência, você fará menos erros e os encontrará mais rápido.</p>
<h5><a class="header" href="#erro-de-tempo-de-execução" id="erro-de-tempo-de-execução">Erro de tempo de execução</a></h5>
<p>    O segundo tipo de erro é o erro de tempo de execução, assim chamado porque o erro não aparece até que o programa seja executado. Esses erros também se chamam de exceções porque normalmente indicam que algo excepcional (e ruim) aconteceu.
    Os erros de tempo de execução são raros nos programas simples que veremos nos primeiros capítulos, então pode demorar um pouco até você encontrar algum.</p>
<h5><a class="header" href="#erro-semântico" id="erro-semântico">Erro semântico</a></h5>
<p>    O terceiro tipo do erro é “semântico”, ou seja, relacionado ao significado. Se houver um <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#erro-sem%C3%A2ntico">erro semântico</a> no seu programa, ele será executado sem gerar mensagens de erro, mas não vai fazer a coisa certa. Vai fazer algo diferente. Especificamente, vai fazer o que você disser para fazer.
    Identificar erros semânticos pode ser complicado, porque é preciso trabalhar de trás para a frente, vendo a saída do programa e tentando compreender o que ele está fazendo.</p>
<h2><a class="header" href="#29---glossário" id="29---glossário">2.9 - Glossário</a></h2>
<h5><a class="header" href="#variável" id="variável">variável</a></h5>
<p>    Um nome que se refere a um valor.</p>
<h5><a class="header" href="#atribuição" id="atribuição">atribuição</a></h5>
<p>    Uma instrução que atribui um valor a uma variável.</p>
<h5><a class="header" href="#diagrama-de-estado" id="diagrama-de-estado">diagrama de estado</a></h5>
<p>    Uma representação gráfica de um grupo de variáveis e os valores a que se referem.</p>
<h5><a class="header" href="#palavra-chave" id="palavra-chave">palavra-chave</a></h5>
<p>    Uma palavra reservada, usada para analisar um programa; não é possível usar palavras-chave como if, def e while como nomes de variáveis.</p>
<h5><a class="header" href="#operando" id="operando">operando</a></h5>
<p>    Um dos valores que um operador produz.</p>
<h5><a class="header" href="#expressão" id="expressão">expressão</a></h5>
<p>    Uma combinação de variáveis, operadores e valores que representa um resultado único.</p>
<h5><a class="header" href="#avaliar" id="avaliar">avaliar</a></h5>
<p>    Simplificar uma expressão executando as operações para produzir um valor único.</p>
<h5><a class="header" href="#instrução" id="instrução">instrução</a></h5>
<p>    Uma seção do código que representa um comando ou ação. Por enquanto, as instruções que vimos são instruções de atribuições e de exibição.</p>
<h5><a class="header" href="#executar" id="executar">executar</a></h5>
<p>    Executar uma instrução para fazer o que ela diz.</p>
<h5><a class="header" href="#modo-interativo" id="modo-interativo">modo interativo</a></h5>
<p>    Um modo de usar o interpretador do Python, digitando o código no prompt.</p>
<h5><a class="header" href="#modo-script" id="modo-script">modo script</a></h5>
<p>    Um modo de usar o interpretador do Python para ler código em um script e executá-lo.</p>
<h5><a class="header" href="#script" id="script">script</a></h5>
<p>    Um programa armazenado em um arquivo.</p>
<h5><a class="header" href="#ordem-das-operações" id="ordem-das-operações">ordem das operações</a></h5>
<p>    As regras que governam a ordem na qual as expressões que envolvem vários operadores e operandos são avaliadas.</p>
<h5><a class="header" href="#concatenar" id="concatenar">concatenar</a></h5>
<p>    Juntar dois operandos pelas extremidades.</p>
<h5><a class="header" href="#comentários" id="comentários">comentários</a></h5>
<p>    Informações em um programa destinadas a outros programadores (ou qualquer pessoa que leia o texto fonte) que não têm efeito sobre a execução do programa.</p>
<h5><a class="header" href="#erro-de-sintaxe-1" id="erro-de-sintaxe-1">erro de sintaxe</a></h5>
<p>    Um erro em um programa que torna sua análise impossível (e por isso impossível de interpretar).</p>
<h5><a class="header" href="#exceção" id="exceção">exceção</a></h5>
<p>    Um erro que se descobre quando o programa é executado.</p>
<h5><a class="header" href="#semântica" id="semântica">semântica</a></h5>
<p>    O significado de um programa.</p>
<h5><a class="header" href="#erro-semântico-1" id="erro-semântico-1">erro semântico</a></h5>
<p>    Um erro que faz com que um programa faça algo diferente do que o programador pretendia.</p>
<h2><a class="header" href="#210---exercícios" id="210---exercícios">2.10 - Exercícios</a></h2>
<h3><a class="header" href="#exercício-21" id="exercício-21">Exercício 2.1</a></h3>
<p>Repetindo o meu conselho do capítulo anterior, sempre que você aprender um recurso novo, você deve testá-lo no <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#modo-interativo">modo interativo</a> e fazer erros de propósito para ver o que acontece.</p>
<ul>
<li>
<p>Vimos que n = 42 é legal. E 42 = n?</p>
</li>
<li>
<p>Ou x = y = 1?</p>
</li>
<li>
<p>Em algumas linguagens, cada <a href="02-variaveis-expressoes-e-instrucoes/09-glossario.html#instru%C3%A7%C3%A3o">instrução</a> termina em um ponto e vírgula ;. O que acontece se você puser um ponto e vírgula no fim de uma instrução no Python?</p>
</li>
<li>
<p>E se puser um ponto no fim de uma instrução?</p>
</li>
<li>
<p>Em notação matemática é possível multiplicar x e y desta forma: xy. O que acontece se você tentar fazer o mesmo no Python?</p>
</li>
</ul>
<h3><a class="header" href="#exercício-22" id="exercício-22">Exercício 2.2</a></h3>
<p>Pratique o uso do interpretador do Python como uma calculadora:</p>
<ol>
<li>
<p>O volume de uma esfera com raio r é <img src="02-variaveis-expressoes-e-instrucoes//fig/p19f1.png" alt="Fórmula – Volume de uma esfera" />.. Qual é o volume de uma esfera com raio 5?</p>
</li>
<li>
<p>Suponha que o preço de capa de um livro seja R$ 24,95, mas as livrarias recebem um desconto de 40%. O transporte custa R$ 3,00 para o primeiro exemplar e 75 centavos para cada exemplar adicional. Qual é o custo total de atacado para 60 cópias?</p>
</li>
<li>
<p>Se eu sair da minha casa às 6:52 e correr 1 quilômetro a um certo passo (8min15s por quilômetro), então 3 quilômetros a um passo mais rápido (7min12s por quilômetro) e 1 quilômetro no mesmo passo usado em primeiro lugar, que horas chego em casa para o café da manhã?</p>
</li>
</ol>
<h1><a class="header" href="#capítulo-3-funções" id="capítulo-3-funções">Capítulo 3: Funções</a></h1>
<p>No contexto da programação, uma <a href="03-funcoes/13-glossario.html#fun%C3%A7%C3%A3o">função</a> é uma sequência nomeada de instruções que executa uma operação de computação. Ao definir uma função, você especifica o nome e a sequência de instruções. Depois, pode “chamar” a função pelo nome.</p>
<h2><a class="header" href="#31---chamada-de-a-href03-funcoes13-glossariohtmlfunc3a7c3a3ofunçãoa" id="31---chamada-de-a-href03-funcoes13-glossariohtmlfunc3a7c3a3ofunçãoa">3.1 - Chamada de <a href="03-funcoes/13-glossario.html#fun%C3%A7%C3%A3o">função</a></a></h2>
<p>Já vimos um exemplo de <a href="03-funcoes/13-glossario.html#chamada-de-fun%C3%A7%C3%A3o">chamada de função</a>:</p>
<pre><code class="language-python">&gt;&gt;&gt; type(42)
&lt;class 'int'&gt;
</code></pre>
<p>O nome da função é type. A expressão entre parênteses é chamada de <a href="03-funcoes/13-glossario.html#argumento">argumento</a> da função. Para esta função, o resultado é o tipo do argumento.</p>
<p>É comum dizer que uma função “recebe” um argumento e “retorna” um resultado. O resultado também é chamado de <a href="03-funcoes/13-glossario.html#valor-de-retorno">valor de retorno</a>.</p>
<p>O Python oferece funções que convertem valores de um tipo em outro. A função int recebe qualquer valor e o converte em um número inteiro, se for possível, ou declara que há um erro:</p>
<pre><code class="language-python">&gt;&gt;&gt; int('32')
32
&gt;&gt;&gt; int('Hello')
ValueError: invalid literal for int(): Hello
</code></pre>
<p><code>int</code> pode converter valores de ponto flutuante em números inteiros, mas não faz arredondamentos; ela apenas corta a parte da fração:</p>
<pre><code class="language-python">&gt;&gt;&gt; int(3.99999)
3
&gt;&gt;&gt; int(-2.3)
-2
</code></pre>
<p><code>float</code> converte números inteiros e strings em números de ponto flutuante:</p>
<pre><code class="language-python">&gt;&gt;&gt; float(32)
32.0
&gt;&gt;&gt; float('3.14159')
3.14159
</code></pre>
<p>Finalmente, <code>str</code> converte o argumento em uma string:</p>
<pre><code class="language-python">&gt;&gt;&gt; str(32)
'32'
&gt;&gt;&gt; str(3.14159)
'3.14159'
</code></pre>
<h2><a class="header" href="#32---funções-matemáticas" id="32---funções-matemáticas">3.2 - Funções matemáticas</a></h2>
<p>O Python tem um <a href="03-funcoes/13-glossario.html#m%C3%B3dulo">módulo</a> matemático que oferece a maioria das funções matemáticas comuns. Um módulo é um arquivo que contém uma coleção de funções relacionadas.</p>
<p>Antes que possamos usar as funções em um módulo, precisamos importá-lo com uma <a href="03-funcoes/13-glossario.html#instru%C3%A7%C3%A3o-de-importa%C3%A7%C3%A3o">instrução de importação</a>:</p>
<pre><code class="language-python">&gt;&gt;&gt; import math
</code></pre>
<p>Esta instrução cria um <a href="03-funcoes/13-glossario.html#objeto-de-m%C3%B3dulo">objeto de módulo</a> chamado math (matemática). Ao se exibir o objeto de módulo, são apresentadas informações sobre ele:</p>
<pre><code class="language-python">&gt;&gt;&gt; math
&lt;module 'math' (built-in)&gt;
</code></pre>
<p>O objeto de módulo contém as funções e variáveis definidas no módulo. Para acessar uma das funções, é preciso especificar o nome do módulo e o nome da <a href="03-funcoes/13-glossario.html#fun%C3%A7%C3%A3o">função</a>, separados por um ponto. Este formato é chamado de <a href="03-funcoes/13-glossario.html#nota%C3%A7%C3%A3o-de-ponto">notação de ponto</a>.</p>
<pre><code class="language-python">&gt;&gt;&gt; ratio = signal_power / noise_power
&gt;&gt;&gt; decibels = 10 * math.log10(ratio)
&gt;&gt;&gt; radians = 0.7
&gt;&gt;&gt; height = math.sin(radians)
</code></pre>
<p>O primeiro exemplo usa math.log10 para calcular a proporção de sinal e de ruído em decibéis (assumindo que signal_power e noise_power tenham sido definidos). O módulo matemático também oferece a função log, que calcula logaritmos de base e.</p>
<p>O segundo exemplo encontra o seno de radians. O nome da variável indica que sin e outras funções trigonométricas (cos, tan etc) recebem argumentos em radianos. Para converter graus em radianos, divida por 180 e multiplique por π:</p>
<pre><code class="language-python">&gt;&gt;&gt; degrees = 45
&gt;&gt;&gt; radians = degrees / 180.0 * math.pi
&gt;&gt;&gt; math.sin(radians)
0.707106781187
</code></pre>
<p>A expressão math.pi recebe a variável pi do módulo matemático. Seu valor é uma aproximação de ponto flutuante de π, com precisão aproximada de 15 dígitos.</p>
<p>Se souber trigonometria, você pode verificar o resultado anterior comparando-o com a raiz quadrada de 2 dividida por 2:</p>
<pre><code class="language-python">&gt;&gt;&gt; math.sqrt(2) / 2.0
0.707106781187
</code></pre>
<h2><a class="header" href="#33---composição" id="33---composição">3.3 - Composição</a></h2>
<p>Por enquanto, falamos sobre os elementos de um programa – variáveis, expressões e instruções – de forma isolada, mas não sobre como combiná-los.</p>
<p>Uma das características mais úteis das linguagens de programação é a sua capacidade de usar pequenos blocos de montar para compor programas. Por exemplo, o <a href="03-funcoes/13-glossario.html#argumento">argumento</a> de uma <a href="03-funcoes/13-glossario.html#fun%C3%A7%C3%A3o">função</a> pode ser qualquer tipo de expressão, inclusive operadores aritméticos:</p>
<pre><code class="language-python">x = math.sin(degrees / 360.0 * 2 * math.pi)
E até chamadas de função:
x = math.exp(math.log(x+1))
</code></pre>
<p>É possível colocar um valor, uma expressão arbitrária, em quase qualquer lugar. Com uma exceção: o lado esquerdo de uma instrução de atribuição tem que ser um nome de variável. Qualquer outra expressão no lado esquerdo é um erro de sintaxe (veremos exceções a esta regra depois).</p>
<pre><code class="language-python">&gt;&gt;&gt; minutes = hours * 60                # correto
&gt;&gt;&gt; hours * 60 = minutes                # errado!
SyntaxError: can't assign to operator
</code></pre>
<h2><a class="header" href="#34---como-acrescentar-novas-funções" id="34---como-acrescentar-novas-funções">3.4 - Como acrescentar novas funções</a></h2>
<p>Por enquanto, só usamos funções que vêm com o Python, mas também é possível acrescentar novas funções. Uma definição de <a href="03-funcoes/13-glossario.html#fun%C3%A7%C3%A3o">função</a> especifica o nome de uma nova função e a sequência de instruções que são executadas quando a função é chamada.</p>
<p>Aqui está um exemplo:</p>
<pre><code class="language-python">def print_lyrics():
    print(&quot;I'm a lumberjack, and I'm okay.&quot;)
    print(&quot;I sleep all night and I work all day.&quot;)
</code></pre>
<p><code>def</code> é uma palavra-chave que indica uma <a href="03-funcoes/13-glossario.html#defini%C3%A7%C3%A3o-de-fun%C3%A7%C3%A3o">definição de função</a>. O nome da função é <code>print_lyrics</code>. As regras para nomes de função são as mesmas que as das variáveis: letras, números e sublinhado são legais, mas o primeiro caractere não pode ser um número. Não podemos usar uma palavra-chave como nome de uma função e devemos evitar ter uma variável e uma função com o mesmo nome.</p>
<p>Os parênteses vazios depois do nome indicam que esta função não usa argumentos.</p>
<p>A primeira linha da definição de função chama-se <a href="03-funcoes/13-glossario.html#cabe%C3%A7alho">cabeçalho</a>; o resto é chamado de <a href="03-funcoes/13-glossario.html#corpo">corpo</a>. O cabeçalho precisa terminar em dois pontos e o corpo precisa ser endentado. Por convenção, a endentação sempre é de quatro espaços. O corpo pode conter qualquer número de instruções.</p>
<p>As strings nas instruções de exibição são limitadas por aspas duplas. As aspas simples e as aspas duplas fazem a mesma coisa; a maior parte das pessoas usa aspas simples apenas nos casos em que aspas simples (que também são apóstrofes) aparecem na string.</p>
<p>Todas as aspas (simples e duplas) devem ser “aspas retas”, normalmente encontradas ao lado do Enter no teclado. “Aspas curvas”, como as desta oração, não são legais no Python.</p>
<p>Se digitar uma definição de função no modo interativo, o interpretador exibe pontos (..) para mostrar que a definição não está completa:</p>
<pre><code class="language-python">&gt;&gt;&gt; def print_lyrics():
...     print(&quot;I'm a lumberjack, and I'm okay.&quot;)
</code></pre>
<p>...     print(&quot;I sleep all night and I work all day.&quot;)</p>
<pre><code class="language-python">...
</code></pre>
<p>Para terminar a função, é preciso inserir uma linha vazia.</p>
<p>A definição de uma função cria um objeto de função, que tem o tipo function:</p>
<pre><code class="language-python">&gt;&gt;&gt; print(print_lyrics)
&lt;function print_lyrics at 0xb7e99e9c&gt;
&gt;&gt;&gt; type(print_lyrics)
&lt;class 'function'&gt;
</code></pre>
<p>A sintaxe para chamar a nova função é a mesma que a das funções integradas:</p>
<pre><code class="language-python">&gt;&gt;&gt; print_lyrics()
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
</code></pre>
<p>Uma vez que a função tenha sido definida, é possível usá-la dentro de outra função. Por exemplo, para repetir o refrão anterior, podemos escrever uma função chamada <code>repeat_lyrics</code>:</p>
<pre><code class="language-python">def repeat_lyrics():
    print_lyrics()
    print_lyrics()
</code></pre>
<p>E daí chamar <code>repeat_lyrics</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; repeat_lyrics()
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
Mas a canção não é bem assim.
</code></pre>
<h2><a class="header" href="#35---uso-e-definições" id="35---uso-e-definições">3.5 - Uso e definições</a></h2>
<p>Juntando fragmentos de código da seção anterior, o programa inteiro fica assim:</p>
<pre><code class="language-python">def print_lyrics():
    print(&quot;I'm a lumberjack, and I'm okay.&quot;)
    print(&quot;I sleep all night and I work all day.&quot;)

def repeat_lyrics():
    print_lyrics()
    print_lyrics()

repeat_lyrics()
</code></pre>
<p>Este programa contém duas definições de <a href="03-funcoes/13-glossario.html#fun%C3%A7%C3%A3o">função</a>: <code>print_lyrics</code> e <code>repeat_lyrics</code>. As definições de função são executadas como outras instruções, mas o efeito é criar objetos de função. As instruções dentro da função não são executadas até que a função seja chamada, e a <a href="03-funcoes/13-glossario.html#defini%C3%A7%C3%A3o-de-fun%C3%A7%C3%A3o">definição de função</a> não gera nenhuma saída.</p>
<p>Como poderíamos esperar, é preciso criar uma função antes de executá-la. Em outras palavras, a definição de função tem que ser executada antes que a função seja chamada.</p>
<p>Como exercício, mova a última linha deste programa para o topo, para que a <a href="03-funcoes/13-glossario.html#chamada-de-fun%C3%A7%C3%A3o">chamada de função</a> apareça antes das definições. Execute o programa e veja qual é a mensagem de erro que aparece.</p>
<p>Agora mova a chamada de função de volta para baixo e mova a definição de <code>print_lyrics</code> para depois da definição de <code>repeat_lyrics</code>. O que acontece quando este programa é executado?</p>
<h2><a class="header" href="#36---fluxo-de-execução" id="36---fluxo-de-execução">3.6 - Fluxo de execução</a></h2>
<p>Para garantir que uma <a href="03-funcoes/13-glossario.html#fun%C3%A7%C3%A3o">função</a> seja definida antes do seu primeiro uso, é preciso saber a ordem na qual as instruções serão executadas. Isso é chamado de <a href="03-funcoes/13-glossario.html#fluxo-de-execu%C3%A7%C3%A3o">fluxo de execução</a>.</p>
<p>A execução sempre começa na primeira instrução do programa. As instruções são executadas uma após a outra, de cima para baixo.</p>
<p>As definições de função não alteram o fluxo da execução do programa, mas lembre-se de que as instruções dentro da função não são executadas até a função ser chamada.</p>
<p>Uma <a href="03-funcoes/13-glossario.html#chamada-de-fun%C3%A7%C3%A3o">chamada de função</a> é como um desvio no fluxo de execução. Em vez de ir à próxima instrução, o fluxo salta para o <a href="03-funcoes/13-glossario.html#corpo">corpo</a> da função, executa as instruções lá, e então volta para continuar de onde parou.</p>
<p>Parece bastante simples, até você lembrar que uma função pode chamar outra. Enquanto estiver no meio de uma função, o programa pode ter que executar as instruções em outra função. Então, enquanto estiver executando a nova função, o programa pode ter que executar mais uma função!</p>
<p>Felizmente, o Python é bom em não perder o fio da meada, então cada vez que uma função é concluída, o programa continua de onde parou na função que o chamou. Quando chega no fim do programa, ele é encerrado.</p>
<p>Resumindo, nem sempre se deve ler um programa de cima para baixo. Às vezes faz mais sentido seguir o fluxo de execução.</p>
<h2><a class="header" href="#37---parâmetros-e-argumentos" id="37---parâmetros-e-argumentos">3.7 - Parâmetros e argumentos</a></h2>
<p>Algumas funções que vimos exigem argumentos. Por exemplo, ao chamar math.sin, você usa um número como <a href="03-funcoes/13-glossario.html#argumento">argumento</a>. Algumas funções exigem mais de um argumento: o math.pow exige dois, a base e o expoente.</p>
<p>Dentro da <a href="03-funcoes/13-glossario.html#fun%C3%A7%C3%A3o">função</a>, os argumentos são atribuídos a variáveis chamadas parâmetros. Aqui está a definição de uma função que precisa de um argumento:</p>
<pre><code class="language-python">def print_twice(bruce):
    print(bruce)
    print(bruce)
</code></pre>
<p>Esta função atribui o argumento a um <a href="03-funcoes/13-glossario.html#par%C3%A2metro">parâmetro</a> chamado bruce. Quando a função é chamada, ela exibe o valor do parâmetro (seja qual for) duas vezes.</p>
<p>Esta função funciona com qualquer valor que possa ser exibido:</p>
<pre><code class="language-python">&gt;&gt;&gt; print_twice('Spam')
Spam
Spam
&gt;&gt;&gt; print_twice(42)
42
42
&gt;&gt;&gt; print_twice(math.pi)
3.14159265359
3.14159265359
</code></pre>
<p>As mesmas regras de <a href="03-funcoes/13-glossario.html#composi%C3%A7%C3%A3o">composição</a> usadas para funções integradas também são aplicadas a funções definidas pelos programadores, então podemos usar qualquer tipo de expressão como argumento para <code>print_twice</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; print_twice('Spam '*4)
Spam Spam Spam Spam
Spam Spam Spam Spam
&gt;&gt;&gt; print_twice(math.cos(math.pi))
-1.0
-1.0
</code></pre>
<p>O argumento é avaliado antes de a função ser chamada. Então, nos exemplos, as expressões <code>'Spam * 4</code> e <code>math.cos(math.pi)</code> só são avaliadas uma vez.</p>
<pre><code class="language-python">Você também pode usar uma variável como argumento:
&gt;&gt;&gt; michael = 'Eric, the half a bee.'
&gt;&gt;&gt; print_twice(michael)
Eric, the half a bee.
Eric, the half a bee.
</code></pre>
<p>O nome da variável que passamos como argumento (michael) não tem nada a ver com o nome do parâmetro (bruce). Não importa que o valor tenha sido chamado de volta (em quem chama); aqui em <code>print_twice</code>, chamamos todo mundo de bruce.</p>
<h2><a class="header" href="#38---as-variáveis-e-os-parâmetros-são-locais" id="38---as-variáveis-e-os-parâmetros-são-locais">3.8 - As variáveis e os parâmetros são locais</a></h2>
<p>Quando você cria uma variável dentro de uma <a href="03-funcoes/13-glossario.html#fun%C3%A7%C3%A3o">função</a>, ela é local, ou seja, ela só existe dentro da função. Por exemplo:</p>
<pre><code class="language-python">def cat_twice(part1, part2):
    cat = part1 + part2
    print_twice(cat)
</code></pre>
<p>Esta função recebe dois argumentos, concatena-os e exibe o resultado duas vezes. Aqui está um exemplo que a usa:</p>
<pre><code class="language-python">&gt;&gt;&gt; line1 = 'Bing tiddle '
&gt;&gt;&gt; line2 = 'tiddle bang.'
&gt;&gt;&gt; cat_twice(line1, line2)
Bing tiddle tiddle bang.
Bing tiddle tiddle bang.
</code></pre>
<p>Quando <code>cat_twice</code> é encerrada, a variável <code>cat</code> é destruída. Se tentarmos exibi-la, recebemos uma exceção:</p>
<pre><code class="language-python">&gt;&gt;&gt; print(cat)
NameError: name 'cat' is not defined
</code></pre>
<p>Os parâmetros também são locais. Por exemplo, além de print_twice, não existe o bruce.</p>
<h2><a class="header" href="#39---diagrama-da-pilha" id="39---diagrama-da-pilha">3.9 - Diagrama da pilha</a></h2>
<p>Para monitorar quais variáveis podem ser usadas e onde, é uma boa ideia desenhar um <a href="03-funcoes/13-glossario.html#diagrama-da-pilha">diagrama da pilha</a>. Assim como diagramas de estado, os diagramas da pilha mostram o valor de cada variável, mas também mostram a <a href="03-funcoes/13-glossario.html#fun%C3%A7%C3%A3o">função</a> à qual cada variável pertence.</p>
<p>Cada função é representada por um <a href="03-funcoes/13-glossario.html#frame">frame</a> (quadro). Um frame é uma caixa com o nome de uma função junto a ele e os parâmetros e as variáveis da função dentro dele. O diagrama da pilha para o exemplo anterior é exibido na Figura 3.1.</p>
<p><img src="03-funcoes//fig/tnkp_0301.png" alt="Figura 3.1 – Diagrama da pilha" />.
<br><em>Figura 3.1 – Diagrama da pilha.</em></p>
<p>Os frames são organizados em uma pilha que indica qual função que foi chamada por outra, e assim por diante. Neste exemplo, <code>print_twice</code> foi chamada por <code>cat_twice</code> e <code>cat_twice</code> foi chamada por <code>__main__</code>, que é um nome especial para o frame na posição mais proeminente. Quando você cria uma variável fora de qualquer função, ela pertence a <code>__main__</code>.</p>
<p>Cada <a href="03-funcoes/13-glossario.html#par%C3%A2metro">parâmetro</a> refere-se ao mesmo valor como seu <a href="03-funcoes/13-glossario.html#argumento">argumento</a> correspondente. Desta forma, part1 tem o mesmo valor que line1, part2 tem o mesmo valor que line2 e bruce tem o mesmo valor que cat.</p>
<p>Se ocorrer um erro durante uma <a href="03-funcoes/13-glossario.html#chamada-de-fun%C3%A7%C3%A3o">chamada de função</a>, o Python exibe o nome da função, o nome da função que a chamou e o nome da função que chamou esta função por sua vez, voltando até <code>__main__</code>.</p>
<p>Por exemplo, se você tentar acessar <code>cat</code> de dentro de <code>print_twice</code>, receberá uma mensagem de <code>NameError</code>:</p>
<pre><code class="language-python">Traceback (innermost last):
  File &quot;test.py&quot;, line 13, in __main__
    cat_twice(line1, line2)
  File &quot;test.py&quot;, line 5, in cat_twice
    print_twice(cat)
  File &quot;test.py&quot;, line 9, in print_twice
    print(cat)
NameError: name 'cat' is not defined
</code></pre>
<p>Esta lista de funções é chamada de <a href="03-funcoes/13-glossario.html#traceback">traceback</a>. Ela mostra o arquivo do programa em que o erro ocorreu e em que linha, e quais funções estavam sendo executadas no momento. Ele também mostra a linha de código que causou o erro.</p>
<p>A ordem das funções no traceback é a mesma que a ordem dos frames no diagrama da pilha. A função que está sendo executada no momento está no final.</p>
<h2><a class="header" href="#310---funções-com-resultado-e-funções-nulas" id="310---funções-com-resultado-e-funções-nulas">3.10 - Funções com resultado e funções nulas</a></h2>
<p>Algumas funções que usamos, como as funções matemáticas, devolvem resultados; por falta de um nome melhor, vou chamá-las de funções com resultados. Outras funções, como print_twice, executam uma ação, mas não devolvem um valor. Elas são chamadas de funções nulas.</p>
<p>Quando você chama uma <a href="03-funcoes/13-glossario.html#fun%C3%A7%C3%A3o">função</a> com resultado, quase sempre quer fazer algo com o resultado; por exemplo, você pode atribui-lo a uma variável ou usá-la como parte de uma expressão:</p>
<pre><code class="language-python">x = math.cos(radians)
golden = (math.sqrt(5) + 1) / 2
</code></pre>
<p>Quando você chama uma função no modo interativo, o Python exibe o resultado:</p>
<pre><code class="language-python">&gt;&gt;&gt; math.sqrt(5)
2.2360679774997898
</code></pre>
<p>Mas em um script, se você chamar uma <a href="03-funcoes/13-glossario.html#valor-de-retorno">função com resultado</a> e mais nada, o <a href="03-funcoes/13-glossario.html#valor-de-retorno">valor de retorno</a> é perdido para sempre!</p>
<pre><code class="language-python">math.sqrt(5)
</code></pre>
<p>Este script calcula a raiz quadrada de 5, mas como não armazena ou exibe o resultado, não é muito útil.</p>
<p>As funções nulas podem exibir algo na tela ou ter algum outro efeito, mas não têm um valor de retorno. Se você atribuir o resultado a uma variável, recebe um valor especial chamado <a href="03-funcoes/13-glossario.html#None">None</a>:</p>
<pre><code class="language-python">&gt;&gt;&gt; result = print_twice('Bing')
Bing
Bing
&gt;&gt;&gt; print(result)
None
</code></pre>
<p>O valor <code>None</code> não é o mesmo que a string <code>'None'</code>. É um valor especial que tem seu próprio tipo:</p>
<pre><code class="language-python">&gt;&gt;&gt; print(type(None))
&lt;class 'NoneType'&gt;
</code></pre>
<p>As funções que apresentamos por enquanto são todas nulas. Vamos apresentar funções com resultado mais adiante.</p>
<h2><a class="header" href="#311---por-que-funções" id="311---por-que-funções">3.11 - Por que funções?</a></h2>
<p>Caso o objetivo de dividir um programa em funções não esteja claro, saiba que na verdade há várias razões:</p>
<ul>
<li>
<p>Criar uma nova <a href="03-funcoes/13-glossario.html#fun%C3%A7%C3%A3o">função</a> dá a oportunidade de nomear um grupo de instruções, o que deixa o seu programa mais fácil de ler e de depurar.</p>
</li>
<li>
<p>As funções podem tornar um programa menor, eliminando o código repetitivo. Depois, se fizer alguma alteração, basta fazê-la em um lugar só.</p>
</li>
<li>
<p>Dividir um programa longo em funções permite depurar as partes uma de cada vez e então reuni-las em um conjunto funcional.</p>
</li>
<li>
<p>As funções bem projetadas muitas vezes são úteis para muitos programas. Uma vez que escreva e depure uma, você pode reutilizá-la.</p>
</li>
</ul>
<h2><a class="header" href="#312---depuração" id="312---depuração">3.12 - Depuração</a></h2>
<p>Uma das habilidades mais importantes que você vai aprender é a depuração. Embora possa ser frustrante, a depuração é uma das partes mais intelectualmente ricas, desafiadoras e interessantes da programação.</p>
<p>De certa forma, depurar é similar ao trabalho de um detetive. Você tem pistas e precisa inferir os processos e eventos que levaram aos resultados exibidos.</p>
<p>A depuração também é como ciência experimental. Uma vez que você tenha uma ideia sobre o que está errado, basta alterar o programa e tentar novamente. Se a sua hipótese estava correta, você pode prever o resultado da alteração e chegar um passo mais perto de um programa funcional. Se a sua hipótese estava errada, é preciso criar outra. Como dizia Sherlock Holmes, “Quando se elimina o impossível, o que sobra, por mais incrível que pareça, só pode ser a verdade.” (A. Conan Doyle, O signo dos quatro).</p>
<p>Para algumas pessoas, programar e depurar são a mesma coisa. Isto é, a programação é o processo de depurar gradualmente um programa até que ele faça o que o programador quer. A ideia é que você comece com um programa funcional e faça pequenas alterações, depurando-as no decorrer do trabalho.</p>
<p>Por exemplo, o Linux é um sistema operacional que contém milhões de linhas de código, mas começou como um programa simples que Linus Torvalds usava para explorar o chip Intel 80386. Segundo Larry Greenfield, “Um dos primeiros projetos de Linus foi um programa que alternaria entre a exibição de AAAA e BBBB. Mais tarde isso se desenvolveu até virar o Linux.” (Guia do usuário de Linux versão beta 1).</p>
<h2><a class="header" href="#313---glossário" id="313---glossário">3.13 - Glossário</a></h2>
<h5><a class="header" href="#função" id="função">função</a></h5>
<p>    Uma sequência nomeada de declarações que executa alguma operação útil. As funções podem receber argumentos ou não e podem ou não produzir algum resultado.</p>
<h5><a class="header" href="#definição-de-função" id="definição-de-função">definição de função</a></h5>
<p>    Uma instrução que cria uma função nova, especificando seu nome, parâmetros e as instruções que contém.</p>
<h5><a class="header" href="#objeto-da-função" id="objeto-da-função">objeto da função</a></h5>
<p>    Um valor é criado por uma definição de função. O nome da função é uma variável que se refere a um objeto de função.</p>
<h5><a class="header" href="#cabeçalho" id="cabeçalho">cabeçalho</a></h5>
<p>    A primeira linha de uma definição de função.</p>
<h5><a class="header" href="#corpo" id="corpo">corpo</a></h5>
<p>    A sequência de instruções dentro de uma definição de função.</p>
<h5><a class="header" href="#parâmetro" id="parâmetro">parâmetro</a></h5>
<p>    Um nome usado dentro de uma função para se referir ao valor passado como argumento.</p>
<h5><a class="header" href="#chamada-de-função" id="chamada-de-função">chamada de função</a></h5>
<p>    Uma instrução que executa uma função. É composta pelo nome da função seguido de uma lista de argumentos entre parênteses.</p>
<h5><a class="header" href="#argumento" id="argumento">argumento</a></h5>
<p>    Um valor apresentado a uma função quando a função é chamada. Este valor é atribuído ao parâmetro correspondente na função.</p>
<h5><a class="header" href="#variável-local" id="variável-local">variável local</a></h5>
<p>    Uma variável definida dentro de uma função. Uma variável local só pode ser usada dentro da sua função.</p>
<h5><a class="header" href="#valor-de-retorno" id="valor-de-retorno">valor de retorno</a></h5>
<p>    O resultado de uma função. Se uma chamada de função for usada como uma expressão, o valor de retorno é o valor da expressão.</p>
<h5><a class="header" href="#função-com-resultado" id="função-com-resultado">função com resultado</a></h5>
<p>    Uma função que devolve um valor.</p>
<h5><a class="header" href="#função-nula" id="função-nula">função nula</a></h5>
<p>    Uma função que sempre devolve None.</p>
<h5><a class="header" href="#none" id="none">None</a></h5>
<p>    Um valor especial apresentado por funções nulas.</p>
<h5><a class="header" href="#módulo" id="módulo">módulo</a></h5>
<p>    Um arquivo que contém uma coleção de funções relacionadas e outras definições.</p>
<h5><a class="header" href="#instrução-de-importação" id="instrução-de-importação">instrução de importação</a></h5>
<p>    Uma instrução que lê um arquivo de módulo e cria um objeto de módulo.</p>
<h5><a class="header" href="#objeto-de-módulo" id="objeto-de-módulo">objeto de módulo</a></h5>
<p>    Um valor criado por uma instrução import que oferece acesso aos valores definidos em um módulo.</p>
<h5><a class="header" href="#notação-de-ponto" id="notação-de-ponto">notação de ponto</a></h5>
<p>    A sintaxe para chamar uma função em outro módulo especificando o nome do módulo seguido de um ponto e o nome da função.</p>
<h5><a class="header" href="#composição" id="composição">composição</a></h5>
<p>    O uso de uma expressão como parte de uma expressão maior ou de uma instrução como parte de uma instrução maior.</p>
<h5><a class="header" href="#fluxo-de-execução" id="fluxo-de-execução">fluxo de execução</a></h5>
<p>    A ordem na qual as instruções são executadas.</p>
<h5><a class="header" href="#diagrama-da-pilha" id="diagrama-da-pilha">diagrama da pilha</a></h5>
<p>    Representação gráfica de uma pilha de funções, suas variáveis e os valores a que se referem.</p>
<h5><a class="header" href="#frame" id="frame">frame</a></h5>
<p>    Uma caixa em um diagrama da pilha que representa uma chamada de função. Contém as variáveis locais e os parâmetros da função.</p>
<h5><a class="header" href="#traceback" id="traceback">traceback</a></h5>
<p>    Lista das funções que estão sendo executadas, exibidas quando ocorre uma exceção.</p>
<h2><a class="header" href="#314---exercícios" id="314---exercícios">3.14 - Exercícios</a></h2>
<h3><a class="header" href="#exercício-31" id="exercício-31">Exercício 3.1</a></h3>
<p>Escreva uma <a href="03-funcoes/13-glossario.html#fun%C3%A7%C3%A3o">função</a> chamada right_justify, que receba uma string chamada s como <a href="03-funcoes/13-glossario.html#par%C3%A2metro">parâmetro</a> e exiba a string com espaços suficientes à frente para que a última letra da string esteja na coluna 70 da tela:</p>
<pre><code class="language-python">&gt;&gt;&gt; right_justify('monty')
                                                                       monty
</code></pre>
<p>Dica: Use concatenação de strings e repetição. Além disso, o Python oferece uma função integrada chamada len, que apresenta o comprimento de uma string, então o valor de <code>len('monty')</code> é 5.</p>
<h3><a class="header" href="#exercício-32" id="exercício-32">Exercício 3.2</a></h3>
<p>Um objeto de função é um valor que pode ser atribuído a uma variável ou passado como <a href="03-funcoes/13-glossario.html#argumento">argumento</a>. Por exemplo, do_twice é uma função que toma um objeto de função como argumento e o chama duas vezes:</p>
<pre><code class="language-python">def do_twice(f):
    f()
    f()
</code></pre>
<p>Aqui está um exemplo que usa do_twice para chamar uma função chamada print_spam duas vezes:</p>
<pre><code class="language-python">def print_spam():
    print('spam')
do_twice(print_spam)
</code></pre>
<ol>
<li>
<p>Digite este exemplo em um script e teste-o.</p>
</li>
<li>
<p>Altere <code>do_twice</code> para que receba dois argumentos, um objeto de função e um valor, e chame a função duas vezes, passando o valor como um argumento.</p>
</li>
<li>
<p>Copie a definição de <code>print_twice</code> que aparece anteriormente neste capítulo no seu script.</p>
</li>
<li>
<p>Use a versão alterada de <code>do_twice</code> para chamar <code>print_twice</code> duas vezes, passando <code>'spam'</code> como um argumento.</p>
</li>
<li>
<p>Defina uma função nova chamada <code>do_four</code> que receba um objeto de função e um valor e chame a função quatro vezes, passando o valor como um parâmetro. Deve haver só duas afirmações no <a href="03-funcoes/13-glossario.html#corpo">corpo</a> desta função, não quatro.</p>
</li>
</ol>
<p>Solução: <a href="http://thinkpython2.com/code/do_four.py">http://thinkpython2.com/code/do_four.py</a>.</p>
<h3><a class="header" href="#exercício-33" id="exercício-33">Exercício 3.3</a></h3>
<blockquote>
<p>Nota: Este exercício deve ser feito usando-se apenas as instruções e os outros recursos que aprendemos até agora.</p>
</blockquote>
<ol>
<li>Escreva uma função que desenhe uma grade como a seguinte:</li>
</ol>
<pre><code>        + - - - - + - - - - +
        |         |         |
        |         |         |
        |         |         |
        |         |         |
        + - - - - + - - - - +
        |         |         |
        |         |         |
        |         |         |
        |         |         |
        + - - - - + - - - - +
</code></pre>
<blockquote>
<p>Dica: para exibir mais de um valor em uma linha, podemos usar uma sequência de valores separados por vírgula:</p>
<pre><code class="language-python">print('+', '-')
</code></pre>
<p>Por padrão, print avança para a linha seguinte, mas podemos ignorar esse comportamento e inserir um espaço no fim, desta forma:</p>
<pre><code class="language-python">print('+', end=' ')
 print('-')
</code></pre>
<p>A saída dessas instruções é <code>+ -</code>.
Uma instrução <code>print</code> sem argumento termina a linha atual e vai para a próxima linha.</p>
</blockquote>
<ol start="2">
<li>Escreva uma função que desenhe uma grade semelhante com quatro linhas e quatro colunas.</li>
</ol>
<p>Solução: <a href="http://thinkpython2.com/code/grid.py">http://thinkpython2.com/code/grid.py</a>. Crédito: Este exercício é baseado em outro apresentado por Oualline, em Practical C Programming, Third Edition, O’Reilly Media, 1997.</p>
<h1><a class="header" href="#capítulo-4-estudo-de-caso-projeto-de-a-href04-estudo-de-caso-projeto-de-interface11-glossariohtmlinterfaceinterfacea" id="capítulo-4-estudo-de-caso-projeto-de-a-href04-estudo-de-caso-projeto-de-interface11-glossariohtmlinterfaceinterfacea">Capítulo 4: Estudo de caso: projeto de <a href="04-estudo-de-caso-projeto-de-interface/11-glossario.html#interface">interface</a></a></h1>
<p>Este capítulo apresenta um estudo de caso que demonstra o processo de criação de funções que operam simultaneamente.</p>
<p>Ele apresenta o módulo turtle, que permite criar imagens usando [<em>turtle graphics</em>][1]. O módulo turtle é incluído na maior parte das instalações do Python, mas se estiver executando a linguagem com o PythonAnywhere você não poderá executar os exemplos do turtle (pelo menos não era possível quando escrevi este livro).</p>
<p>Se já tiver instalado o Python no seu computador, você poderá executar os exemplos. Caso não, agora é uma boa hora para instalar. Publiquei instruções no site <a href="http://tinyurl.com/thinkpython2e">http://tinyurl.com/thinkpython2e</a>.</p>
<p>Os exemplos de código deste capítulo estão disponíveis em <a href="http://thinkpython2.com/code/polygon.py">http://thinkpython2.com/code/polygon.py</a>.</p>
<h2><a class="header" href="#41---módulo-turtle" id="41---módulo-turtle">4.1 - Módulo turtle</a></h2>
<p>Para conferir se você tem o módulo turtle, abra o interpretador do Python e digite:</p>
<pre><code class="language-python">&gt;&gt;&gt; import turtle
&gt;&gt;&gt; bob = turtle.Turtle()
</code></pre>
<p>Ao executar este código o programa deve abrir uma nova janela com uma pequena flecha que representa o turtle. Feche a janela.</p>
<p>Crie um arquivo chamado mypolygon.py e digite o seguinte código:</p>
<pre><code class="language-python">import turtle
bob = turtle.Turtle()
print(bob)
turtle.mainloop()
</code></pre>
<p>O módulo turtle (com t minúsculo) apresenta uma função chamada Turtle (com T maiúsculo), que cria um objeto Turtle, ao qual atribuímos uma variável chamada bob. Exibir bob faz algo assim:</p>
<pre><code class="language-python">&lt;turtle.Turtle object at 0xb7bfbf4c&gt;
</code></pre>
<p>Isto significa que bob se refere a um objeto com o tipo Turtle definido no módulo turtle.</p>
<p>mainloop diz que a janela deve esperar que o usuário faça algo, embora neste caso não haja muito a fazer, exceto fechar a janela.</p>
<p>Uma vez que tenha criado o Turtle, você pode chamar um <a href="04-estudo-de-caso-projeto-de-interface/11-glossario.html#m%C3%A9todo">método</a> para movê-lo pela janela. Método é semelhante a uma função, mas usa uma sintaxe ligeiramente diferente. Por exemplo, para mover o turtle para a frente:</p>
<pre><code class="language-python">bob.fd(100)
</code></pre>
<p>O método fd é associado com o objeto turtle, que denominamos bob. Chamar de um método é como fazer um pedido: você está pedindo que bob avance.</p>
<p>O argumento de fd é uma distância em píxeis, então o tamanho real depende da sua tela.</p>
<p>Outros métodos que você pode chamar em um Turtle são bk para mover-se para trás, lt para virar à esquerda e rt para virar à direita. O argumento para lt e rt é um ângulo em graus.</p>
<p>Além disso, cada Turtle segura uma caneta, que está abaixada ou levantada; se a caneta estiver abaixada, o Turtle deixa um rastro quando se move. Os métodos pu e pd representam “caneta para cima” e “caneta para baixo”.</p>
<p>Para desenhar um ângulo reto, acrescente estas linhas ao programa (depois de criar bob e antes de chamar o mainloop):</p>
<pre><code class="language-python">bob.fd(100)
bob.lt(90)
bob.fd(100)
</code></pre>
<p>Ao executar este programa, você deveria ver bob mover-se para o leste e depois para o norte, deixando dois segmentos de reta para trás.</p>
<p>Agora altere o programa para desenhar um quadrado. Só siga adiante neste capítulo se ele funcionar adequadamente!</p>
<h2><a class="header" href="#42---repetição-simples" id="42---repetição-simples">4.2 - Repetição simples</a></h2>
<p>Provavelmente você escreveu algo assim:</p>
<pre><code class="language-python">bob.fd(100)
bob.lt(90)
bob.fd(100)
bob.lt(90)
bob.fd(100)
bob.lt(90)
bob.fd(100)
</code></pre>
<p>Podemos fazer a mesma coisa de forma mais concisa com uma instrução for. Acrescente este exemplo a mypolygon.py e execute-o novamente:</p>
<pre><code class="language-python">for i in range(4):
    print('Hello!')
</code></pre>
<p>Você deve ver algo assim:</p>
<pre><code class="language-python">Hello!
Hello!
Hello!
Hello!
</code></pre>
<p>Este é o uso mais simples da instrução for; depois veremos mais sobre isso. Mas isso deve ser o suficiente para que você possa reescrever o seu programa de desenhar quadrados. Não continue a leitura até que dê certo.</p>
<p>Aqui está uma instrução for que desenha um quadrado:</p>
<pre><code class="language-python">for i in range(4):
    bob.fd(100)
    bob.lt(90)
</code></pre>
<p>A sintaxe de uma instrução for é semelhante à definição de uma função. Tem um cabeçalho que termina em dois pontos e um corpo endentado. O corpo pode conter qualquer número de instruções.</p>
<p>Uma instrução for também é chamada de <a href="04-estudo-de-caso-projeto-de-interface/11-glossario.html#loop">loop</a> porque o fluxo da execução passa pelo corpo e depois volta ao topo. Neste caso, ele passa pelo corpo quatro vezes.</p>
<p>Esta versão, na verdade, é um pouco diferente do código anterior que desenha quadrados porque faz outra volta depois de desenhar o último lado do quadrado. A volta extra leva mais tempo, mas simplifica o código se fizermos a mesma coisa a cada vez pelo loop. Esta versão também tem o efeito de trazer o turtle de volta à posição inicial, de frente para a mesma direção em que estava.</p>
<h2><a class="header" href="#43---exercícios" id="43---exercícios">4.3 - Exercícios</a></h2>
<p>A seguir, uma série de exercícios usando TurtleWorld. Eles servem para divertir, mas também têm outro objetivo. Enquanto trabalha neles, pense que objetivo pode ser.</p>
<p>As seções seguintes têm as soluções para os exercícios, mas não olhe até que tenha terminado (ou, pelo menos, tentado).</p>
<ol>
<li>Escreva uma função chamada square que receba um parâmetro chamado t, que é um turtle. Ela deve usar o turtle para desenhar um quadrado.</li>
</ol>
<p>        Escreva uma chamada de função que passe bob como um argumento para o square e então execute o programa novamente.</p>
<ol start="2">
<li>
<p>Acrescente outro parâmetro, chamado length, ao square. Altere o corpo para que o comprimento dos lados seja length e então altere a chamada da função para fornecer um segundo argumento. Execute o programa novamente. Teste o seu programa com uma variedade de valores para length.</p>
</li>
<li>
<p>Faça uma cópia do square e mude o nome para polygon. Acrescente outro parâmetro chamado n e altere o corpo para que desenhe um polígono regular de n lados.</p>
</li>
</ol>
<p>        Dica: os ângulos exteriores de um polígono regular de n lados são 360/n graus.</p>
<ol start="4">
<li>Escreva uma função chamada circle que use o turtle, t e um raio r como parâmetros e desenhe um círculo aproximado ao chamar polygon com um comprimento e número de lados adequados. Teste a sua função com uma série de valores de r.</li>
</ol>
<p>        Dica: descubra a circunferência do círculo e certifique-se de que length * n = circumference.</p>
<ol start="5">
<li>Faça uma versão mais geral do circle chamada arc, que receba um parâmetro adicional de angle, para determinar qual fração do círculo deve ser desenhada. angle está em unidades de graus, então quando angle=360, o arc deve desenhar um círculo completo.</li>
</ol>
<h2><a class="header" href="#44---encapsulamento" id="44---encapsulamento">4.4 - Encapsulamento</a></h2>
<p>O primeiro exercício pede que você ponha seu código para desenhar quadrados em uma definição de função e então chame a função, passando o turtle como parâmetro. Aqui está uma solução:</p>
<pre><code class="language-python">def square(t):
    for i in range(4):
        t.fd(100)
        t.lt(90)

square(bob)
</code></pre>
<p>As instruções mais internas, fd e lt, são endentadas duas vezes para mostrar que estão dentro do <a href="04-estudo-de-caso-projeto-de-interface/11-glossario.html#loop">loop</a> for, que está dentro da definição da função. A linha seguinte, square(bob), está alinhada à margem esquerda, o que indica tanto o fim do loop for como da definição de função.</p>
<p>Dentro da função, o t indica o mesmo turtle bob, então t.lt (90) tem o mesmo efeito que bob.lt (90). Neste caso, por que não chamar o parâmetro bob? A ideia é que t pode ser qualquer turtle, não apenas bob, então você pode criar um segundo turtle e passá-lo como argumento ao square:</p>
<pre><code class="language-python">alice = turtle.Turtle()
square(alice)
</code></pre>
<p>Incluir uma parte do código em uma função chama-se <a href="04-estudo-de-caso-projeto-de-interface/11-glossario.html#encapsulamento">encapsulamento</a>. Um dos benefícios do encapsulamento é que ele atribui um nome ao código, o que serve como uma espécie de documentação. Outra vantagem é que se você reutilizar o código, é mais conciso chamar uma função duas vezes que copiar e colar o corpo!</p>
<h2><a class="header" href="#45---generalização" id="45---generalização">4.5 - Generalização</a></h2>
<p>O próximo passo é acrescentar um parâmetro length ao square. Aqui está uma solução:</p>
<pre><code class="language-python">def square(t, length):
    for i in range(4):
        t.fd(length)
        t.lt(90)

square(bob, 100)
</code></pre>
<p>Acrescentar um parâmetro a uma função chama-se <a href="04-estudo-de-caso-projeto-de-interface/11-glossario.html#generaliza%C3%A7%C3%A3o">generalização</a> porque ele torna a função mais geral: na versão anterior, o quadrado é sempre do mesmo tamanho; nesta versão, pode ser de qualquer tamanho.</p>
<p>O próximo passo também é uma generalização. Em vez de desenhar quadrados, polygon desenha polígonos regulares com qualquer número de lados. Aqui está uma solução:</p>
<pre><code class="language-python">def polygon(t, n, length):
    angle = 360 / n
    for i in range(n):
        t.fd(length)
        t.lt(angle)

polygon(bob, 7, 70)
</code></pre>
<p>Este exemplo desenha um polígono de 7 lados, cada um de comprimento 70.</p>
<p>Se estiver usando Python 2, o valor do angle poderia estar errado por causa da divisão de número inteiro. Uma solução simples é calcular angle = 360.0 / n. Como o numerador é um número de ponto flutuante, o resultado é em ponto flutuante.</p>
<p>Quando uma função tem vários argumentos numéricos, é fácil esquecer o que eles são ou a ordem na qual eles devem estar. Neste caso, muitas vezes é uma boa ideia incluir os nomes dos parâmetros na lista de argumentos:</p>
<pre><code class="language-python">polygon (bob, n=7, length=70)
</code></pre>
<p>Esses são os argumentos de palavra-chave porque incluem os nomes dos parâmetros como “palavras-chave” (para não confundir com palavras-chave do Python, tais como while e def).</p>
<p>Esta sintaxe torna o programa mais legível. Também é uma lembrança sobre como os argumentos e os parâmetros funcionam: quando você chama uma função, os argumentos são atribuídos aos parâmetros.</p>
<h2><a class="header" href="#46---projeto-da-a-href04-estudo-de-caso-projeto-de-interface11-glossariohtmlinterfaceinterfacea" id="46---projeto-da-a-href04-estudo-de-caso-projeto-de-interface11-glossariohtmlinterfaceinterfacea">4.6 - Projeto da <a href="04-estudo-de-caso-projeto-de-interface/11-glossario.html#interface">interface</a></a></h2>
<p>O próximo passo é escrever circle, que recebe um raio r, como parâmetro. Aqui está uma solução simples que usa o polygon para desenhar um polígono de 50 lados:</p>
<pre><code class="language-python">import math
def circle(t, r):
    circumference = 2 * math.pi * r
    n = 50
    length = circumference / n
    polygon(t, n, length)
</code></pre>
<p>A primeira linha calcula a circunferência de um círculo com o raio r usando a fórmula 2πr. Já que usamos math.pi, temos que importar math. Por convenção, instruções import normalmente ficam no início do script.</p>
<p>n é o número de segmentos de reta na nossa aproximação de um círculo, então length é o comprimento de cada segmento. Assim, polygon desenha um polígono 50 lados que se aproxima de um círculo com o raio r.</p>
<p>Uma limitação desta solução é que n é uma constante. Para círculos muito grandes, os segmentos de reta são longos demais, e para círculos pequenos, perdemos tempo desenhando segmentos muito pequenos. Uma solução seria generalizar a função tomando n como parâmetro. Isso daria ao usuário (seja quem for que chame circle) mais controle, mas a interface seria menos limpa.</p>
<p>A interface de uma função é um resumo de como ela é usada: Quais são os parâmetros? O que a função faz? E qual é o valor de retorno? Uma interface é “limpa” se permitir à pessoa que a chama fazer o que quiser sem ter que lidar com detalhes desnecessários.</p>
<p>Neste exemplo, r pertence à interface porque especifica o círculo a ser desenhado. n é menos adequado porque pertence aos detalhes de como o círculo deve ser apresentado.</p>
<p>Em vez de poluir a interface, é melhor escolher um valor adequado para n, dependendo da circumference:</p>
<pre><code class="language-python">def circle(t, r):
    circumference = 2 * math.pi * r
    n = int(circumference / 3) + 1
    length = circumference / n
    polygon(t, n, length)
</code></pre>
<p>Neste ponto, o número de segmentos é um número inteiro próximo a circumference/3, então o comprimento de cada segmento é aproximadamente 3, pequeno o suficiente para que os círculos fiquem bons, mas grandes o suficiente para serem eficientes e aceitáveis para círculos de qualquer tamanho.</p>
<h2><a class="header" href="#47---refatoração" id="47---refatoração">4.7 - Refatoração</a></h2>
<p>Quando escrevi circle, pude reutilizar polygon porque um polígono de muitos lados é uma boa aproximação de um círculo. Mas o arc não é tão cooperativo; não podemos usar polygon ou circle para desenhar um arco.</p>
<p>Uma alternativa é começar com uma cópia de polygon e transformá-la em arc. O resultado poderia ser algo assim:</p>
<pre><code class="language-python">def arc(t, r, angle):
    arc_length = 2 * math.pi * r * angle / 360
    n = int(arc_length / 3) + 1
    step_length = arc_length / n
    step_angle = angle / n
    for i in range(n):
        t.fd(step_length)
        t.lt(step_angle)
</code></pre>
<p>A segunda metade desta função parece com a do polygon, mas não é possível reutilizar o polygon sem mudar a <a href="04-estudo-de-caso-projeto-de-interface/11-glossario.html#interface">interface</a>. Poderíamos generalizar polygon para receber um ângulo como um terceiro argumento, mas então polygon não seria mais um nome adequado! Em vez disso, vamos chamar a função mais geral de polyline:</p>
<pre><code class="language-python">def polyline(t, n, length, angle):
    for i in range(n):
        t.fd(length)
        t.lt(angle)
</code></pre>
<p>Agora podemos reescrever polygon e arc para usar polyline:</p>
<pre><code class="language-python">def polygon(t, n, length):
    angle = 360.0 / n
    polyline(t, n, length, angle)
def arc(t, r, angle):
    arc_length = 2 * math.pi * r * angle / 360
    n = int(arc_length / 3) + 1
    step_length = arc_length / n
    step_angle = float(angle) / n
    polyline(t, n, step_length, step_angle)
</code></pre>
<p>Finalmente, podemos reescrever circle para usar arc:</p>
<pre><code class="language-python">def circle(t, r):
    arc(t, r, 360)
</code></pre>
<p>Este processo – recompor um programa para melhorar interfaces e facilitar a reutilização do código – é chamado de <a href="04-estudo-de-caso-projeto-de-interface/11-glossario.html#refatora%C3%A7%C3%A3o">refatoração</a>. Neste caso, notamos que houve código semelhante em arc e polygon, então nós o “fatoramos” no polyline.</p>
<p>Se tivéssemos planejado, poderíamos ter escrito polyline primeiro e evitado a refatoração, mas muitas vezes não sabemos o suficiente já no início de um projeto para projetar todas as interfaces. Quando começarmos a escrever código, entenderemos melhor o problema. Às vezes, a refatoração é um sinal de que aprendemos algo.</p>
<h2><a class="header" href="#48---um-a-href04-estudo-de-caso-projeto-de-interface11-glossariohtmlplano-de-desenvolvimentoplano-de-desenvolvimentoa" id="48---um-a-href04-estudo-de-caso-projeto-de-interface11-glossariohtmlplano-de-desenvolvimentoplano-de-desenvolvimentoa">4.8 - Um <a href="04-estudo-de-caso-projeto-de-interface/11-glossario.html#plano-de-desenvolvimento">plano de desenvolvimento</a></a></h2>
<p>Um plano de desenvolvimento é um processo para escrever programas. O processo que usamos neste estudo de caso é “<a href="04-estudo-de-caso-projeto-de-interface/11-glossario.html#encapsulamento">encapsulamento</a> e <a href="04-estudo-de-caso-projeto-de-interface/11-glossario.html#generaliza%C3%A7%C3%A3o">generalização</a>”. Os passos deste processo são:</p>
<ol>
<li>
<p>Comece escrevendo um pequeno programa sem definições de função.</p>
</li>
<li>
<p>Uma vez que o programa esteja funcionando, identifique uma parte coerente dele, encapsule essa parte em uma função e dê um nome a ela.</p>
</li>
<li>
<p>Generalize a função acrescentando os parâmetros adequados.</p>
</li>
<li>
<p>Repita os passos 1-3 até que tenha um conjunto de funções operantes. Copie e cole o código operante para evitar a redigitação (e redepuração).</p>
</li>
<li>
<p>Procure oportunidades de melhorar o programa pela <a href="04-estudo-de-caso-projeto-de-interface/11-glossario.html#refatora%C3%A7%C3%A3o">refatoração</a>. Por exemplo, se você tem um código semelhante em vários lugares, pode ser uma boa ideia fatorá-lo em uma função geral adequada.</p>
</li>
</ol>
<p>Este processo tem algumas desvantagens – veremos alternativas mais tarde – mas pode ser útil se você não souber de antemão como dividir o programa em funções. Esta abordagem permite criar o projeto no decorrer do trabalho.</p>
<h2><a class="header" href="#49---a-href04-estudo-de-caso-projeto-de-interface11-glossariohtmldocstringdocstringa" id="49---a-href04-estudo-de-caso-projeto-de-interface11-glossariohtmldocstringdocstringa">4.9 - <a href="04-estudo-de-caso-projeto-de-interface/11-glossario.html#docstring">docstring</a></a></h2>
<p>Uma docstring é uma string no início de uma função que explica a <a href="04-estudo-de-caso-projeto-de-interface/11-glossario.html#interface">interface</a> (“doc” é uma abreviação para “documentação”). Aqui está um exemplo:</p>
<pre><code class="language-python">def polyline(t, n, length, angle):
    &quot;&quot;&quot;Desenha n segmentos de reta com o comprimento dado e
    ângulo (em graus) entre eles. t é um turtle.
    &quot;&quot;&quot;
    for i in range(n):
        t.fd(length)
        t.lt(angle)
</code></pre>
<p>Por convenção, todas as docstrings têm aspas triplas, também conhecidas como strings multilinha porque as aspas triplas permitem que a string se estenda por mais de uma linha.</p>
<p>É conciso, mas contém a informação essencial que alguém precisaria para usar esta função. Explica sucintamente o que a função faz (sem entrar nos detalhes de como o faz). Explica que efeito cada parâmetro tem sobre o comportamento da função e o tipo que cada parâmetro deve ser (se não for óbvio).</p>
<p>Escrever este tipo de documentação é uma parte importante do projeto da interface. Uma interface bem projetada deve ser simples de explicar; se não for assim, talvez a interface possa ser melhorada.</p>
<h2><a class="header" href="#410---depuração" id="410---depuração">4.10 - Depuração</a></h2>
<p>Uma <a href="04-estudo-de-caso-projeto-de-interface/11-glossario.html#interface">interface</a> é como um contrato entre uma função e quem a chama. Quem chama concorda em fornecer certos parâmetros e a função concorda em fazer certa ação.</p>
<p>Por exemplo, polyline precisa de quatro argumentos: t tem que ser um Turtle; n tem que ser um número inteiro; length deve ser um número positivo; e o angle tem que ser um número, que se espera estar em graus.</p>
<p>Essas exigências são chamadas de precondições porque se supõe que sejam verdade antes que a função seja executada. De forma inversa, as condições no fim da função são pós-condições. As pós-condições incluem o efeito desejado da função (como o desenho de segmentos de reta) e qualquer efeito colateral (como mover o Turtle ou fazer outras mudanças).</p>
<p>Precondições são responsabilidade de quem chama. Se quem chama violar uma <a href="04-estudo-de-caso-projeto-de-interface/11-glossario.html#precondi%C3%A7%C3%A3o">precondição</a> (adequadamente documentada!) e a função não funcionar corretamente, o problema está nesta pessoa, não na função.</p>
<p>Se as precondições forem satisfeitas e as pós-condições não forem, o problema está na função. Se as suas precondições e pós-condições forem claras, elas podem ajudar na depuração.</p>
<h2><a class="header" href="#411---glossário" id="411---glossário">4.11 - Glossário</a></h2>
<h5><a class="header" href="#método" id="método">método</a></h5>
<p>    Uma função associada a um objeto e chamada usando a notação de ponto.</p>
<h5><a class="header" href="#loop" id="loop">loop</a></h5>
<p>    Parte de um programa que pode ser executada repetidamente.</p>
<h5><a class="header" href="#encapsulamento" id="encapsulamento">encapsulamento</a></h5>
<p>    O processo de transformar uma sequência de instruções em uma definição de função.</p>
<h5><a class="header" href="#generalização" id="generalização">generalização</a></h5>
<p>    O processo de substituir algo desnecessariamente específico (como um número) por algo adequadamente geral (como uma variável ou parâmetro).</p>
<h5><a class="header" href="#argumento-de-palavra-chave" id="argumento-de-palavra-chave">argumento de palavra-chave</a></h5>
<p>    Um argumento que inclui o nome do parâmetro como uma “palavra-chave”.</p>
<h5><a class="header" href="#interface" id="interface">interface</a></h5>
<p>    Uma descrição de como usar uma função, incluindo o nome e as descrições dos argumentos e do valor de retorno.</p>
<h5><a class="header" href="#refatoração" id="refatoração">refatoração</a></h5>
<p>    O processo de alterar um programa funcional para melhorar a interface de funções e outras qualidades do código.</p>
<h5><a class="header" href="#plano-de-desenvolvimento" id="plano-de-desenvolvimento">plano de desenvolvimento</a></h5>
<p>    Um processo de escrever programas.</p>
<h5><a class="header" href="#docstring" id="docstring">docstring</a></h5>
<p>    Uma string que aparece no início de uma definição de função para documentar a interface da função.</p>
<h5><a class="header" href="#precondição" id="precondição">precondição</a></h5>
<p>    Uma exigência que deve ser satisfeita por quem chama a função, antes de executá-la.</p>
<h5><a class="header" href="#pós-condição" id="pós-condição">pós-condição</a></h5>
<p>    Uma exigência que deve ser satisfeita pela função antes que ela seja encerrada.</p>
<h2><a class="header" href="#412---exercícios" id="412---exercícios">4.12 - Exercícios</a></h2>
<h3><a class="header" href="#exercício-41" id="exercício-41">Exercício 4.1</a></h3>
<p>Baixe o código deste capítulo no site <a href="http://thinkpython2.com/code/polygon.py">http://thinkpython2.com/code/polygon.py</a>.</p>
<ol>
<li>
<p>Desenhe um diagrama da pilha que mostre o estado do programa enquanto executa circle (bob, radius). Você pode fazer a aritmética à mão ou acrescentar instruções print ao código.</p>
</li>
<li>
<p>A versão de <code>arc</code> na seção <a href="04-estudo-de-caso-projeto-de-interface/07-refatoracao.html">4.7 - Refatoração</a> não é muito precisa porque a aproximação linear do círculo está sempre do lado de fora do círculo verdadeiro. Consequentemente, o Turtle acaba ficando alguns píxeis de distância do destino correto. Minha solução mostra um modo de reduzir o efeito deste erro. Leia o código e veja se faz sentido para você. Se desenhar um diagrama, poderá ver como funciona.</p>
</li>
</ol>
<h3><a class="header" href="#exercício-42" id="exercício-42">Exercício 4.2</a></h3>
<p>Escreva um conjunto de funções adequadamente geral que possa desenhar flores como as da Figura 4.1.</p>
<p><img src="04-estudo-de-caso-projeto-de-interface//fig/tnkp_0401.png" alt="Figura 4.1 – Flores de tartaruga" />.
<br><em>Figura 4.1 – Flores de tartaruga.</em></p>
<p>Solução: <a href="http://thinkpython2.com/code/flower.py">http://thinkpython2.com/code/flower.py</a>, também exige <a href="http://thinkpython2.com/code/polygon.py">http://thinkpython2.com/code/polygon.py</a>.</p>
<h3><a class="header" href="#exercício-43" id="exercício-43">Exercício 4.3</a></h3>
<p>Escreva um conjunto de funções adequadamente geral que possa desenhar formas como as da Figura 4.2.</p>
<p><img src="04-estudo-de-caso-projeto-de-interface//fig/tnkp_0402.png" alt="Figura 4.2 – Tortas de tartaruga" />.
<br><em>Figura 4.2 – Tortas de tartaruga.</em></p>
<p>Solução: <a href="http://thinkpython2.com/code/pie.py">http://thinkpython2.com/code/pie.py</a>.</p>
<h3><a class="header" href="#exercício-44" id="exercício-44">Exercício 4.4</a></h3>
<p>As letras do alfabeto podem ser construídas a partir de um número moderado de elementos básicos, como linhas verticais e horizontais e algumas curvas. Crie um alfabeto que possa ser desenhado com um número mínimo de elementos básicos e então escreva funções que desenhem as letras.</p>
<p>Você deve escrever uma função para cada letra, com os nomes draw_a, draw_b etc., e colocar suas funções em um arquivo chamado letters.py. Você pode baixar uma “máquina de escrever de turtle” no site <a href="http://thinkpython2.com/code/typewriter.py">http://thinkpython2.com/code/typewriter.py</a> para ajudar a testar o seu código.</p>
<p>Você pode ver uma solução no site <a href="http://thinkpython2.com/code/letters.py">http://thinkpython2.com/code/letters.py</a>; ela também exige <a href="http://thinkpython2.com/code/polygon.py">http://thinkpython2.com/code/polygon.py</a>.</p>
<h3><a class="header" href="#exercício-45" id="exercício-45">Exercício 4.5</a></h3>
<p>Leia sobre espirais em <a href="https://pt.wikipedia.org/wiki/Espiral">https://pt.wikipedia.org/wiki/Espiral</a>; então escreva um programa que desenhe uma espiral de Arquimedes (ou um dos outros tipos).</p>
<p>[1] <em>turtle graphics</em> ou gráficos de tartaruga é o sistema de desenho popularizado pela linguagem Logo, onde os comandos movimentam um cursor triangular pela tela, conhecido como <em>turtle</em> ou tartaruga. A tartaruga deixa um rastro à medida que é movimentada, e é com esses rastros que se forma um desenho. Diferente dos sistemas usuais de desenho em computação gráfica, o sistema <em>turtle graphics</em> não exige o uso de coordenadas cartesianas.</p>
<h1><a class="header" href="#capítulo-5-condicionais-e-a-href05-condicionais-e-recursividade13-glossariohtmlrecursividaderecursividadea" id="capítulo-5-condicionais-e-a-href05-condicionais-e-recursividade13-glossariohtmlrecursividaderecursividadea">Capítulo 5: Condicionais e <a href="05-condicionais-e-recursividade/13-glossario.html#recursividade">recursividade</a></a></h1>
<p>O tópico principal deste capítulo é a instrução if, que executa códigos diferentes dependendo do estado do programa. Mas primeiro quero apresentar dois novos operadores: <a href="05-condicionais-e-recursividade/13-glossario.html#divis%C3%A3o-pelo-piso">divisão pelo piso</a> e módulo.</p>
<h2><a class="header" href="#51---divisão-pelo-piso-e-módulo" id="51---divisão-pelo-piso-e-módulo">5.1 - Divisão pelo piso e módulo</a></h2>
<p>O operador de <a href="05-condicionais-e-recursividade/13-glossario.html#divis%C3%A3o-pelo-piso">divisão pelo piso</a>, //, divide dois números e arredonda o resultado para um número inteiro para baixo. Por exemplo, suponha que o tempo de execução de um filme seja de 105 minutos. Você pode querer saber a quanto isso corresponde em horas. A divisão convencional devolve um número de ponto flutuante:</p>
<pre><code class="language-python">&gt;&gt;&gt; minutes = 105
&gt;&gt;&gt; minutes / 60
1.75
</code></pre>
<p>Mas não é comum escrever horas com pontos decimais. A divisão pelo piso devolve o número inteiro de horas, ignorando a parte fracionária:</p>
<pre><code class="language-python">&gt;&gt;&gt; minutes = 105
&gt;&gt;&gt; hours = minutes // 60
&gt;&gt;&gt; hours
1
</code></pre>
<p>Para obter o resto, você pode subtrair uma hora em minutos:</p>
<pre><code class="language-python">&gt;&gt;&gt; remainder = minutes - hours * 60
&gt;&gt;&gt; remainder
45
</code></pre>
<p>Uma alternativa é usar o <a href="05-condicionais-e-recursividade/13-glossario.html#operador-m%C3%B3dulo">operador módulo</a>, %, que divide dois números e devolve o resto:</p>
<pre><code class="language-python">&gt;&gt;&gt; remainder = minutes % 60
&gt;&gt;&gt; remainder
45
</code></pre>
<p>O operador módulo é mais útil do que parece. Por exemplo, é possível verificar se um número é divisível por outro – se x % y for zero, então x é divisível por y.</p>
<p>Além disso, você pode extrair o dígito ou dígitos mais à direita de um número. Por exemplo, x % 10 produz o dígito mais à direita de x (na base 10). Da mesma forma x % 100 produz os dois últimos dígitos.</p>
<p>Se estiver usando o Python 2, a divisão funciona de forma diferente. O operador de divisão, /, executa a divisão pelo piso se ambos os operandos forem números inteiros e faz a divisão de ponto flutuante se pelo menos um dos operandos for do tipo float.</p>
<h2><a class="header" href="#52---expressões-booleanas" id="52---expressões-booleanas">5.2 - Expressões booleanas</a></h2>
<p>Uma <a href="05-condicionais-e-recursividade/13-glossario.html#express%C3%A3o-booleana">expressão booleana</a> é uma expressão que pode ser verdadeira ou falsa. Os exemplos seguintes usam o operador ==, que compara dois operandos e produz True se forem iguais e False se não forem:</p>
<pre><code class="language-python">&gt;&gt;&gt; 5 == 5
True
&gt;&gt;&gt; 5 == 6
False
</code></pre>
<p>True e False são valores especiais que pertencem ao tipo bool; não são strings:</p>
<pre><code class="language-python">&gt;&gt;&gt; type(True)
&lt;class 'bool'&gt;
&gt;&gt;&gt; type(False)
&lt;class 'bool'&gt;
</code></pre>
<p>O operador == é um dos operadores relacionais; os outros são:</p>
<pre><code class="language-python">x != y                # x não é igual a y
x &gt; y                 # x é maior que y
x &lt; y                 # x é menor que y
x &gt;= y                # x é maior ou igual a y
x &lt;= y                # x é menor ou igual a y
</code></pre>
<p>Embora essas operações provavelmente sejam familiares para você, os símbolos do Python são diferentes dos símbolos matemáticos. Um erro comum é usar apenas um sinal de igual (=) em vez de um sinal duplo (==). Lembre-se de que = é um operador de atribuição e == é um <a href="05-condicionais-e-recursividade/13-glossario.html#operador-relacional">operador relacional</a>. Não existe =&lt; ou =&gt;.</p>
<h2><a class="header" href="#53---operadores-lógicos" id="53---operadores-lógicos">5.3 - Operadores lógicos</a></h2>
<p>Há três operadores lógicos: and, or e not. A semântica (significado) destes operadores é semelhante ao seu significado em inglês. Por exemplo, x&gt; 0 and x &lt;10 só é verdade se x for maior que 0 e menor que 10.</p>
<p>n%2 == 0 or n%3 == 0 é verdadeiro se uma ou as duas <a href="05-condicionais-e-recursividade/13-glossario.html#condi%C3%A7%C3%A3o">condição</a>(ões) for(em) verdadeira(s), isto é, se o número for divisível por 2 ou 3.</p>
<p>Finalmente, o operador not nega uma <a href="05-condicionais-e-recursividade/13-glossario.html#express%C3%A3o-booleana">expressão booleana</a>, então not (x &gt; y) é verdade se x &gt; y for falso, isto é, se x for menor que ou igual a y.</p>
<p>Falando estritamente, os operandos dos operadores lógicos devem ser expressões booleanas, mas o Python não é muito estrito. Qualquer número que não seja zero é interpretado como True:</p>
<pre><code class="language-python">&gt;&gt;&gt; 42 and True
True
</code></pre>
<p>Esta flexibilidade tem sua utilidade, mas há algumas sutilezas relativas a ela que podem ser confusas. Assim, pode ser uma boa ideia evitá-la (a menos que saiba o que está fazendo).</p>
<h2><a class="header" href="#54---execução-condicional" id="54---execução-condicional">5.4 - Execução condicional</a></h2>
<p>Para escrever programas úteis, quase sempre precisamos da capacidade de verificar condições e mudar o comportamento do programa de acordo com elas. Instruções condicionais nos dão esta capacidade. A forma mais simples é a instrução if:</p>
<pre><code class="language-python">if x &gt; 0:
    print('x is positive')
</code></pre>
<p>A <a href="05-condicionais-e-recursividade/13-glossario.html#express%C3%A3o-booleana">expressão booleana</a> depois do if é chamada de <a href="05-condicionais-e-recursividade/13-glossario.html#condi%C3%A7%C3%A3o">condição</a>. Se for verdadeira, a instrução endentada é executada. Se não, nada acontece.</p>
<p>Instruções if têm a mesma estrutura que definições de função: um cabeçalho seguido de um corpo endentado. Instruções como essa são chamadas de instruções compostas.</p>
<p>Não há limite para o número de instruções que podem aparecer no corpo, mas deve haver pelo menos uma. Ocasionalmente, é útil ter um corpo sem instruções (normalmente como um espaço reservado para código que ainda não foi escrito). Neste caso, você pode usar a instrução pass, que não faz nada.</p>
<pre><code class="language-python">if x &lt; 0:
    pass          # A FAZER: lidar com valores negativos!
</code></pre>
<h2><a class="header" href="#55---execução-alternativa" id="55---execução-alternativa">5.5 - Execução alternativa</a></h2>
<p>Uma segunda forma da instrução if é a “execução alternativa”, na qual há duas possibilidades e a <a href="05-condicionais-e-recursividade/13-glossario.html#condi%C3%A7%C3%A3o">condição</a> determina qual será executada. A sintaxe pode ser algo assim:</p>
<pre><code class="language-python">if x % 2 == 0:
    print('x is even')
else:
    print('x is odd')
</code></pre>
<p>Se o resto quando x for dividido por 2 for 0, então sabemos que x é par e o programa exibe uma mensagem adequada. Se a condição for falsa, o segundo conjunto de instruções é executado. Como a condição deve ser verdadeira ou falsa, exatamente uma das alternativas será executada. As alternativas são chamadas de ramos (branches), porque são ramos no fluxo da execução.</p>
<h2><a class="header" href="#56---condicionais-encadeadas" id="56---condicionais-encadeadas">5.6 - Condicionais encadeadas</a></h2>
<p>Às vezes, há mais de duas possibilidades e precisamos de mais que dois ramos. Esta forma de expressar uma operação de computação é uma <a href="05-condicionais-e-recursividade/13-glossario.html#condicional-encadeada">condicional encadeada</a>:</p>
<pre><code class="language-python">if x &lt; y:
    print('x is less than y')
elif x &gt; y:
    print('x is greater than y')
else:
    print('x and y are equal')
</code></pre>
<p>elif é uma abreviatura de “else if”. Novamente, exatamente um <a href="05-condicionais-e-recursividade/13-glossario.html#ramo">ramo</a> será executado. Não há nenhum limite para o número de instruções elif. Se houver uma cláusula else, ela deve estar no fim, mas não é preciso haver uma.</p>
<pre><code class="language-python">if choice == 'a':
    draw_a()
elif choice == 'b':
    draw_b()
elif choice == 'c':
    draw_c()
</code></pre>
<p>Cada <a href="05-condicionais-e-recursividade/13-glossario.html#condi%C3%A7%C3%A3o">condição</a> é verificada em ordem. Se a primeira for falsa, a próxima é verificada, e assim por diante. Se uma delas for verdadeira, o ramo correspondente é executado e a instrução é encerrada. Mesmo se mais de uma condição for verdade, só o primeiro ramo verdadeiro é executado.</p>
<h2><a class="header" href="#57---condicionais-aninhadas" id="57---condicionais-aninhadas">5.7 - Condicionais aninhadas</a></h2>
<p>Uma condicional também pode ser aninhada dentro de outra. Poderíamos ter escrito o exemplo na seção anterior desta forma:</p>
<pre><code class="language-python">if x == y:
    print('x and y are equal')
else:
    if x &lt; y:
        print('x is less than y')
    else:
        print('x is greater than y')
</code></pre>
<p>A condicional exterior contém dois ramos. O primeiro <a href="05-condicionais-e-recursividade/13-glossario.html#ramo">ramo</a> contém uma instrução simples. O segundo ramo contém outra instrução if, que tem outros dois ramos próprios. Esses dois ramos são instruções simples, embora pudessem ser instruções condicionais também.</p>
<p>Embora a endentação das instruções evidencie a estrutura das condicionais, condicionais aninhadas são difíceis de ler rapidamente. É uma boa ideia evitá-las quando for possível.</p>
<p>Operadores lógicos muitas vezes oferecem uma forma de simplificar instruções condicionais aninhadas. Por exemplo, podemos reescrever o seguinte código usando uma única condicional:</p>
<pre><code class="language-python">if 0 &lt; x:
    if x &lt; 10:
        print('x is a positive single-digit number.')
</code></pre>
<p>A instrução print só é executada se a colocarmos depois de ambas as condicionais, então podemos obter o mesmo efeito com o operador and:</p>
<pre><code class="language-python">if 0 &lt; x and x &lt; 10:
    print('x is a positive single-digit number.')
</code></pre>
<p>Para este tipo de <a href="05-condicionais-e-recursividade/13-glossario.html#condi%C3%A7%C3%A3o">condição</a>, o Python oferece uma opção mais concisa:</p>
<pre><code class="language-python">if 0 &lt; x &lt; 10:
    print('x is a positive single-digit number.')
</code></pre>
<h2><a class="header" href="#58---recursividade" id="58---recursividade">5.8 - Recursividade</a></h2>
<p>É legal para uma função chamar outra; também é legal para uma função chamar a si própria. Pode não ser óbvio porque isso é uma coisa boa, mas na verdade é uma das coisas mais mágicas que um programa pode fazer. Por exemplo, veja a seguinte função:</p>
<pre><code class="language-python">def countdown(n):
    if n &lt;= 0:
        print('Blastoff!')
    else:
        print(n)
        countdown(n-1)
</code></pre>
<p>Se n for 0 ou negativo, a palavra “Blastoff!” é exibida, senão a saída é n e então a função countdown é chamada – por si mesma – passando n-1 como argumento.</p>
<p>O que acontece se chamarmos esta função assim?</p>
<pre><code class="language-python">&gt;&gt;&gt; countdown(3)
</code></pre>
<p>A execução de countdown inicia com n=3 e como n é maior que 0, ela produz o valor 3 e então chama a si mesma...</p>
<p>    A execução de countdown inicia com n=2 e como n é maior que 0, ela produz o valor 2 e então chama a si mesma...</p>
<p>        A execução de countdown inicia com n=1 e como n é maior que 0, ela produz o valor 1 e então chama a si mesma...</p>
<p>            A execução de countdown inicia com n=0 e como n não é maior que 0, ela produz a palavra “Blastoff!” e então retorna.</p>
<p>        O countdown que recebeu n=1 retorna.</p>
<p>    O countdown que recebeu n=2 retorna.</p>
<p>O countdown que recebeu n=3 retorna.</p>
<p>E então você está de volta ao <code>__main__</code>. Então a saída completa será assim:</p>
<pre><code class="language-python">3
2
1
Blastoff!
</code></pre>
<p>Uma função que chama a si mesma é dita recursiva; o processo para executá-la é a <a href="05-condicionais-e-recursividade/13-glossario.html#recursividade">recursividade</a>.</p>
<p>Como em outro exemplo, podemos escrever uma função que exiba uma string n vezes:</p>
<pre><code class="language-python">def print_n(s, n):
    if n &lt;= 0:
        return
    print(s)
    print_n(s, n-1)
</code></pre>
<p>Se <code>n &lt;= 0</code> a instrução <code>return</code> causa a saída da função. O fluxo de execução volta imediatamente a quem fez a chamada, e as linhas restantes da função não são executadas.</p>
<p>O resto da função é similar à countdown: ela mostra s e então chama a si mesma para mostrar s mais n-1 vezes. Então o número de linhas da saída é 1 + (n - 1), até chegar a n.</p>
<p>Para exemplos simples como esse, provavelmente é mais fácil usar um loop for. Mais adiante veremos exemplos que são difíceis de escrever com um loop for e fáceis de escrever com recursividade, então é bom começar cedo.</p>
<h2><a class="header" href="#59---diagramas-da-pilha-para-funções-recursivas" id="59---diagramas-da-pilha-para-funções-recursivas">5.9 - Diagramas da pilha para funções recursivas</a></h2>
<p>Em “Diagrama da pilha”, na página 55, usamos um diagrama da pilha para representar o estado de um programa durante uma chamada de função. O mesmo tipo de diagrama pode ajudar a interpretar uma função recursiva.</p>
<p>Cada vez que uma função é chamada, o Python cria um frame para conter as variáveis locais e parâmetros da função. Para uma função recursiva, pode haver mais de um frame na pilha ao mesmo tempo.</p>
<p>A Figura 5.1 mostra um diagrama da pilha para <code>countdown</code> chamado com n = 3.</p>
<p><img src="05-condicionais-e-recursividade//fig/tnkp_0501.png" alt="Figura 5.1 – Diagrama da pilha" />.
<br><em>Figura 5.1 – Diagrama da pilha.</em></p>
<p>Como de hábito, o topo da pilha é o frame de <code>__main__</code>. Está vazio porque não criamos nenhuma variável em <code>__main__</code> nem passamos argumentos a ela.</p>
<p>Os quatro frames do countdown têm valores diferentes para o parâmetro <code>n</code>. O fundo da pilha, onde <code>n = 0</code>, é chamado <a href="05-condicionais-e-recursividade/13-glossario.html#caso-base">caso-base</a>. Ele não faz uma chamada recursiva, então não há mais frames.</p>
<p>Como exercício, desenhe um diagrama da pilha para <code>print_n</code> chamado com <code>s = 'Hello'</code> e <code>n = 2</code>. Então escreva uma função chamada <code>do_n</code> que tome um objeto de função e um número <code>n</code> como argumentos e que chame a respectiva função <code>n</code> vezes.</p>
<h2><a class="header" href="#510---recursividade-infinita" id="510---recursividade-infinita">5.10 - Recursividade infinita</a></h2>
<p>Se a <a href="05-condicionais-e-recursividade/13-glossario.html#recursividade">recursividade</a> nunca atingir um <a href="05-condicionais-e-recursividade/13-glossario.html#caso-base">caso-base</a>, continua fazendo chamadas recursivas para sempre, e o programa nunca termina. Isso é conhecido como <a href="05-condicionais-e-recursividade/13-glossario.html#recursividade-infinita">recursividade infinita</a> e geralmente não é uma boa ideia. Aqui está um programa mínimo com recursividade infinita:</p>
<pre><code class="language-python">def recurse():
    recurse()
</code></pre>
<p>Na maior parte dos ambientes de programação, um programa com recursividade infinita não é realmente executado para sempre. O Python exibe uma mensagem de erro quando a profundidade máxima de recursividade é atingida:</p>
<pre><code class="language-python">  File &quot;&lt;stdin&gt;&quot;, line 2, in recurse
  File &quot;&lt;stdin&gt;&quot;, line 2, in recurse
  File &quot;&lt;stdin&gt;&quot;, line 2, in recurse
                  .
                  .
                  .
  File &quot;&lt;stdin&gt;&quot;, line 2, in recurse
RuntimeError: Maximum recursion depth exceeded
</code></pre>
<p>Este traceback é um pouco maior que o que vimos no capítulo anterior. Quando o erro ocorre, há mil frames de recurse na pilha!</p>
<p>Se você escrever em recursividade infinita por engano, confira se a sua função tem um caso-base que não faz uma chamada recursiva. E se houver um caso-base, verifique se você vai mesmo atingi-lo.</p>
<h2><a class="header" href="#511---entrada-de-teclado" id="511---entrada-de-teclado">5.11 - Entrada de teclado</a></h2>
<p>Os programas que escrevemos até agora não aceitam entradas do usuário. Eles sempre fazem a mesma coisa cada vez.</p>
<p>O Python fornece uma função integrada chamada <code>input</code> que interrompe o programa e espera que o usuário digite algo. Quando o usuário pressionar Return ou Enter, o programa volta a ser executado e input retorna o que o usuário digitou como uma string. No Python 2, a mesma função é chamada <code>raw_input</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; text = input()
What are you waiting for?
&gt;&gt;&gt; text
What are you waiting for?
</code></pre>
<p>Antes de receber entradas do usuário, é uma boa ideia exibir um prompt dizendo ao usuário o que ele deve digitar. input pode ter um prompt como argumento:</p>
<pre><code class="language-python">&gt;&gt;&gt; name = input('What...is your name?\\n')
What...is your name?
Arthur, King of the Britons!
&gt;&gt;&gt; name
Arthur, King of the Britons!
</code></pre>
<p>A sequência <code>\n</code> no final do prompt representa um newline, que é um caractere especial de quebra de linha. É por isso que a entrada do usuário aparece abaixo do prompt.</p>
<p>Se esperar que o usuário digite um número inteiro, você pode tentar converter o valor de retorno para int:</p>
<pre><code class="language-python">&gt;&gt;&gt; prompt = 'What...is the airspeed velocity of an unladen swallow?\\n'
&gt;&gt;&gt; speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
42
&gt;&gt;&gt; int(speed)
42
</code></pre>
<p>Mas se o usuário digitar algo além de uma série de dígitos, você recebe um erro:</p>
<pre><code class="language-python">&gt;&gt;&gt; speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
What do you mean, an African or a European swallow?
&gt;&gt;&gt; int(speed)
ValueError: invalid literal for int() with base 10
</code></pre>
<p>Veremos como tratar este tipo de erro mais adiante.</p>
<h2><a class="header" href="#512---depuração" id="512---depuração">5.12 - Depuração</a></h2>
<p>Quando um erro de sintaxe ou de tempo de execução ocorre, a mensagem de erro contém muita informação, às vezes, até demais. As partes mais úteis são normalmente:</p>
<ul>
<li>
<p>que tipo de erro foi;</p>
</li>
<li>
<p>onde ocorreu.</p>
</li>
</ul>
<p>Erros de sintaxe são normalmente fáceis de encontrar, mas há algumas pegadinhas. Erros de whitespace podem ser complicados porque os espaços e tabulações são invisíveis e estamos acostumados a ignorá-los.</p>
<pre><code class="language-python">&gt;&gt;&gt; x = 5
&gt;&gt;&gt; y = 6
  File &quot;&lt;stdin&gt;&quot;, line 1
    y = 6
    ^
IndentationError: unexpected indent
</code></pre>
<p>Neste exemplo, o problema é que a segunda linha está endentada por um espaço. Mas a mensagem de erro aponta para y, o que pode ser capcioso. Em geral, mensagens de erro indicam onde o problema foi descoberto, mas o erro real pode estar em outra parte do código, às vezes, em uma linha anterior.</p>
<p>O mesmo acontece com erros em tempo de execução. Suponha que você esteja tentando calcular a proporção de sinal a ruído em decibéis. A fórmula é SNRdb = 10 log10 (Psignal/Pnoise). No Python, você poderia escrever algo assim:</p>
<pre><code class="language-python">import math
signal_power = 9
noise_power = 10
ratio = signal_power // noise_power
decibels = 10 * math.log10(ratio)
print(decibels)
</code></pre>
<p>Ao executar este programa, você recebe uma exceção:</p>
<pre><code class="language-python">Traceback (most recent call last):
  File &quot;snr.py&quot;, line 5, in ?
    decibels = 10 * math.log10(ratio)
ValueError: math domain error
</code></pre>
<p>A mensagem de erro indica a linha 5, mas não há nada de errado com esta linha. Uma opção para encontrar o verdadeiro erro é exibir o valor de ratio, que acaba sendo 0. O problema está na linha 4, que usa a <a href="05-condicionais-e-recursividade/13-glossario.html#divis%C3%A3o-pelo-piso">divisão pelo piso</a> em vez da divisão de ponto flutuante.</p>
<p>É preciso ler as mensagens de erro com atenção, mas não assumir que tudo que dizem esteja correto.</p>
<h2><a class="header" href="#513---glossário" id="513---glossário">5.13 - Glossário</a></h2>
<h5><a class="header" href="#divisão-pelo-piso" id="divisão-pelo-piso">divisão pelo piso</a></h5>
<p>    Um operador, denotado por //, que divide dois números e arredonda o resultado para baixo (em direção ao zero), a um número inteiro.</p>
<h5><a class="header" href="#operador-módulo" id="operador-módulo">operador módulo</a></h5>
<p>    Um operador, denotado com um sinal de percentagem (%), que funciona com números inteiros e devolve o resto quando um número é dividido por outro.</p>
<h5><a class="header" href="#expressão-booleana" id="expressão-booleana">expressão booleana</a></h5>
<p>    Uma expressão cujo valor é True (verdadeiro) ou False (falso).</p>
<h5><a class="header" href="#operador-relacional" id="operador-relacional">operador relacional</a></h5>
<p>    Um destes operadores, que compara seus operandos: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code> e <code>&lt;=</code>.</p>
<h5><a class="header" href="#operador-lógico" id="operador-lógico">operador lógico</a></h5>
<p>    Um destes operadores, que combina expressões booleanas: and (e), or (ou) e not (não).</p>
<h5><a class="header" href="#instrução-condicional" id="instrução-condicional">instrução condicional</a></h5>
<p>    Uma instrução que controla o fluxo de execução, dependendo de alguma condição.</p>
<h5><a class="header" href="#condição" id="condição">condição</a></h5>
<p>    A expressão booleana em uma instrução condicional que determina qual ramo deve ser executado.</p>
<h5><a class="header" href="#instrução-composta" id="instrução-composta">instrução composta</a></h5>
<p>    Uma instrução composta de um cabeçalho e um corpo. O cabeçalho termina em dois pontos (:). O corpo é endentado em relação ao cabeçalho.</p>
<h5><a class="header" href="#ramo" id="ramo">ramo</a></h5>
<p>    Uma das sequências alternativas de instruções em uma instrução condicional.</p>
<h5><a class="header" href="#condicional-encadeada" id="condicional-encadeada">condicional encadeada</a></h5>
<p>    Uma instrução condicional com uma série de ramos alternativos.</p>
<h5><a class="header" href="#condicional-aninhada" id="condicional-aninhada">condicional aninhada</a></h5>
<p>    Uma instrução condicional que aparece em um dos ramos de outra instrução condicional.</p>
<h5><a class="header" href="#instrução-de-retorno" id="instrução-de-retorno">instrução de retorno</a></h5>
<p>    Uma instrução que faz uma função terminar imediatamente e voltar a quem a chamou.</p>
<h5><a class="header" href="#recursividade" id="recursividade">recursividade</a></h5>
<p>    O processo de chamar a função que está sendo executada no momento.</p>
<h5><a class="header" href="#caso-base" id="caso-base">caso-base</a></h5>
<p>    Um ramo condicional em uma função recursiva que não faz uma chamada recursiva.</p>
<h5><a class="header" href="#recursividade-infinita" id="recursividade-infinita">recursividade infinita</a></h5>
<p>    Recursividade que não tem um caso-base, ou nunca o atinge. A recursividade infinita eventualmente causa um erro em tempo de execução.</p>
<h2><a class="header" href="#514---exercícios" id="514---exercícios">5.14 - Exercícios</a></h2>
<h3><a class="header" href="#exercício-51" id="exercício-51">Exercício 5.1</a></h3>
<p>O módulo time fornece uma função, também chamada time, que devolve a Hora Média de Greenwich na “época”, que é um momento arbitrário usado como ponto de referência. Em sistemas UNIX, a época é primeiro de janeiro de 1970.</p>
<pre><code class="language-python">&gt;&gt;&gt; import time
&gt;&gt;&gt; time.time()
1437746094.5735958
</code></pre>
<p>Escreva um script que leia a hora atual e a converta em um tempo em horas, minutos e segundos, mais o número de dias desde a época.</p>
<h3><a class="header" href="#exercício-52" id="exercício-52">Exercício 5.2</a></h3>
<p>O último teorema de Fermat diz que não existem números inteiros a, b e c tais que <code>a**n + b**n == c**n</code> para quaisquer valores de n maiores que 2.</p>
<ol>
<li>
<p>Escreva uma função chamada check_fermat que receba quatro parâmetros – a, b, c e n – e verifique se o teorema de Fermat se mantém. Se n for maior que 2 e <code>a**n + b**n == c**n</code> o programa deve imprimir, “Holy smokes, Fermat was wrong!” Senão o programa deve exibir “No, that doesn’t work.”</p>
</li>
<li>
<p>Escreva uma função que peça ao usuário para digitar valores para a, b, c e n, os converta em números inteiros e use check_fermat para verificar se violam o teorema de Fermat.</p>
</li>
</ol>
<h3><a class="header" href="#exercício-53" id="exercício-53">Exercício 5.3</a></h3>
<p>Se você tiver três gravetos, pode ser que consiga arranjá-los em um triângulo ou não. Por exemplo, se um dos gravetos tiver 12 polegadas de comprimento e outros dois tiverem uma polegada de comprimento, não será possível fazer com que os gravetos curtos se encontrem no meio. Há um teste simples para ver se é possível formar um triângulo para quaisquer três comprimentos:</p>
<p>Se algum dos três comprimentos for maior que a soma dos outros dois, então você não pode formar um triângulo. Senão, você pode. (Se a soma de dois comprimentos igualar o terceiro, eles formam um triângulo chamado “degenerado”)</p>
<ol>
<li>
<p>Escreva uma função chamada <code>is_triangle</code> que receba três números inteiros como argumentos, e que imprima “Yes” ou “No”, dependendo da possibilidade de formar ou não um triângulo de gravetos com os comprimentos dados.</p>
</li>
<li>
<p>Escreva uma função que peça ao usuário para digitar três comprimentos de gravetos, os converta em números inteiros e use <code>is_triangle</code> para verificar se os gravetos com os comprimentos dados podem formar um triângulo.</p>
</li>
</ol>
<h3><a class="header" href="#exercício-54" id="exercício-54">Exercício 5.4</a></h3>
<p>Qual é a saída do seguinte programa? Desenhe um diagrama da pilha que mostre o estado do programa quando exibir o resultado.</p>
<pre><code class="language-python">def recurse(n, s):
    if n == 0:
        print(s)
    else:
        recurse(n-1, n+s)

recurse(3, 0)
</code></pre>
<ol>
<li>
<p>O que aconteceria se você chamasse esta função desta forma: recurse(-1, 0)?</p>
</li>
<li>
<p>Escreva uma docstring que explique tudo o que alguém precisaria saber para usar esta função (e mais nada).</p>
</li>
</ol>
<p>Os seguintes exercícios usam o módulo turtle, descrito no Capítulo 4:</p>
<h3><a class="header" href="#exercício-55" id="exercício-55">Exercício 5.5</a></h3>
<p>Leia a próxima função e veja se consegue compreender o que ela faz (veja os exemplos no Capítulo 4). Então execute-a e veja se acertou.</p>
<pre><code class="language-python">def draw(t, length, n):
    if n == 0:
        return
    angle = 50
    t.fd(length * n)
    t.lt(angle)
    draw(t, length, n-1)
    t.rt(2 * angle)
    draw(t, length, n-1)
    t.lt(angle)
    t.bk(length * n)
</code></pre>
<h3><a class="header" href="#exercício-56" id="exercício-56">Exercício 5.6</a></h3>
<p><img src="05-condicionais-e-recursividade//fig/tnkp_0502.png" alt="Figura 5.2 – Uma curva de Koch" />.
<br><em>Figura 5.2 – Uma curva de Koch.</em></p>
<p>A curva de Koch é um fractal que parece com o da Figura 5.2. Para desenhar uma curva de Koch com o comprimento x, tudo o que você tem que fazer é:</p>
<ol>
<li>
<p>Desenhe uma curva de Koch com o comprimento x/3.</p>
</li>
<li>
<p>Vire 60 graus à esquerda.</p>
</li>
<li>
<p>Desenhe uma curva de Koch com o comprimento x/3.</p>
</li>
<li>
<p>Vire 120 graus à direita.</p>
</li>
<li>
<p>Desenhe uma curva de Koch com o comprimento x/3.</p>
</li>
<li>
<p>Vire 60 graus à esquerda.</p>
</li>
<li>
<p>Desenhe uma curva de Koch com o comprimento x/3.</p>
</li>
</ol>
<p>A exceção é se x for menor que 3: neste caso, você pode desenhar apenas uma linha reta com o comprimento x.</p>
<ol>
<li>
<p>Escreva uma função chamada koch que receba um turtle e um comprimento como parâmetros, e use o turtle para desenhar uma curva de Koch com o comprimento dado.</p>
</li>
<li>
<p>Escreva uma função chamada snowflake que desenhe três curvas de Koch para fazer o traçado de um floco de neve.</p>
</li>
</ol>
<p>        Solução: <a href="http://thinkpython2.com/code/koch.py">http://thinkpython2.com/code/koch.py</a>.</p>
<ol start="3">
<li>A curva de Koch pode ser generalizada de vários modos. Veja exemplos em <a href="http://en.wikipedia.org/wiki/Koch_snowflake">http://en.wikipedia.org/wiki/Koch_snowflake</a> e implemente o seu favorito.</li>
</ol>
<h1><a class="header" href="#capítulo-6-funções-com-resultado" id="capítulo-6-funções-com-resultado">Capítulo 6: Funções com resultado</a></h1>
<p>Muitas das funções do Python que usamos, como as matemáticas, produzem valores de retorno. Mas as funções que escrevemos até agora são todas nulas: têm um efeito, como exibir um valor ou mover uma tartaruga, mas não têm um valor de retorno. Neste capítulo você aprenderá a escrever funções com resultados.</p>
<h2><a class="header" href="#61---valores-de-retorno" id="61---valores-de-retorno">6.1 - Valores de retorno</a></h2>
<p>A chamada de função gera um valor de retorno, que normalmente atribuímos a uma variável ou usamos como parte de uma expressão.</p>
<pre><code class="language-python">e = math.exp(1.0)
height = radius * math.sin(radians)
</code></pre>
<p>As funções que descrevemos, por enquanto, são todas nulas. Resumindo, elas não têm valores de retorno; mais precisamente, o seu valor de retorno é None.</p>
<p>Neste capítulo veremos (finalmente) como escrever funções com resultados. O primeiro exemplo é area, que devolve a área de um círculo com o raio dado:</p>
<pre><code class="language-python">def area(radius):
    a = math.pi * radius**2
    return a
</code></pre>
<p>Já vimos a instrução return, mas em uma função com resultado ela inclui uma expressão. Esta instrução significa: “Volte imediatamente desta função e use a seguinte expressão como valor de retorno”. A expressão pode ser arbitrariamente complicada, então poderíamos ter escrito esta função de forma mais concisa:</p>
<pre><code class="language-python">def area(radius):
    return math.pi * radius**2
</code></pre>
<p>Por outro lado, variáveis temporárias como a, tornam a depuração mais fácil.</p>
<p>Às vezes, é útil ter várias instruções de retorno, uma em cada ramo de uma condicional:</p>
<pre><code class="language-python">def absolute_value(x):
    if x &lt; 0:
        return -x
    else:
        return x
</code></pre>
<p>Como essas instruções return estão em uma condicional alternativa, apenas uma é executada.</p>
<p>Logo que uma instrução de retorno seja executada, a função termina sem executar nenhuma instrução subsequente. Qualquer código que apareça depois de uma instrução return, ou em qualquer outro lugar que o fluxo da execução não atinja, é chamado de <a href="06-funcoes-com-resultado/10-glossario.html#c%C3%B3digo-morto">código morto</a>.</p>
<p>Em uma função com resultado, é uma boa ideia garantir que cada caminho possível pelo programa atinja uma instrução return. Por exemplo:</p>
<pre><code class="language-python">def absolute_value(x):
    if x &lt; 0:
        return -x
    if x &gt; 0:
        return x
</code></pre>
<p>Essa função é incorreta porque se x for 0, nenhuma condição é verdade, e a função termina sem chegar a uma instrução return. Se o fluxo de execução chegar ao fim de uma função, o valor de retorno é None, que não é o valor absoluto de 0:</p>
<pre><code class="language-python">&gt;&gt;&gt; absolute_value(0)
None
</code></pre>
<p>A propósito, o Python oferece uma função integrada chamada abs, que calcula valores absolutos.</p>
<p>Como exercício, escreva uma função compare que receba dois valores, x e y, e retorne 1 se x &gt; y, 0 se x == y e -1 se x &lt; y.</p>
<h2><a class="header" href="#62---desenvolvimento-incremental" id="62---desenvolvimento-incremental">6.2 - Desenvolvimento incremental</a></h2>
<p>Conforme você escrever funções maiores, pode ser que passe mais tempo as depurando.</p>
<p>Para lidar com programas cada vez mais complexos, você pode querer tentar usar um processo chamado de <a href="06-funcoes-com-resultado/10-glossario.html#desenvolvimento-incremental">desenvolvimento incremental</a>. A meta do desenvolvimento incremental é evitar longas sessões de depuração, acrescentando e testando pequenas partes do código de cada vez.</p>
<p>Como um exemplo, vamos supor que você queira encontrar a distância entre dois pontos dados pelas coordenadas (x1, y1) e(x2, y2). Pelo teorema de Pitágoras, a distância é:</p>
<p><img src="06-funcoes-com-resultado//fig/p63f1.png" alt="Fórmula – Distância entre dois pontos" />.</p>
<p>O primeiro passo é pensar como uma função distance deveria ser no Python. Em outras palavras, quais são as entradas (parâmetros) e qual é a saída (valor de retorno)?</p>
<p>Nesse caso, as entradas são dois pontos que você pode representar usando quatro números. O valor de retorno é a distância representada por um valor de ponto flutuante.</p>
<p>Imediatamente, é possível escrever um rascunho da função:</p>
<pre><code class="language-python">def distance(x1, y1, x2, y2):
    return 0.0
</code></pre>
<p>Claro que esta versão não calcula distâncias; sempre retorna zero. Mas está sintaticamente correta, e pode ser executada, o que significa que você pode testá-la antes de torná-la mais complicada.</p>
<p>Para testar a nova função, chame-a com argumentos de amostra:</p>
<pre><code class="language-python">&gt;&gt;&gt; distance(1, 2, 4, 6)
0.0
</code></pre>
<p>Escolhi esses valores para que a distância horizontal seja 3 e a distância vertical, 4; assim, o resultado final é 5, a hipotenusa de um triângulo 3-4-5. Ao testar uma função, é útil saber a resposta certa.</p>
<p>Neste ponto confirmamos que a função está sintaticamente correta, e podemos começar a acrescentar código ao corpo. Um próximo passo razoável é encontrar as diferenças x2 − x1 e y2 − y1. A próxima versão guarda esses valores em variáveis temporárias e os exibe:</p>
<pre><code class="language-python">def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    print('dx is', dx)
    print('dy is', dy)
    return 0.0
</code></pre>
<p>Se a função estiver funcionando, deve exibir dx is 3 e dy is 4. Nesse caso sabemos que a função está recebendo os argumentos corretos e executando o primeiro cálculo acertadamente. Se não, há poucas linhas para verificar.</p>
<p>Depois calculamos a soma dos quadrados de dx e dy:</p>
<pre><code class="language-python">def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    dsquared = dx**2 + dy**2
    print('dsquared is: ', dsquared)
    return 0.0
</code></pre>
<p>Nesta etapa você executaria o programa mais uma vez e verificaria a saída (que deve ser 25). Finalmente, pode usar math.sqrt para calcular e devolver o resultado:</p>
<pre><code class="language-python">def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    dsquared = dx**2 + dy**2
    result = math.sqrt(dsquared)
    return result
</code></pre>
<p>Se funcionar corretamente, pronto. Senão, uma ideia é exibir o valor result antes da instrução de retorno.</p>
<p>A versão final da função não exibe nada ao ser executada; apenas retorna um valor. As instruções print que escrevemos são úteis para depuração, mas assim que conferir se a função está funcionando você deve retirá-las. Códigos desse tipo são chamados de scaffolding (andaime) porque são úteis para construir o programa, mas não são parte do produto final.</p>
<p>Ao começar, você deveria acrescentar apenas uma linha ou duas de código de cada vez. Conforme adquira mais experiência, poderá escrever e depurar parcelas maiores. De qualquer forma, o desenvolvimento incremental pode economizar muito tempo de depuração.</p>
<p>Os principais aspectos do processo são:</p>
<ol>
<li>
<p>Comece com um programa que funcione e faça pequenas alterações incrementais. Se houver um erro em qualquer ponto, será bem mais fácil encontrá-lo.</p>
</li>
<li>
<p>Use variáveis para guardar valores intermediários, assim poderá exibi-los e verificá-los.</p>
</li>
<li>
<p>Uma vez que o programa esteja funcionando, você pode querer remover uma parte do scaffolding ou consolidar várias instruções em expressões compostas, mas apenas se isso não tornar o programa difícil de ler.</p>
</li>
</ol>
<p>Como exercício, use o desenvolvimento incremental para escrever uma função chamada hypotenuse, que devolva o comprimento da hipotenusa de um triângulo retângulo dados os comprimentos dos outros dois lados como argumentos. Registre cada etapa do processo de desenvolvimento no decorrer do processo.</p>
<h2><a class="header" href="#63---composição" id="63---composição">6.3 - Composição</a></h2>
<p>Como você já deveria esperar a essa altura, é possível chamar uma função de dentro de outra. Como exemplo, escreveremos uma função que recebe dois pontos, o centro do círculo e um ponto no perímetro, para calcular a área do círculo.</p>
<p>Suponha que o ponto do centro seja guardado nas variáveis xc e yc e o ponto de perímetro está em xp e yp. O primeiro passo deve ser encontrar o raio do círculo, que é a distância entre os dois pontos. Acabamos de escrever uma função, distance, que faz isto:</p>
<pre><code class="language-python">radius = distance(xc, yc, xp, yp)
</code></pre>
<p>O próximo passo deve ser encontrar a área de um círculo com aquele raio; acabamos de escrever isso também:</p>
<pre><code class="language-python">result = area(radius)
</code></pre>
<p>Encapsulando esses passos em uma função, temos:</p>
<pre><code class="language-python">def circle_area(xc, yc, xp, yp):
    radius = distance(xc, yc, xp, yp)
    result = area(radius)
    return result
</code></pre>
<p>As variáveis temporárias radius e result são úteis para desenvolvimento e depuração, e uma vez que o programa esteja funcionando podemos torná-lo mais conciso compondo chamadas de função:</p>
<pre><code class="language-python">def circle_area(xc, yc, xp, yp):
    return area(distance(xc, yc, xp, yp))
</code></pre>
<h2><a class="header" href="#64---funções-booleanas" id="64---funções-booleanas">6.4 - Funções booleanas</a></h2>
<p>As funções podem retornar booleans, o que pode ser conveniente para esconder testes complicados dentro de funções. Por exemplo:</p>
<pre><code class="language-python">def is_divisible(x, y):
    if x % y == 0:
        return True
    else:
        return False
</code></pre>
<p>É comum dar nomes de funções booleanas que pareçam perguntas de sim ou não; is_divisible retorna True ou False para indicar se x é divisível por y.</p>
<p>Aqui está um exemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; is_divisible(6, 4)
False
&gt;&gt;&gt; is_divisible(6, 3)
True
</code></pre>
<p>O resultado do operador == é um booleano, então podemos escrever a função de forma mais concisa, retornando-o diretamente:</p>
<pre><code class="language-python">def is_divisible(x, y):
    return x % y == 0
</code></pre>
<p>As funções booleanas muitas vezes são usadas em instruções condicionais:</p>
<pre><code class="language-python">if is_divisible(x, y):
    print('x is divisible by y')
</code></pre>
<p>Pode ser tentador escrever algo assim:</p>
<pre><code class="language-python">if is_divisible(x, y) == True:
    print('x is divisible by y')
</code></pre>
<p>Mas a comparação extra é desnecessária.</p>
<p>Como um exercício, escreva uma função <code>is_between(x, y, z)</code> que retorne True, se x ≤ y ≤ z, ou False, se não for o caso.</p>
<h2><a class="header" href="#65---mais-recursividade" id="65---mais-recursividade">6.5 - Mais recursividade</a></h2>
<p>Cobrimos apenas um pequeno subconjunto do Python, mas talvez seja bom você saber que este subconjunto é uma linguagem de programação completa, ou seja, qualquer coisa que possa ser calculada pode ser expressa nesta linguagem. Qualquer programa que já foi escrito pode ser reescrito apenas com os recursos da linguagem que você aprendeu até agora (na verdade, seria preciso alguns comandos para dispositivos de controle como mouse, discos etc., mas isso é tudo).</p>
<p>Comprovar esta declaração é um exercício nada trivial realizado pela primeira vez por Alan Turing, um dos primeiros cientistas da computação (alguns diriam que ele foi matemático, mas muitos dos primeiros cientistas da computação começaram como matemáticos). Assim, é conhecida como a Tese de Turing. Para uma exposição mais completa (e exata) da Tese de Turing, recomendo o livro de Michael Sipser, Introduction to the Theory of Computation (Introdução à teoria da computação, Course Technology, 2012).</p>
<p>Para dar uma ideia do que podemos fazer com as ferramentas que aprendeu até agora, avaliaremos algumas funções matemáticas definidas recursivamente. Uma definição recursiva é semelhante a uma definição circular, no sentido de que a definição contém uma referência à coisa que é definida. Uma definição realmente circular não é muito útil:</p>
<h5><a class="header" href="#vorpal" id="vorpal">vorpal</a></h5>
<p>    Adjetivo usado para descrever algo que é vorpal.</p>
<p>Ver uma definição assim no dicionário pode ser irritante. Por outro lado, se procurar a definição da função de fatorial, denotada pelo símbolo !, você pode encontrar algo assim:</p>
<pre><code>0! = 1
n! = n·(n − 1)!
</code></pre>
<p>Esta definição diz que o fatorial de 0 é 1, e o fatorial de qualquer outro valor, n, é n multiplicado pelo fatorial de n-1.</p>
<p>Então 3! é 3 vezes 2!, que é 2 vezes 1!, que é 1 vez 0!. Juntando tudo, 3! é igual a 3 vezes 2 vezes 1 vezes 1, que é 6.</p>
<p>Se puder escrever uma definição recursiva de algo, você poderá escrever um programa em Python que a avalie. O primeiro passo deve ser decidir quais parâmetros ela deve ter. Neste caso, deve estar claro que factorial recebe um número inteiro:</p>
<pre><code class="language-python">def factorial(n):
</code></pre>
<p>Se o argumento for 0, tudo que temos de fazer é retornar 1:</p>
<pre><code class="language-python">def factorial(n):
    if n == 0:
        return 1
</code></pre>
<p>Senão, e aí é que fica interessante, temos que fazer uma chamada recursiva para encontrar o fatorial de n-1 e então multiplicá-lo por n:</p>
<pre><code class="language-python">def factorial(n):
    if n == 0:
        return 1
    else:
        recurse = factorial(n-1)
        result = n * recurse
        return result
</code></pre>
<p>O fluxo de execução deste programa é semelhante ao fluxo de countdown em “Recursividade”, na página 81. Se chamarmos factorial com o valor 3:</p>
<p>Como 3 não é 0, tomamos o segundo ramo e calculamos o fatorial de n-1...</p>
<p>    Como 2 não é 0, tomamos o segundo ramo e calculamos o fatorial de n-1...</p>
<p>        Como 1 não é 0, tomamos o segundo ramo e calculamos o fatorial de n-1...</p>
<p>            Como 0 é igual a 0, tomamos o primeiro ramo e devolvemos 1 sem fazer mais chamadas recursivas.</p>
<p>        O valor de retorno, 1, é multiplicado por n, que é 1, e o resultado é devolvido.</p>
<p>    O valor de retorno, 1, é multiplicado por n, que é 2, e o resultado é devolvido.</p>
<p>O valor devolvido (2) é multiplicado por n, que é 3, e o resultado, 6, torna-se o valor devolvido pela chamada de função que começou o processo inteiro.</p>
<p>A Figura 6.1 mostra como é o diagrama da pilha para esta sequência de chamadas de função.</p>
<p><img src="06-funcoes-com-resultado//fig/tnkp_0601.png" alt="Figura 6.1 – Diagrama da pilha para factorial" />.
<br><em>Figura 6.1 – Diagrama da pilha para factorial.</em></p>
<p>Os valores devolvidos são mostrados ao serem passados de volta até o alto da pilha. Em cada frame, o valor devolvido é o valor de <code>result</code>, que é o produto de <code>n</code> e <code>recurse</code>.</p>
<p>No último frame, as variáveis locais recurse e result não existem, porque o ramo que os cria não é executado.</p>
<h2><a class="header" href="#66---salto-de-fé" id="66---salto-de-fé">6.6 - Salto de fé</a></h2>
<p>Seguir o fluxo da execução é uma forma de ler programas, mas poderá ser trabalhoso demais. Uma alternativa é o que chamo de “salto de fé” (leap of faith). Ao chegar a uma chamada de função, em vez de seguir o fluxo de execução suponha que a função esteja funcionando corretamente e que está retornando o resultado certo.</p>
<p>Na verdade, você já está praticando este salto de fé quando usa funções integradas. Quando chama math.cos ou math.exp, você não examina o corpo dessas funções. Apenas supõe que funcionem porque as pessoas que as escreveram eram bons programadores.</p>
<p>O mesmo acontece ao chamar uma das suas próprias funções. Por exemplo, em “Funções booleanas”, na página 97, escrevemos uma função chamada is_divisible que determina se um número é divisível por outro. Uma vez que estejamos convencidos de que esta função está correta – examinando o código e testando – podemos usar a função sem ver o corpo novamente.</p>
<p>O mesmo é verdade para programas recursivos. Quando chega à chamada recursiva, em vez de seguir o fluxo de execução, você deveria supor que a chamada recursiva funcione (devolva o resultado correto) e então perguntar-se: “Supondo que eu possa encontrar o fatorial de n-1, posso calcular o fatorial de n?”. É claro que pode, multiplicando por n.</p>
<p>Naturalmente, é um pouco estranho supor que a função funcione corretamente quando ainda não terminou de escrevê-la, mas é por isso que se chama um salto de fé!</p>
<h2><a class="header" href="#67---mais-um-exemplo" id="67---mais-um-exemplo">6.7 - Mais um exemplo</a></h2>
<p>Depois do factorial, o exemplo mais comum de uma função matemática definida recursivamente é fibonacci, que tem a seguinte definição (ver <a href="http://en.wikipedia.org/wiki/Fibonacci_number">http://en.wikipedia.org/wiki/Fibonacci_number</a>):</p>
<pre><code>fibonacci(0) = 0
fibonacci(1) = 1
fibonacci(n) = fibonacci(n − 1) + fibonacci(n − 2)
</code></pre>
<p>Traduzida para Python, ela fica assim:</p>
<pre><code class="language-python">def fibonacci (n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)
</code></pre>
<p>Se tentar seguir o fluxo de execução aqui, até para valores razoavelmente pequenos de n, sua cabeça explode. Porém, seguindo o salto de fé, supondo que as duas chamadas recursivas funcionem corretamente, então é claro que vai receber o resultado correto adicionando-as juntas.</p>
<h2><a class="header" href="#68---verificação-de-tipos" id="68---verificação-de-tipos">6.8 - Verificação de tipos</a></h2>
<p>O que acontece se chamarmos factorial e usarmos 1.5 como argumento?</p>
<pre><code class="language-python">&gt;&gt;&gt; factorial(1.5)
RuntimeError: Maximum recursion depth exceeded
</code></pre>
<p>Parece uma recursividade infinita. No entanto, por que isso acontece? A função tem um caso-base – quando n == 0. Mas se n não é um número inteiro, podemos perder o caso-base e recorrer para sempre.</p>
<p>Na primeira chamada recursiva, o valor de n é 0.5. No seguinte, é -0.5. Daí, torna-se menor (mais negativo), mas nunca será 0.</p>
<p>Temos duas escolhas. Podemos tentar generalizar a função factorial para trabalhar com números de ponto flutuante, ou podemos fazer factorial controlar o tipo de argumento que recebe. A primeira opção chama-se função gamma e está um pouco além do alcance deste livro. Então usaremos a segunda opção.</p>
<p>Podemos usar a função integrada isinstance para verificar o tipo de argumento. E vamos aproveitar para verificar também se o argumento é positivo:</p>
<pre><code class="language-python">def factorial (n):
    if not isinstance(n, int):
        print('Factorial is only defined for integers.')
        return None
    elif n &lt; 0:
        print('Factorial is not defined for negative integers.')
        return None
    elif n == 0:
        return 1
    else:
        return n * factorial(n-1)
</code></pre>
<p>O primeiro caso-base lida com números não inteiros; o segundo, com números inteiros negativos. Em ambos os casos o programa exibe uma mensagem de erro e retorna None para indicar que algo deu errado:</p>
<pre><code class="language-python">&gt;&gt;&gt; factorial('fred')
Factorial is only defined for integers.
None
&gt;&gt;&gt; factorial(-2)
Factorial is not defined for negative integers.
None
</code></pre>
<p>Se passarmos por ambas as verificações, sabemos que n é positivo ou zero, então podemos comprovar que a recursividade termina.</p>
<p>Esse programa demonstra um padrão às vezes chamado de <a href="06-funcoes-com-resultado/10-glossario.html#guardi%C3%A3o">guardião</a>. As duas primeiras condicionais atuam como guardiãs, protegendo o código que segue de valores que poderiam causar um erro. As guardiãs permitem comprovar a correção do código.</p>
<p>Na “Busca reversa”, na página 165, veremos uma alternativa mais flexível para a exibição de uma mensagem de erro: o levantamento de exceções.</p>
<h2><a class="header" href="#69---depuração" id="69---depuração">6.9 - Depuração</a></h2>
<p>Quebrar um grande programa em funções menores cria controles naturais da depuração. Se uma função não estiver funcionando, há três possibilidades a considerar:</p>
<ul>
<li>
<p>Há algo errado com os argumentos que a função está recebendo; uma precondição está sendo violada.</p>
</li>
<li>
<p>Há algo errado com a função; uma pós-condição foi violada.</p>
</li>
<li>
<p>Há algo errado com o valor de retorno ou a forma na qual está sendo usado.</p>
</li>
</ul>
<p>Para excluir a primeira possibilidade, você pode acrescentar uma instrução print no início da função e exibir os valores dos parâmetros (e talvez os seus tipos). Ou escrever código que verifique as precondições explicitamente.</p>
<p>Se os parâmetros parecerem bons, acrescente uma instrução print antes de cada instrução return e exiba o valor de retorno. Se possível, verifique o resultado à mão. Uma possibilidade é chamar a função com valores facilitem a verificação do resultado (como no “Desenvolvimento incremental”, da página 94).</p>
<p>Se a função parecer funcionar, veja a chamada da função para ter certeza de que o valor de retorno está sendo usado corretamente (ou se está sendo usado mesmo!).</p>
<p>Acrescentar instruções de exibição no começo e no fim de uma função pode ajudar a tornar o fluxo de execução mais visível. Por exemplo, aqui está uma versão de factorial com instruções de exibição:</p>
<pre><code class="language-python">def factorial(n):
    space = ' ' * (4 * n)
    print(space, 'factorial', n)
    if n == 0:
        print(space, 'returning 1')
        return 1
    else:
        recurse = factorial(n-1)
        result = n * recurse
        print(space, 'returning', result)
        return result
</code></pre>
<p>space é uma string de caracteres especiais que controla a endentação da saída. Aqui está o resultado de factorial(4):</p>
<pre><code>                factorial 4
            factorial 3
        factorial 2
    factorial 1
factorial 0
returning 1
    returning 1
        returning 2
            returning 6
                returning 24
</code></pre>
<p>Se o fluxo de execução parecer confuso a você, este tipo de saída pode ser útil. Leva um tempo para desenvolver um scaffolding eficaz, mas um pouco dele pode economizar muita depuração.</p>
<h2><a class="header" href="#610---glossário" id="610---glossário">6.10 - Glossário</a></h2>
<h5><a class="header" href="#variável-temporária" id="variável-temporária">variável temporária</a></h5>
<p>    Uma variável usada para guardar um valor intermediário em um cálculo complexo.</p>
<h5><a class="header" href="#código-morto" id="código-morto">código morto</a></h5>
<p>    A parte de um programa que nunca pode ser executada, muitas vezes porque aparece depois de uma instrução return.</p>
<h5><a class="header" href="#desenvolvimento-incremental" id="desenvolvimento-incremental">desenvolvimento incremental</a></h5>
<p>    Um plano de desenvolvimento de programa para evitar a depuração, que acrescenta e testa poucas linhas de código de cada vez.</p>
<h5><a class="header" href="#scaffolding-andaime" id="scaffolding-andaime">scaffolding (andaime)</a></h5>
<p>    O código que se usa durante o desenvolvimento de programa, mas que não faz parte da versão final.</p>
<h5><a class="header" href="#guardião" id="guardião">guardião</a></h5>
<p>    Um padrão de programação que usa uma instrução condicional para verificar e lidar com circunstâncias que possam causar erros.</p>
<h2><a class="header" href="#611---exercícios" id="611---exercícios">6.11 - Exercícios</a></h2>
<h3><a class="header" href="#exercício-61" id="exercício-61">Exercício 6.1</a></h3>
<p>Desenhe um diagrama da pilha do seguinte programa. O que o programa exibe?</p>
<pre><code class="language-python">def b(z):
    prod = a(z, z)
    print(z, prod)
    return prod

def a(x, y):
    x = x + 1
    return x * y

def c(x, y, z):
    total = x + y + z
    square = b(total)**2
    return square

x = 1
y = x + 1
print(c(x, y+3, x+y))
</code></pre>
<h3><a class="header" href="#exercício-62" id="exercício-62">Exercício 6.2</a></h3>
<p>A função de Ackermann, A(m, n), é definida assim:</p>
<p><img src="06-funcoes-com-resultado//fig/p72f1.png" alt="Fórmula – Função de Ackermann" />.</p>
<p>Veja <a href="http://en.wikipedia.org/wiki/Ackermann_function">http://en.wikipedia.org/wiki/Ackermann_function</a>. Escreva uma função denominada ack que avalie a função de Ackermann. Use a sua função para avaliar <code>ack(3, 4)</code>, cujo resultado deve ser 125. O que acontece para valores maiores de m e n?</p>
<p>Solução: <a href="http://thinkpython2.com/code/ackermann.py">http://thinkpython2.com/code/ackermann.py</a>.</p>
<h3><a class="header" href="#exercício-63" id="exercício-63">Exercício 6.3</a></h3>
<p>Um palíndromo é uma palavra que se soletra da mesma forma nos dois sentidos, como “osso” e “reviver”. Recursivamente, uma palavra é um palíndromo se a primeira e última letras forem iguais e o meio for um palíndromo.</p>
<p>As funções seguintes recebem uma string como argumento e retornam as letras iniciais, finais e do meio das palavras:</p>
<pre><code class="language-python">def first(word):
    return word[0]
def last(word):
    return word[-1]
def middle(word):
    return word[1:-1]
</code></pre>
<p>Veremos como funcionam no Capítulo 8.</p>
<ol>
<li>
<p>Digite essas funções em um arquivo chamado palindrome.py e teste-as. O que acontece se chamar middle com uma string de duas letras? Uma letra? E se a string estiver vazia, escrita com <code>''</code> e não contiver nenhuma letra?</p>
</li>
<li>
<p>Escreva uma função chamada <code>is_palindrome</code> que receba uma string como argumento e retorne True se for um palíndromo e False se não for. Lembre-se de que você pode usar a função integrada len para verificar o comprimento de uma string.</p>
</li>
</ol>
<p>Solução: <a href="http://thinkpython2.com/code/palindrome_soln.py">http://thinkpython2.com/code/palindrome_soln.py</a>.</p>
<h3><a class="header" href="#exercício-64" id="exercício-64">Exercício 6.4</a></h3>
<p>Um número a é uma potência de b se for divisível por b e a/b for uma potência de b. Escreva uma função chamada is_power que receba os parâmetros a e b e retorne True se a for uma potência de b. Dica: pense no caso-base.</p>
<h3><a class="header" href="#exercício-65" id="exercício-65">Exercício 6.5</a></h3>
<p>O maior divisor comum (MDC, ou GCD em inglês) de a e b é o maior número que divide ambos sem sobrar resto.</p>
<p>Um modo de encontrar o MDC de dois números é observar qual é o resto r quando a é dividido por b, verificando que gcd(a, b) = gcd(b, r). Como caso-base, podemos usar gcd(a, 0) = a.</p>
<p>Escreva uma função chamada gcd que receba os parâmetros a e b e devolva o maior divisor comum.</p>
<p>Crédito: Este exercício é baseado em um exemplo do livro de Abelson e Sussman, Structure and Interpretation of Computer Programs (Estrutura e interpretação de programas de computador, MIT Press, 1996).</p>
<h1><a class="header" href="#capítulo-7-iteração" id="capítulo-7-iteração">Capítulo 7: Iteração</a></h1>
<p>Este capítulo é sobre a <a href="07-iteracao/08-glossario.html#itera%C3%A7%C3%A3o">iteração</a>, a capacidade de executar um bloco de instruções repetidamente. Vimos um tipo de iteração, usando a recursividade, em “Recursividade”, na página 81. Vimos outro tipo, usando um loop for, em “Repetição simples”, na página 65. Neste capítulo veremos ainda outro tipo, usando a instrução while. Porém, primeiro quero falar um pouco mais sobre a atribuição de variáveis.</p>
<h2><a class="header" href="#71---reatribuição" id="71---reatribuição">7.1 - Reatribuição</a></h2>
<p>Pode ser que você já tenha descoberto que é permitido fazer mais de uma atribuição para a mesma variável. Uma nova atribuição faz uma variável existente referir-se a um novo valor (e deixar de referir-se ao valor anterior).</p>
<pre><code class="language-python">&gt;&gt;&gt; x = 5
&gt;&gt;&gt; x
5
&gt;&gt;&gt; x = 7
&gt;&gt;&gt; x
7
</code></pre>
<p>A primeira vez que exibimos x, seu valor é 5; na segunda vez, seu valor é 7.</p>
<p>A Figura 7.1 mostra que a <a href="07-iteracao/08-glossario.html#reatribui%C3%A7%C3%A3o">reatribuição</a> parece um diagrama de estado.</p>
<p>Neste ponto quero tratar de uma fonte comum de confusão. Como o Python usa o sinal de igual (=) para atribuição, é tentador interpretar uma afirmação como a = b como uma proposição matemática de igualdade; isto é, a declaração de que a e b são iguais. Mas esta é uma interpretação equivocada.</p>
<p>Em primeiro lugar, a igualdade é uma relação simétrica e a atribuição não é. Por exemplo, na matemática, se a=7 então 7=a. Mas no Python, a instrução a = 7 é legal e 7 = a não é.</p>
<p>Além disso, na matemática, uma proposição de igualdade é verdadeira ou falsa para sempre. Se a=b agora, então a sempre será igual a b. No Python, uma instrução de atribuição pode tornar duas variáveis iguais, mas elas não precisam se manter assim:</p>
<pre><code class="language-python">&gt;&gt;&gt; a = 5
&gt;&gt;&gt; b = a    # a e b agora são iguais
&gt;&gt;&gt; a = 3    # a e b não são mais iguais
&gt;&gt;&gt; b
5
</code></pre>
<p>A terceira linha modifica o valor de a, mas não muda o valor de b, então elas já não são iguais.</p>
<p>A reatribuição de variáveis muitas vezes é útil, mas você deve usá-la com prudência. Se os valores das variáveis mudarem frequentemente, isso pode dificultar a leitura e depuração do código.</p>
<pre><code class="language-python">Figura 7.1 – Diagrama de estado.
</code></pre>
<p><img src="07-iteracao//fig/tnkp_0701.png" alt="Figura 7.1 – Diagrama de estado da variável x" />.
<br><em>Figura 7.1 – Diagrama de estado da variável x.</em></p>
<h2><a class="header" href="#72---atualização-de-variáveis" id="72---atualização-de-variáveis">7.2 - Atualização de variáveis</a></h2>
<p>Um tipo comum de <a href="07-iteracao/08-glossario.html#reatribui%C3%A7%C3%A3o">reatribuição</a> é uma <a href="07-iteracao/08-glossario.html#atualiza%C3%A7%C3%A3o">atualização</a>, onde o novo valor da variável depende do velho.</p>
<pre><code class="language-python">&gt;&gt;&gt; x = x + 1
</code></pre>
<p>Isso significa “pegue o valor atual de x, acrescente um, e então atualize x para o novo valor”.</p>
<p>Se você tentar atualizar uma variável que não existe, recebe um erro porque o Python avalia o lado direito antes de atribuir um valor a x:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = x + 1
NameError: name 'x' is not defined
</code></pre>
<p>Antes de poder atualizar uma variável é preciso inicializá-la, normalmente com uma atribuição simples:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = 0
&gt;&gt;&gt; x = x + 1
</code></pre>
<p>Atualizar uma variável acrescentando 1 chama-se <a href="07-iteracao/08-glossario.html#incremento">incremento</a>; subtrair 1 chama-se <a href="07-iteracao/08-glossario.html#decremento">decremento</a>.</p>
<h2><a class="header" href="#73---instrução-while" id="73---instrução-while">7.3 - Instrução while</a></h2>
<p>Os computadores muitas vezes são usados para automatizar tarefas repetitivas. A repetição de tarefas idênticas ou semelhantes sem fazer erros é algo que os computadores fazem bem e as pessoas não. Em um programa de computador, a repetição também é chamada de <a href="07-iteracao/08-glossario.html#itera%C3%A7%C3%A3o">iteração</a>.</p>
<p>Já vimos duas funções, <code>countdown</code> e <code>print_n</code>, que se repetem usando recursividade. Como a iteração é bem comum, o Python fornece recursos de linguagem para facilitá-la. Um deles é a instrução <code>for</code> que vimos em “Repetição simples”, na página 65. Voltaremos a isso mais adiante.</p>
<p>Outra é a instrução <code>while</code>. Aqui está uma versão de countdown que usa a instrução <code>while</code>:</p>
<pre><code class="language-python">def countdown(n):
    while n &gt; 0:
        print(n)
        n = n - 1
    print('Blastoff!')
</code></pre>
<p>Você até pode ler a instrução <code>while</code> como se fosse uma tradução do inglês. Significa “Enquanto <code>n</code> for maior que 0, mostre o valor de <code>n</code> e então decremente <code>n</code>. Quando chegar a 0, mostre a palavra Blastoff!”</p>
<p>Mais formalmente, aqui está o fluxo de execução para uma instrução while:</p>
<ol>
<li>
<p>Determine se a condição é verdadeira ou falsa.</p>
</li>
<li>
<p>Se for falsa, saia da instrução while e continue a execução da próxima instrução.</p>
</li>
<li>
<p>Se a condição for verdadeira, execute o corpo e então volte ao passo 1.</p>
</li>
</ol>
<p>Este tipo de fluxo chama-se loop (laço), porque o terceiro passo faz um loop de volta ao topo.</p>
<p>O corpo do loop deve mudar o valor de uma ou mais variáveis para que, a certa altura, a condição fique falsa e o loop termine. Senão o loop vai se repetir para sempre, o que é chamado de <a href="07-iteracao/08-glossario.html#loop-infinito">loop infinito</a>. Uma fonte infindável de divertimento para cientistas da computação é a observação das instruções no xampu, “Faça espuma, enxágue, repita”, que são parte de um loop infinito.</p>
<p>No caso de countdown, podemos provar que o loop termina: se <code>n</code> for zero ou negativo, o loop nunca é executado. Senão, <code>n</code> fica cada vez menor ao passar pelo loop, até eventualmente chegar a 0.</p>
<p>Para alguns outros loops, não é tão fácil perceber isso. Por exemplo:</p>
<pre><code class="language-python">def sequence(n):
    while n != 1:
        print(n)
        if n % 2 == 0:        # n é par
            n = n / 2
        else:                 # n é ímpar
            n = n * 3 + 1
</code></pre>
<p>A condição deste loop é <code>n != 1</code>, então o loop continuará até que <code>n</code> seja 1, o que torna a condição falsa.</p>
<p>Cada vez que passa pelo loop, o programa produz o valor de <code>n</code> e então verifica se é par ou ímpar. Se for par, <code>n</code> é dividido por 2. Se for ímpar, o valor de <code>n</code> é substituído por <code>n * 3 + 1</code>. Por exemplo, se o argumento passado a sequence for 3, os valores resultantes de <code>n</code> são 3, 10, 5, 16, 8, 4, 2, 1.</p>
<p>Como <code>n</code> às vezes aumenta e às vezes diminui, não há nenhuma prova óbvia de que <code>n</code> chegará eventualmente a 1, ou que o programa terminará. Para alguns valores de <code>n</code>, podemos provar o término. Por exemplo, se o valor inicial for uma potência de dois, <code>n</code> será par cada vez que passar pelo loop até que chegue a 1. O exemplo anterior termina com uma sequência assim, que inicia com 16.</p>
<p>A questão difícil é se podemos provar que este programa termina para todos os valores positivos de <code>n</code>. Por enquanto, ninguém foi capaz de comprovar ou refutar isso! (Veja <a href="http://en.wikipedia.org/wiki/Collatz_conjecture">http://en.wikipedia.org/wiki/Collatz_conjecture</a>.)</p>
<p>Como um exercício, reescreva a função print_n de “Recursividade”, na página 81, usando a iteração em vez da recursividade.</p>
<h2><a class="header" href="#74---break" id="74---break">7.4 - break</a></h2>
<p>Às vezes você não sabe que está na hora de terminar um loop até que já esteja na metade do corpo. Neste caso pode usar a instrução break para sair do loop.</p>
<p>Por exemplo, suponha que você quer receber uma entrada do usuário até que este digite done. Você pode escrever:</p>
<pre><code class="language-python">while True:
    line = input('&gt; ')
    if line == 'done':
        break
    print(line)
print('Done!')
</code></pre>
<p>A condição do loop é True, que sempre é verdade, então o loop roda até que chegue à instrução de interrupção.</p>
<p>Cada vez que passa pelo loop, o programa apresenta ao usuário um colchete angular. Se o usuário digitar done, a instrução break sai do loop. Senão, o programa ecoa o que quer que o usuário digite e volta ao topo do loop. Aqui está uma amostra de execução:</p>
<pre><code class="language-python">&gt; not done
not done
&gt; done
Done!
</code></pre>
<p>Esta forma de escrever loops while é comum porque podemos verificar a condição em qualquer lugar do loop (não somente no topo) e podemos exprimir a condição de parada afirmativamente (“pare quando isto acontecer”) em vez de negativamente (“continue a seguir até que isto aconteça”).</p>
<h2><a class="header" href="#75---raízes-quadradas" id="75---raízes-quadradas">7.5 - Raízes quadradas</a></h2>
<p>Loops muitas vezes são usados em programas que calculam resultados numéricos, começando com uma resposta aproximada e melhorando-a iterativamente.</p>
<p>Por exemplo, uma forma de calcular raízes quadradas é o método de Newton. Suponha que você queira saber a raiz quadrada de a. Se começar com quase qualquer estimativa, x, é possível calcular uma estimativa melhor com a seguinte fórmula:</p>
<p><img src="07-iteracao//fig/p79f1.png" alt="Fórmula – Raiz quadrada pelo método de Newton" />.</p>
<pre><code class="language-python">Por exemplo, se a for 4 e x for 3:
&gt;&gt;&gt; a = 4
&gt;&gt;&gt; x = 3
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.16666666667
</code></pre>
<p>O resultado é mais próximo à resposta correta (<img src="07-iteracao//fig/p79f2.png" alt="Fórmula – Raiz quadrada de 4" />. = 2). Se repetirmos o processo com a nova estimativa, chegamos ainda mais perto:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.00641025641
</code></pre>
<p>Depois de algumas atualizações, a estimativa é quase exata:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.00001024003
&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.00000000003
</code></pre>
<p>Em geral, não sabemos com antecedência quantos passos são necessários para chegar à resposta correta, mas sabemos quando chegamos lá porque a estimativa para de mudar:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.0
&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.0
</code></pre>
<p>Quando y == x, podemos parar. Aqui está um loop que começa com uma estimativa inicial, x, e a melhora até que deixe de mudar:</p>
<pre><code class="language-python">while True:
    print(x)
    y = (x + a/x) / 2
    if y == x:
        break
    x = y
</code></pre>
<p>Para a maior parte de valores de <code>a</code> funciona bem, mas pode ser perigoso testar a igualdade de um float. Os valores de ponto flutuante são aproximadamente corretos: a maioria dos números racionais, como 1/3, e números irracionais, como <img src="07-iteracao//fig/p80f1.png" alt="Fórmula – Raiz quadrada de 2" />., não podem ser representados exatamente com um float.</p>
<p>Em vez de verificar se <code>x</code> e <code>y</code> são exatamente iguais, é mais seguro usar a função integrada <code>abs</code> para calcular o valor absoluto ou magnitude da diferença entre eles:</p>
<pre><code class="language-python">if abs(y-x) &lt; epsilon:
    break
</code></pre>
<p>Onde <code>epsilon</code> tem um valor como 0.0000001, que determina a proximidade desejada entre <code>x</code> e <code>y</code>.</p>
<h2><a class="header" href="#76---algoritmos" id="76---algoritmos">7.6 - Algoritmos</a></h2>
<p>O método de Newton é um exemplo de um <a href="07-iteracao/08-glossario.html#algoritmo">algoritmo</a>: um processo mecânico para resolver uma categoria de problemas (neste caso, calcular raízes quadradas).</p>
<p>Para entender o que é um algoritmo, pode ser útil começar com algo que não é um algoritmo. Quando aprendeu a multiplicar números de um dígito, você provavelmente memorizou a tabuada. Ou seja, você memorizou 100 soluções específicas. Este tipo de conhecimento não é algorítmico.</p>
<p>No entanto, se você foi “preguiçoso”, poderia ter aprendido alguns truques. Por exemplo, para encontrar o produto de <code>n</code> e 9, pode escrever <code>n-1</code> como o primeiro dígito e <code>10-n</code> como o segundo dígito. Este truque é uma solução geral para multiplicar qualquer número de dígito único por 9. Isto é um algoritmo!</p>
<p>De forma semelhante, as técnicas que aprendeu, como o transporte na adição, o empréstimo na subtração e a divisão longa são todos algoritmos. Uma das características de algoritmos é que eles não exigem inteligência para serem executados. São processos mecânicos, nos quais cada passo segue a partir do último, de acordo com um conjunto de regras simples.</p>
<p>A execução de algoritmos é maçante, mas projetá-los é interessante, intelectualmente desafiador e uma parte central da Ciência da Computação.</p>
<p>Algumas coisas que as pessoas fazem naturalmente, sem dificuldade ou pensamento consciente, são as mais difíceis para exprimir algoritmicamente. A compreensão de linguagem natural é um bom exemplo. Todos nós o fazemos, mas por enquanto ninguém foi capaz de explicar como o fazemos, pelo menos não na forma de um algoritmo.</p>
<h2><a class="header" href="#77---depuração" id="77---depuração">7.7 - Depuração</a></h2>
<p>Ao começar a escrever programas maiores, pode ser que você passe mais tempo depurando. Mais código significa mais possibilidades fazer erros e mais lugares para esconder defeitos.</p>
<p>Uma forma de cortar o tempo de depuração é “depurar por bisseção”. Por exemplo, se há 100 linhas no seu programa e você as verifica uma a uma, seriam 100 passos a tomar.</p>
<p>Em vez disso, tente quebrar o problema pela metade. Olhe para o meio do programa, ou perto disso, para um valor intermediário que possa verificar. Acrescente uma instrução print (ou outra coisa que tenha um efeito verificável) e execute o programa.</p>
<p>Se a verificação do ponto central for incorreta, deve haver um problema na primeira metade do programa. Se for correta, o problema está na segunda metade.</p>
<p>Cada vez que executar uma verificação assim, divida ao meio o número de linhas a serem verificadas. Depois de seis passos (que é menos de 100), você teria menos de uma ou duas linhas do código para verificar, pelo menos em teoria.</p>
<p>Na prática, nem sempre é claro o que representa o “meio do programa” e nem sempre é possível verificá-lo. Não faz sentido contar linhas e encontrar o ponto central exato. Em vez disso, pense em lugares no programa onde poderia haver erros e lugares onde é fácil inserir um ponto de verificação. Então escolha um lugar onde as possibilidades são basicamente as mesmas de que o defeito esteja antes ou depois da verificação.</p>
<h2><a class="header" href="#78---glossário" id="78---glossário">7.8 - Glossário</a></h2>
<h5><a class="header" href="#reatribuição" id="reatribuição">reatribuição</a></h5>
<p>    Atribuir um novo valor a uma variável que já existe.</p>
<h5><a class="header" href="#atualização" id="atualização">atualização</a></h5>
<p>    Uma atribuição onde o novo valor da variável dependa do velho.</p>
<h5><a class="header" href="#inicialização" id="inicialização">inicialização</a></h5>
<p>    Uma atribuição que dá um valor inicial a uma variável que será atualizada.</p>
<h5><a class="header" href="#incremento" id="incremento">incremento</a></h5>
<p>    Uma atualização que aumenta o valor de uma variável (normalmente por uma unidade).</p>
<h5><a class="header" href="#decremento" id="decremento">decremento</a></h5>
<p>    Uma atualização que reduz o valor de uma variável.</p>
<h5><a class="header" href="#iteração" id="iteração">iteração</a></h5>
<p>    Execução repetida de um grupo de instruções, usando uma chamada da função recursiva ou um loop.</p>
<h5><a class="header" href="#loop-infinito" id="loop-infinito">loop infinito</a></h5>
<p>    Um loop no qual a condição de término nunca é satisfeita.</p>
<h5><a class="header" href="#algoritmo" id="algoritmo">algoritmo</a></h5>
<p>    Um processo geral para resolver uma categoria de problemas.</p>
<h2><a class="header" href="#79---exercícios" id="79---exercícios">7.9 - Exercícios</a></h2>
<h3><a class="header" href="#exercício-71" id="exercício-71">Exercício 7.1</a></h3>
<p>Copie o loop de “Raízes quadradas”, na página 111, e encapsule-o em uma função chamada <code>mysqrt</code> que receba a como parâmetro, escolha um valor razoável de x e devolva uma estimativa da raiz quadrada de a.</p>
<p>Para testar, escreva uma função denominada <code>test_square_root</code>, que exibe uma tabela como esta:</p>
<pre><code class="language-python">a   mysqrt(a)     math.sqrt(a)  diff
-   ---------     ------------  ----
1.0 1.0           1.0           0.0
2.0 1.41421356237 1.41421356237 2.22044604925e-16
3.0 1.73205080757 1.73205080757 0.0
4.0 2.0           2.0           0.0
5.0 2.2360679775  2.2360679775  0.0
6.0 2.44948974278 2.44948974278 0.0
7.0 2.64575131106 2.64575131106 0.0
8.0 2.82842712475 2.82842712475 4.4408920985e-16
9.0 3.0           3.0           0.0
</code></pre>
<p>A primeira coluna é um número, <code>a</code>; a segunda coluna é a raiz quadrada de a calculada com <code>mysqrt</code>; a terceira coluna é a raiz quadrada calculada por <code>math.sqrt</code>; a quarta coluna é o valor absoluto da diferença entre as duas estimativas.</p>
<h3><a class="header" href="#exercício-72" id="exercício-72">Exercício 7.2</a></h3>
<p>A função integrada <code>eval</code> toma uma string e a avalia, usando o interpretador do Python. Por exemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; eval('1 + 2 * 3')
7
&gt;&gt;&gt; import math
&gt;&gt;&gt; eval('math.sqrt(5)')
2.2360679774997898
&gt;&gt;&gt; eval('type(math.pi)')
&lt;class 'float'&gt;
</code></pre>
<p>Escreva uma função chamada <code>eval_loop</code> que iterativamente peça uma entrada ao usuário, a avalie usando <code>eval</code> e exiba o resultado.</p>
<p>Ela deve continuar até que o usuário digite <code>done</code>; então deverá exibir o valor da última expressão avaliada.</p>
<h3><a class="header" href="#exercício-73" id="exercício-73">Exercício 7.3</a></h3>
<p>O matemático Srinivasa Ramanujan encontrou uma série infinita que pode ser usada para gerar uma aproximação numérica de 1/π:</p>
<p><img src="07-iteracao//fig/p83f1.png" alt="Fórmula – Aproximação de π pela série de Ramanujan" />.</p>
<p>Escreva uma função chamada <code>estimate_pi</code> que use esta fórmula para computar e devolver uma estimativa de π. Você deve usar o loop <code>while</code> para calcular os termos da adição até que o último termo seja menor que 1e-15 (que é a notação do Python para <code>10 ** 15</code>). Você pode verificar o resultado comparando-o com <code>math.pi</code>.</p>
<h1><a class="header" href="#capítulo-8-strings" id="capítulo-8-strings">Capítulo 8: Strings</a></h1>
<p>Strings não são como números inteiros, de ponto flutuante ou booleanos. Uma string é uma <a href="08-strings/12-glossario.html#sequ%C3%AAncia">sequência</a>, ou seja, uma coleção ordenada de outros valores. Neste capítulo você verá como acessar os caracteres que compõem uma string e aprenderá alguns métodos que as strings oferecem.</p>
<h2><a class="header" href="#81---uma-string-é-uma-a-href08-strings12-glossariohtmlsequc3aanciasequênciaa" id="81---uma-string-é-uma-a-href08-strings12-glossariohtmlsequc3aanciasequênciaa">8.1 - Uma string é uma <a href="08-strings/12-glossario.html#sequ%C3%AAncia">sequência</a></a></h2>
<p>Uma string é uma sequência de caracteres. Você pode acessar um caractere de cada vez com o operador de colchete:</p>
<pre><code class="language-python">&gt;&gt;&gt; fruit = 'banana'
&gt;&gt;&gt; letter = fruit[1]
</code></pre>
<p>A segunda instrução seleciona o caractere número 1 de fruit e o atribui a letter.</p>
<p>A expressão entre colchetes chama-se <a href="08-strings/12-glossario.html#%C3%ADndice">índice</a>. O índice aponta qual caractere da sequência você quer (daí o nome).</p>
<pre><code class="language-python">Mas pode ser que você não obtenha o que espera:
&gt;&gt;&gt; letter
'a'
</code></pre>
<p>Para a maior parte das pessoas, a primeira letra de 'banana' é b, não a. Mas para os cientistas da computação, o índice é uma referência do começo da string, e a referência da primeira letra é zero.</p>
<pre><code class="language-python">&gt;&gt;&gt; letter = fruit[0]
&gt;&gt;&gt; letter
'b'
</code></pre>
<p>Então b é a 0ª (“zerésima”) letra de 'banana', a é a 1ª (primeira) letra e n é a 2ª (segunda) letra.</p>
<p>Você pode usar uma expressão que contenha variáveis e operadores como índice:</p>
<pre><code class="language-python">&gt;&gt;&gt; i = 1
&gt;&gt;&gt; fruit[i]
'a'
&gt;&gt;&gt; fruit[i+1]
'n'
</code></pre>
<p>Porém, o valor do índice tem que ser um número inteiro. Se não for, é isso que aparece:</p>
<pre><code class="language-python">&gt;&gt;&gt; letter = fruit[1.5]
TypeError: string indices must be integers
</code></pre>
<h2><a class="header" href="#82---len" id="82---len">8.2 - len</a></h2>
<p>len é uma função integrada que devolve o número de caracteres em uma string:</p>
<pre><code class="language-python">&gt;&gt;&gt; fruit = 'banana'
&gt;&gt;&gt; len(fruit)
6
</code></pre>
<p>Para obter a última letra de uma string, pode parecer uma boa ideia tentar algo assim:</p>
<pre><code class="language-python">&gt;&gt;&gt; length = len(fruit)
&gt;&gt;&gt; last = fruit[length]
IndexError: string index out of range
</code></pre>
<p>A razão de haver um IndexError aqui é que não há nenhuma letra em 'banana' com o <a href="08-strings/12-glossario.html#%C3%ADndice">índice</a> 6. Como a contagem inicia no zero, as seis letras são numeradas de 0 a 5. Para obter o último caractere, você deve subtrair 1 de length:</p>
<pre><code class="language-python">&gt;&gt;&gt; last = fruit[length-1]
&gt;&gt;&gt; last
'a'
</code></pre>
<p>Ou você pode usar índices negativos, que contam de trás para a frente a partir do fim da string. A expressão fruit[-1] apresenta a última letra, fruit[-2] apresenta a segunda letra de trás para a frente, e assim por diante.</p>
<h2><a class="header" href="#83---travessia-com-loop-for" id="83---travessia-com-loop-for">8.3 - Travessia com loop for</a></h2>
<p>Muitos cálculos implicam o processamento de um caractere por vez em uma string. Muitas vezes começam no início, selecionam um caractere por vez, fazem algo e continuam até o fim. Este modelo do processamento chama-se travessia. Um modo de escrever uma travessia é com o loop while:</p>
<pre><code class="language-python">index = 0
while index &lt; len(fruit):
    letter = fruit[index]
    print(letter)
    index = index + 1
</code></pre>
<p>Este loop atravessa a string e exibe cada letra sozinha em uma linha. A condição do loop é index &lt;len (fruit), então quando index é igual ao comprimento da string, a condição é falsa e o corpo do loop não é mais executado. O último caractere acessado é aquele com o <a href="08-strings/12-glossario.html#%C3%ADndice">índice</a> len (fruit)-1, que é o último caractere na string.</p>
<p>Como exercício, escreva uma função que receba uma string como argumento e exiba as letras de trás para a frente, uma por linha.</p>
<p>Outra forma de escrever uma travessia é com um loop for:</p>
<pre><code class="language-python">for letter in fruit:
    print(letter)
</code></pre>
<p>Cada vez que o programa passar pelo loop, o caractere seguinte na string é atribuído à variável letter. O loop continua até que não sobre nenhum caractere.</p>
<p>O próximo exemplo mostra como usar a concatenação (adição de strings) e um loop for para gerar uma série abecedária (isto é, em ordem alfabética). No livro de Robert McCloskey, Make Way for Ducklings (Abram caminho para os patinhos), os nomes dos patinhos são Jack, Kack, Lack, Mack, Nack, Ouack, Pack e Quack. Este loop produz estes nomes em ordem:</p>
<pre><code class="language-python">prefixes = 'JKLMNOPQ'
suffix = 'ack'
for letter in prefixes:
    print(letter + suffix)
A saída é:
Jack
Kack
Lack
Mack
Nack
Oack
Pack
Qack
</code></pre>
<p>Claro que não está exatamente certo porque “Ouack” e “Quack” foram mal soletrados. Como exercício, altere o programa para corrigir este erro.</p>
<h2><a class="header" href="#84---fatiamento-de-strings" id="84---fatiamento-de-strings">8.4 - Fatiamento de strings</a></h2>
<p>Um segmento de uma string é chamado de <a href="08-strings/12-glossario.html#fatia">fatia</a>. Selecionar uma fatia é como selecionar um caractere:</p>
<pre><code class="language-python">&gt;&gt;&gt; s = 'Monty Python'
&gt;&gt;&gt; s[0:5]
'Monty'
&gt;&gt;&gt; s[6:12]
'Python'
</code></pre>
<p>O operador <code>[n:m]</code> retorna a parte da string do “enésimo” caractere ao “emésimo” caractere, incluindo o primeiro, mas excluindo o último. Este comportamento é contraintuitivo, porém pode ajudar a imaginar os índices que indicam a parte entre os caracteres, como na Figura 8.1.</p>
<p><img src="08-strings//fig/tnkp_0801.png" alt="Figura 8.1 – Índices de fatias" />.
<br><em>Figura 8.1 – Índices de fatias.</em></p>
<p>Se você omitir o primeiro <a href="08-strings/12-glossario.html#%C3%ADndice">índice</a> (antes dos dois pontos), a fatia começa no início da string. Se omitir o segundo índice, a fatia vai ao fim da string:</p>
<pre><code class="language-python">&gt;&gt;&gt; fruit = 'banana'
&gt;&gt;&gt; fruit[:3]
'ban'
&gt;&gt;&gt; fruit[3:]
'ana'
</code></pre>
<p>Se o primeiro índice for maior ou igual ao segundo, o resultado é uma <a href="08-strings/12-glossario.html#string-vazia">string vazia</a>, representada por duas aspas:</p>
<pre><code class="language-python">&gt;&gt;&gt; fruit = 'banana'
&gt;&gt;&gt; fruit[3:3]
''
</code></pre>
<p>Uma string vazia não contém nenhum caractere e tem o comprimento 0, fora isso, é igual a qualquer outra string.</p>
<p>Continuando este exemplo, o que você acha que <code>fruit[:]</code> significa? Teste e veja.</p>
<h2><a class="header" href="#85---strings-são-imutáveis" id="85---strings-são-imutáveis">8.5 - Strings são imutáveis</a></h2>
<p>É tentador usar o operador <code>[]</code> no lado esquerdo de uma atribuição, com a intenção de alterar um caractere em uma string. Por exemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; greeting = 'Hello, world!'
&gt;&gt;&gt; greeting[0] = 'J'
TypeError: 'str' object does not support item assignment
</code></pre>
<p>O “<a href="08-strings/12-glossario.html#objeto">objeto</a>” neste caso é a string e o “item” é o caractere que você tentou atribuir. Por enquanto, um objeto é a mesma coisa que um valor, mas refinaremos esta definição mais adiante (<a href="08-strings/../10-listas/10-objetos-e-valores.html">Objetos e valores</a>, no capítulo 10).</p>
<p>A razão do erro é que as strings são imutáveis, o que significa que você não pode alterar uma string existente. O melhor que você pode fazer é criar uma string que seja uma variação da original:</p>
<pre><code class="language-python">&gt;&gt;&gt; greeting = 'Hello, world!'
&gt;&gt;&gt; new_greeting = 'J' + greeting[1:]
&gt;&gt;&gt; new_greeting
'Jello, world!'
</code></pre>
<p>Esse exemplo concatena uma nova primeira letra a uma <a href="08-strings/12-glossario.html#fatia">fatia</a> de <code>greeting</code>. Não tem efeito sobre a string original.</p>
<h2><a class="header" href="#86---buscando" id="86---buscando">8.6 - Buscando</a></h2>
<pre><code class="language-python">O que faz a seguinte função?
def find(word, letter):
    index = 0
    while index &lt; len(word):
        if word[index] == letter:
            return index
        index = index + 1
    return-1
</code></pre>
<p>De certo modo, <code>find</code> é o inverso do operador <code>[]</code>. Em vez de tomar um <a href="08-strings/12-glossario.html#%C3%ADndice">índice</a> e extrair o caractere correspondente, ele toma um caractere e encontra o índice onde aquele caractere aparece. Se o caractere não for encontrado, a função retorna -1.</p>
<p>Esse é o primeiro exemplo que vimos de uma instrução <code>return</code> dentro de um loop. Se <code>word[index] == letter</code>, a função sai do loop e retorna imediatamente.</p>
<p>Se o caractere não aparecer na string, o programa sai do loop normalmente e devolve -1.</p>
<p>Este modelo de cálculo – <a href="08-strings/12-glossario.html#atravessar">atravessar</a> uma <a href="08-strings/12-glossario.html#sequ%C3%AAncia">sequência</a> e retornar quando encontramos o que estamos procurando – chama-se <a href="08-strings/12-glossario.html#busca">busca</a>.</p>
<p>Como exercício, altere <code>find</code> para que tenha um terceiro parâmetro: o índice em <code>word</code> onde deve começar a busca.</p>
<h2><a class="header" href="#87---loop-e-contagem" id="87---loop-e-contagem">8.7 - Loop e contagem</a></h2>
<p>O seguinte programa conta o número de vezes que a letra a aparece em uma string:</p>
<pre><code class="language-python">word = 'banana'
count = 0
for letter in word:
    if letter == 'a':
        count = count + 1
print(count)
</code></pre>
<p>Este programa demonstra outro padrão de computação chamado <a href="08-strings/12-glossario.html#contador">contador</a>. A variável <code>count</code> é inicializada com 0 e então incrementada cada vez que um a é encontrado. Ao sair do loop, <code>count</code> contém o resultado – o número total de letras <code>'a'</code>.</p>
<p>Como exercício, encapsule este código em uma função denominada <code>count</code> e generalize-o para que aceite a string e a letra como argumentos.</p>
<p>Então reescreva a função para que, em vez de <a href="08-strings/12-glossario.html#atravessar">atravessar</a> a string, ela use a versão de três parâmetros do find da seção anterior.</p>
<h2><a class="header" href="#88---métodos-de-strings" id="88---métodos-de-strings">8.8 - Métodos de strings</a></h2>
<p>As strings oferecem métodos que executam várias operações úteis. Um método é semelhante a uma função – toma argumentos e devolve um valor –, mas a sintaxe é diferente. Por exemplo, o método upper recebe uma string e devolve uma nova string com todas as letras maiúsculas.</p>
<p>Em vez da sintaxe de função <code>upper(word)</code>, ela usa a sintaxe de método <code>word.upper()</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; word = 'banana'
&gt;&gt;&gt; new_word = word.upper()
&gt;&gt;&gt; new_word
'BANANA'
</code></pre>
<p>Esta forma de notação de ponto especifica o nome do método, <code>upper</code> e o nome da string, <code>word</code>, à qual o método será aplicado. Os parênteses vazios indicam que este método não toma nenhum argumento.</p>
<p>Uma chamada de método denomina-se <a href="08-strings/12-glossario.html#invoca%C3%A7%C3%A3o">invocação</a>; neste caso, diríamos que estamos invocando <code>upper</code> em <code>word</code>.</p>
<p>E, na verdade, há um método de string denominado <code>find</code>, que é notavelmente semelhante à função que escrevemos:</p>
<pre><code class="language-python">&gt;&gt;&gt; word = 'banana'
&gt;&gt;&gt; index = word.find('a')
&gt;&gt;&gt; index
1
</code></pre>
<p>Neste exemplo, invocamos <code>find</code> em <code>word</code> e passamos a letra que estamos procurando como um parâmetro.</p>
<p>Na verdade, o método <code>find</code> é mais geral que a nossa função; ele pode encontrar substrings, não apenas caracteres:</p>
<pre><code class="language-python">&gt;&gt;&gt; word.find('na')
2
</code></pre>
<p>Por padrão, <code>find</code> inicia no começo da string, mas pode receber um segundo argumento, o <a href="08-strings/12-glossario.html#%C3%ADndice">índice</a> onde deve começar:</p>
<pre><code class="language-python">&gt;&gt;&gt; word.find('na', 3)
4
</code></pre>
<p>Este é um exemplo de um <a href="08-strings/12-glossario.html#argumento-opcional">argumento opcional</a>. <code>find</code> também pode receber um terceiro argumento, o índice para onde deve parar:</p>
<pre><code class="language-python">&gt;&gt;&gt; name = 'bob'
&gt;&gt;&gt; name.find('b', 1, 2)
-1
</code></pre>
<p>Esta <a href="08-strings/12-glossario.html#busca">busca</a> falha porque <code>'b'</code> não aparece no intervalo do índice de 1 a 2, não incluindo 2. Fazer buscas até (mas não incluindo) o segundo índice torna <code>find</code> similar ao operador de fatiamento.</p>
<h2><a class="header" href="#89---operador-in" id="89---operador-in">8.9 - Operador in</a></h2>
<p>A palavra <code>in</code> é um operador booleano que recebe duas strings e retorna <code>True</code> se a primeira aparecer como uma substring da segunda:</p>
<pre><code class="language-python">&gt;&gt;&gt; 'a' in 'banana'
True
&gt;&gt;&gt; 'seed' in 'banana'
False
</code></pre>
<p>Por exemplo, a seguinte função imprime todas as letras de <code>word1</code> que também aparecem em <code>word2</code>:</p>
<pre><code class="language-python">def in_both(word1, word2):
    for letter in word1:
        if letter in word2:
            print(letter)
</code></pre>
<p>Com nomes de variáveis bem escolhidos, o Python às vezes pode ser lido como um texto em inglês. Você pode ler este loop, “para (cada) letra em (a primeira) palavra, se (a) letra (aparecer) em (a segunda) palavra, exiba (a) letra”.</p>
<p>Veja o que é apresentado ao se comparar maçãs e laranjas:</p>
<pre><code class="language-python">&gt;&gt;&gt; in_both('apples', 'oranges')
a
e
s
</code></pre>
<h2><a class="header" href="#810---comparação-de-strings" id="810---comparação-de-strings">8.10 - Comparação de strings</a></h2>
<p>Os operadores relacionais funcionam em strings. Para ver se duas strings são iguais:</p>
<pre><code class="language-python">if word == 'banana':
    print('All right, bananas.')
</code></pre>
<p>Outras operações relacionais são úteis para colocar palavras em ordem alfabética:</p>
<pre><code class="language-python">if word &lt; 'banana':
    print('Your word, ' + word + ', comes before banana.')
elif word &gt; 'banana':
    print('Your word, ' + word + ', comes after banana.')
else:
    print('All right, bananas.')
</code></pre>
<p>O Python não lida com letras maiúsculas e minúsculas do mesmo jeito que as pessoas. Todas as letras maiúsculas vêm antes de todas as letras minúsculas, portanto:</p>
<pre><code class="language-python">Your word, Pineapple, comes before banana.
</code></pre>
<p>Uma forma comum de lidar com este problema é converter strings em um formato padrão, como letras minúsculas, antes de executar a comparação. Lembre-se disso caso tenha que se defender de um homem armado com um abacaxi.</p>
<h2><a class="header" href="#811---depuração" id="811---depuração">8.11 - Depuração</a></h2>
<p>Ao usar índices para <a href="08-strings/12-glossario.html#atravessar">atravessar</a> os valores em uma <a href="08-strings/12-glossario.html#sequ%C3%AAncia">sequência</a>, é complicado acertar o começo e o fim da travessia. Aqui está uma função que supostamente compara duas palavras e retorna True se uma das palavras for o reverso da outra, mas contém dois erros:</p>
<pre><code class="language-python">def is_reverse(word1, word2):
    if len(word1) != len(word2):
        return False
    i = 0
    j = len(word2)
    while j &gt; 0:
        if word1[i] != word2[j]:
            return False
        i = i+1
        j = j-1
    return True
</code></pre>
<p>A primeira instrução if verifica se as palavras têm o mesmo comprimento. Se não for o caso, podemos retornar False imediatamente. Do contrário, para o resto da função, podemos supor que as palavras tenham o mesmo comprimento. Este é um exemplo do modelo de guardião em “Verificação de tipos”, na página 101.</p>
<p>i e j são índices: i atravessa word1 para a frente, enquanto j atravessa word2 para trás. Se encontrarmos duas letras que não combinam, podemos retornar False imediatamente. Se terminarmos o loop inteiro e todas as letras corresponderem, retornamos True.</p>
<p>Se testarmos esta função com as palavras “pots” e “stop”, esperamos o valor de retorno True, mas recebemos um IndexError:</p>
<pre><code class="language-python">&gt;&gt;&gt; is_reverse('pots', 'stop')
...
  File &quot;reverse.py&quot;, line 15, in is_reverse
    if word1[i] != word2[j]:
IndexError: string index out of range
</code></pre>
<p>Para depurar este tipo de erro, minha primeira ação é exibir os valores dos índices imediatamente antes da linha onde o erro aparece.</p>
<pre><code class="language-python">while j &gt; 0:
    print(i, j)        # exibir aqui
    if word1[i] != word2[j]:
        return False
    i = i+1
    j = j-1
</code></pre>
<p>Agora quando executo o programa novamente, recebo mais informação:</p>
<pre><code class="language-python">&gt;&gt;&gt; is_reverse('pots', 'stop')
0 4
...
IndexError: string index out of range
</code></pre>
<p>Na primeira vez que o programa passar pelo loop, o valor de j é 4, que está fora do intervalo da string 'pots'. O <a href="08-strings/12-glossario.html#%C3%ADndice">índice</a> do último caractere é 3, então o valor inicial de j deve ser len(word2)-1.</p>
<p>Se corrigir esse erro e executar o programa novamente, recebo:</p>
<pre><code class="language-python">&gt;&gt;&gt; is_reverse('pots', 'stop')
0 3
1 2
2 1
True
</code></pre>
<p>Desta vez, recebemos a resposta certa, mas parece que o loop só foi executado três vezes, o que é suspeito. Para ter uma ideia melhor do que está acontecendo, é útil desenhar um diagrama de estado. Durante a primeira iteração, o frame de <code>is_reverse</code> é mostrado na Figura 8.2.</p>
<p><img src="08-strings//fig/tnkp_0802.png" alt="Figura 8.2 – Diagrama de estado de is_reverse" />.
<br><em>8.2 – Diagrama de estado de is_reverse.</em></p>
<p>Tomei a liberdade de arrumar as variáveis no frame e acrescentei linhas pontilhadas para mostrar que os valores de i e j indicam caracteres em word1 e word2.</p>
<p>Começando com este diagrama, execute o programa em papel, alterando os valores de i e j durante cada iteração. Encontre e corrija o segundo erro desta função.</p>
<h2><a class="header" href="#812---glossário" id="812---glossário">8.12 - Glossário</a></h2>
<h5><a class="header" href="#objeto" id="objeto">objeto</a></h5>
<p>    Algo a que uma variável pode se referir. Por enquanto, você pode usar “objeto” e “valor” de forma intercambiável.</p>
<h5><a class="header" href="#sequência" id="sequência">sequência</a></h5>
<p>    Uma coleção ordenada de valores onde cada valor é identificado por um índice de número inteiro.</p>
<h5><a class="header" href="#item" id="item">item</a></h5>
<p>    Um dos valores em uma sequência.</p>
<h5><a class="header" href="#índice" id="índice">índice</a></h5>
<p>    Um valor inteiro usado para selecionar um item em uma sequência, como um caractere em uma string. No Python, os índices começam em 0.</p>
<h5><a class="header" href="#fatia" id="fatia">fatia</a></h5>
<p>    Parte de uma string especificada por um intervalo de índices.</p>
<h5><a class="header" href="#string-vazia" id="string-vazia">string vazia</a></h5>
<p>    Uma string sem caracteres e de comprimento 0, representada por duas aspas.</p>
<h5><a class="header" href="#imutável" id="imutável">imutável</a></h5>
<p>    A propriedade de uma sequência cujos itens não podem ser alterados.</p>
<h5><a class="header" href="#atravessar" id="atravessar">atravessar</a></h5>
<p>    Repetir os itens em uma sequência, executando uma operação semelhante em cada um.</p>
<h5><a class="header" href="#busca" id="busca">busca</a></h5>
<p>    Um modelo de travessia que é interrompido quando encontra o que está procurando.</p>
<h5><a class="header" href="#contador" id="contador">contador</a></h5>
<p>    Uma variável usada para contar algo, normalmente inicializada com zero e então incrementada.</p>
<h5><a class="header" href="#invocação" id="invocação">invocação</a></h5>
<p>    Uma instrução que chama um método.</p>
<h5><a class="header" href="#argumento-opcional" id="argumento-opcional">argumento opcional</a></h5>
<p>    Um argumento de função ou método que não é necessário.</p>
<h2><a class="header" href="#813---exercícios" id="813---exercícios">8.13 - Exercícios</a></h2>
<h3><a class="header" href="#exercício-81" id="exercício-81">Exercício 8.1</a></h3>
<p>Leia a documentação dos métodos de strings em <a href="http://docs.python.org/3/library/stdtypes.html#string-methods">http://docs.python.org/3/library/stdtypes.html#string-methods</a>. Pode ser uma boa ideia experimentar alguns deles para entender como funcionam. <code>strip</code> e <code>replace</code> são especialmente úteis.</p>
<p>A documentação usa uma sintaxe que pode ser confusa. Por exemplo, em <code>find(sub[, start[, end]])</code>, os colchetes indicam argumentos opcionais. Então <code>sub</code> é exigido, mas <code>start</code> é opcional, e se você incluir <code>start</code>, então <code>end</code> é opcional.</p>
<h3><a class="header" href="#exercício-82" id="exercício-82">Exercício 8.2</a></h3>
<p>Há um método de string chamado <code>count</code>, que é semelhante à função em “Loop e contagem”, na página 123. Leia a documentação deste método e escreva uma <a href="08-strings/12-glossario.html#invoca%C3%A7%C3%A3o">invocação</a> que conte o número de letras <code>'a'</code> em 'banana'.</p>
<h3><a class="header" href="#exercício-83" id="exercício-83">Exercício 8.3</a></h3>
<p>Uma <a href="08-strings/12-glossario.html#fatia">fatia</a> de string pode receber um terceiro <a href="08-strings/12-glossario.html#%C3%ADndice">índice</a> que especifique o “tamanho do passo”; isto é, o número de espaços entre caracteres sucessivos. Um tamanho de passo 2 significa tomar um caractere e outro não; 3 significa tomar um e dois não etc.</p>
<pre><code class="language-python">&gt;&gt;&gt; fruit = 'banana'
&gt;&gt;&gt; fruit[0:5:2]
'bnn'
</code></pre>
<p>Um tamanho de passo -1 atravessa a palavra de trás para a frente, então a fatia <code>[::-1]</code> gera uma string invertida.</p>
<p>Use isso para escrever uma versão de uma linha de <code>is_palindrome</code> do Exercício 6.3.</p>
<h3><a class="header" href="#exercício-84" id="exercício-84">Exercício 8.4</a></h3>
<p>As seguintes funções pretendem verificar se uma string contém alguma letra minúscula, mas algumas delas estão erradas. Para cada função, descreva o que ela faz (assumindo que o parâmetro seja uma string).</p>
<pre><code class="language-python">def any_lowercase1(s):
    for c in s:
        if c.islower():
            return True
        else:
            return False

def any_lowercase2(s):
    for c in s:
        if 'c'.islower():
            return 'True'
        else:
            return 'False'

def any_lowercase3(s):
    for c in s:
        flag = c.islower()
    return flag

def any_lowercase4(s):
    flag = False
    for c in s:
        flag = flag or c.islower()
    return flag

def any_lowercase5(s):
    for c in s:
        if not c.islower():
            return False
    return True
</code></pre>
<h3><a class="header" href="#exercício-85" id="exercício-85">Exercício 8.5</a></h3>
<p>Uma cifra de César é uma forma fraca de criptografia que implica “rotacionar” cada letra por um número fixo de lugares. Rotacionar uma letra significa deslocá-lo pelo alfabeto, voltando ao início se for necessário, portanto ‘A’ rotacionado por 3 é ‘D’ e ‘Z’ rotacionado por 1 é ‘A’.</p>
<p>Para rotacionar uma palavra, faça cada letra se mover pela mesma quantidade de posições. Por exemplo, “cheer” rotacionado por 7 é “jolly” e “melon” rotacionado por -10 é “cubed”. No filme 2001: Uma odisseia no espaço, o computador da nave chama-se HAL, que é IBM rotacionado por -1.</p>
<p>Escreva uma função chamada <code>rotate_word</code> que receba uma string e um número inteiro como parâmetros, e retorne uma nova string que contém as letras da string original rotacionadas pelo número dado.</p>
<p>Você pode usar a função integrada ord, que converte um caractere em um código numérico e chr, que converte códigos numéricos em caracteres. As letras do alfabeto são codificadas em ordem alfabética, então, por exemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; ord('c') - ord('a')
2
</code></pre>
<p>Porque <code>'c'</code> é a “segunda” letra do alfabeto. Mas tenha cuidado: os códigos numéricos de letras maiúsculas são diferentes.</p>
<p>Piadas potencialmente ofensivas na internet às vezes são codificadas em ROT13, que é uma cifra de César com rotação 13. Se não se ofender facilmente, encontre e decifre algumas delas.</p>
<h1><a class="header" href="#capítulo-9-estudo-de-caso-jogos-de-palavras" id="capítulo-9-estudo-de-caso-jogos-de-palavras">Capítulo 9: Estudo de caso: jogos de palavras</a></h1>
<p>Este capítulo apresenta o segundo estudo de caso que envolve solucionar quebra-cabeças usando palavras com certas propriedades. Por exemplo, encontraremos os palíndromos mais longos em inglês e procuraremos palavras cujas letras apareçam em ordem alfabética. E apresentarei outro plano de desenvolvimento de programa: a <a href="09-estudo-de-caso-jogos-de-palavras/06-glossario.html#redu%C3%A7%C3%A3o-a-um-problema-resolvido-anteriormente">redução a um problema resolvido anteriormente</a>.</p>
<h2><a class="header" href="#91---leitura-de-listas-de-palavras" id="91---leitura-de-listas-de-palavras">9.1 - Leitura de listas de palavras</a></h2>
<p>Para os exercícios deste capítulo vamos usar uma lista de palavras em inglês. Há muitas listas de palavras disponíveis na internet, mas a mais conveniente ao nosso propósito é uma das listas de palavras disponibilizadas em domínio público por Grady Ward como parte do projeto lexical Moby (ver <a href="http://wikipedia.org/wiki/Moby_Project">http://wikipedia.org/wiki/Moby_Project</a>). É uma lista de 113.809 palavras cruzadas oficiais; isto é, as palavras que se consideram válidas em quebra-cabeças de palavras cruzadas e outros jogos de palavras. Na coleção Moby, o nome do arquivo é 113809of.fic; você pode baixar uma cópia, com um nome mais simples como words.txt, de <a href="http://thinkpython2.com/code/words.txt">http://thinkpython2.com/code/words.txt</a>.</p>
<p>Este arquivo está em texto simples, então você pode abri-lo com um editor de texto, mas também pode lê-lo no Python. A função integrada open recebe o nome do arquivo como um parâmetro e retorna um <a href="09-estudo-de-caso-jogos-de-palavras/06-glossario.html#objeto-de-arquivo">objeto de arquivo</a> que você pode usar para ler o arquivo.</p>
<pre><code class="language-python">&gt;&gt;&gt; fin = open('words.txt')
</code></pre>
<p><code>fin</code> é um nome comum de objeto de arquivo usado para entrada de dados. O objeto de arquivo oferece vários métodos de leitura, inclusive readline, que lê caracteres no arquivo até chegar a um comando de nova linha, devolvendo o resultado como uma string:</p>
<pre><code class="language-python">&gt;&gt;&gt; fin.readline()
'aa\r\n'
</code></pre>
<p>A primeira palavra nesta lista específica é “aa”, uma espécie de lava. A sequência <code>'\r\n'</code> representa dois caracteres que representam espaços em branco (whitespace), um retorno de carro e uma nova linha, que separa esta palavra da seguinte.</p>
<p>O objeto de arquivo grava a posição em que está no arquivo, então se você chamar readline mais uma vez, receberá a seguinte palavra:</p>
<pre><code class="language-python">&gt;&gt;&gt; fin.readline()
'aah\r\n'
</code></pre>
<p>A palavra seguinte é “aah”, uma palavra perfeitamente legítima, então pare de olhar para mim desse jeito. Ou, se é o whitespace que está incomodando você, podemos nos livrar dele com o método de string <code>strip</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; line = fin.readline()
&gt;&gt;&gt; word = line.strip()
&gt;&gt;&gt; word
'aahed'
</code></pre>
<p>Você também pode usar um objeto de arquivo como parte de um loop <code>for</code>. Este programa lê words.txt e imprime cada palavra, uma por linha:</p>
<pre><code class="language-python">fin = open('words.txt')
for line in fin:
    word = line.strip()
    print(word)
</code></pre>
<h2><a class="header" href="#92---exercícios" id="92---exercícios">9.2 - Exercícios</a></h2>
<p>Há soluções para estes exercícios na próxima seção. Mas é bom você tentar fazer cada um antes de ver as soluções.</p>
<h3><a class="header" href="#exercício-91" id="exercício-91">Exercício 9.1</a></h3>
<p>Escreva um programa que leia words.txt e imprima apenas as palavras com mais de 20 caracteres (sem contar whitespace).</p>
<h3><a class="header" href="#exercício-92" id="exercício-92">Exercício 9.2</a></h3>
<p>Em 1939, Ernest Vincent Wright publicou uma novela de 50.000 palavras, chamada Gadsby, que não contém a letra “e”. Como o “e” é a letra mais comum em inglês, isso não é algo fácil de fazer.</p>
<p>Na verdade, é difícil até construir um único pensamento sem usar o símbolo mais comum do idioma. No início é lento, mas com prudência e horas de treino, vai ficando cada vez mais fácil.</p>
<pre><code class="language-python">Muito bem, agora eu vou parar.
</code></pre>
<p>Escreva uma função chamada <code>has_no_e</code> que retorne <code>True</code> se a palavra dada não tiver a letra “e” nela.</p>
<p>Altere seu programa na seção anterior para imprimir apenas as palavras que não têm “e” e calcule a porcentagem de palavras na lista que não têm “e”.</p>
<h3><a class="header" href="#exercício-93" id="exercício-93">Exercício 9.3</a></h3>
<p>Escreva uma função chamada avoids que receba uma palavra e uma série de letras proibidas, e retorne True se a palavra não usar nenhuma das letras proibidas.</p>
<p>Altere o código para que o usuário digite uma série de letras proibidas e o programa imprima o número de palavras que não contêm nenhuma delas. Você pode encontrar uma combinação de cinco letras proibidas que exclua o menor número possível de palavras?</p>
<h3><a class="header" href="#exercício-94" id="exercício-94">Exercício 9.4</a></h3>
<p>Escreva uma função chamada <code>uses_only</code> que receba uma palavra e uma série de letras e retorne <code>True</code>, se a palavra só contiver letras da lista. Você pode fazer uma frase usando só as letras acefhlo? Que não seja “Hoe alfalfa?”</p>
<h3><a class="header" href="#exercício-95" id="exercício-95">Exercício 9.5</a></h3>
<p>Escreva uma função chamada <code>uses_all</code> que receba uma palavra e uma série de letras obrigatórias e retorne <code>True</code> se a palavra usar todas as letras obrigatórias pelo menos uma vez. Quantas palavras usam todas as vogais (aeiou)? E que tal aeiouy?</p>
<h3><a class="header" href="#exercício-96" id="exercício-96">Exercício 9.6</a></h3>
<p>Escreva uma função chamada <code>is_abecedarian</code> que retorne <code>True</code> se as letras numa palavra aparecerem em ordem alfabética (tudo bem se houver letras duplas). Quantas palavras em ordem alfabética existem?</p>
<h2><a class="header" href="#93---busca" id="93---busca">9.3 - Busca</a></h2>
<p>Todos os exercícios na seção anterior têm algo em comum; eles podem ser resolvidos com o modelo de busca que vimos em <a href="09-estudo-de-caso-jogos-de-palavras/../08-strings/06-buscando.html">Buscando</a>. O exemplo mais simples é:</p>
<pre><code class="language-python">def has_no_e(word):
    for letter in word:
        if letter == 'e':
            return False
    return True
</code></pre>
<p>O loop for atravessa os caracteres em word. Se encontrarmos a letra “e”, podemos retornar False imediatamente; se não for o caso, temos que ir à letra seguinte. Se sairmos do loop normalmente, isso quer dizer que não encontramos um “e”, então retornamos True.</p>
<p>Você pode escrever esta função de forma mais concisa usando o operador in, mas comecei com esta versão porque ela demonstra a lógica do modelo de busca.</p>
<p><code>avoids</code> é uma versão mais geral de <code>has_no_e</code>, mas tem a mesma estrutura:</p>
<pre><code class="language-python">def avoids(word, forbidden):
    for letter in word:
        if letter in forbidden:
            return False
    return True
</code></pre>
<p>Podemos retornar <code>False</code> logo que encontrarmos uma letra proibida; se chegarmos ao fim do loop, retornamos <code>True</code>.</p>
<p><code>uses_only</code> é semelhante, exceto pelo sentido da condição, que se inverte:</p>
<pre><code class="language-python">def uses_only(word, available):
    for letter in word:
        if letter not in available:
            return False
    return True
</code></pre>
<p>Em vez de uma lista de letras proibidas, temos uma lista de letras disponíveis. Se encontrarmos uma letra em word que não está em <code>available</code>, podemos retornar <code>False</code>.</p>
<p><code>uses_all</code> é semelhante, mas invertemos a função da palavra e a string de letras:</p>
<pre><code class="language-python">def uses_all(word, required):
    for letter in required:
        if letter not in word:
            return False
    return True
</code></pre>
<p>Em vez de atravessar as letras em <code>word</code>, o loop atravessa as letras obrigatórias. Se alguma das letras obrigatórias não aparecer na palavra, podemos retornar <code>False</code>.</p>
<p>Se você realmente estivesse pensando como um cientista da computação, teria reconhecido que <code>uses_all</code> foi um exemplo de um problema resolvido anteriormente e escreveria:</p>
<pre><code class="language-python">def uses_all(word, required):
    return uses_only(required, word)
</code></pre>
<p>Esse é um exemplo de um plano de desenvolvimento de programa chamado <strong>redução a um problema resolvido anteriormente</strong>, ou seja, você reconhece o problema no qual está trabalhando como um exemplo de um problema já resolvido e aplica uma solução existente.</p>
<h2><a class="header" href="#94---loop-com-índices" id="94---loop-com-índices">9.4 - Loop com índices</a></h2>
<p>Escrevi as funções na seção anterior com loops <code>for</code> porque eu só precisava dos caracteres nas strings; não precisava fazer nada com os índices.</p>
<p>Para <code>is_abecedarian</code> temos que comparar letras adjacentes, o que é um pouco complicado para o loop for:</p>
<pre><code class="language-python">def is_abecedarian(word):
    previous = word[0]
    for c in word:
        if c &lt; previous:
            return False
        previous = c
    return True
</code></pre>
<p>Uma alternativa é usar a recursividade:</p>
<pre><code class="language-python">def is_abecedarian(word):
    if len(word) &lt;= 1:
        return True
    if word[0] &gt; word[1]:
        return False
    return is_abecedarian(word[1:])
</code></pre>
<p>Outra opção é usar um loop <code>while</code>:</p>
<pre><code class="language-python">def is_abecedarian(word):
    i = 0
    while i &lt; len(word)-1:
        if word[i+1] &lt; word[i]:
            return False
        i = i+1
    return True
</code></pre>
<p>O loop começa com <code>i == 0</code> e termina quando <code>i == len(word)-1</code>. Cada vez que passa pelo loop, o programa compara o “i-ésimo” caractere (que você pode considerar o caractere atual) com o caractere de posição <code>i+1</code> (que pode ser considerado o caractere seguinte).</p>
<p>Se o próximo caractere for de uma posição anterior (alfabeticamente anterior) à atual, então descobrimos uma quebra na tendência alfabética, e retornamos <code>False</code>.</p>
<p>Se chegarmos ao fim do loop sem encontrar uma quebra, então a palavra passa no teste. Para convencer-se de que o loop termina corretamente, considere um exemplo como <code>'flossy'</code>. O comprimento da palavra é 6, então o loop é executado pela última vez quando i for igual a 4, que é o índice do segundo caractere de trás para frente. Na última iteração, o programa compara o penúltimo caractere com o último, que é o que queremos.</p>
<p>Aqui está uma versão de <code>is_palindrome</code> (veja o Exercício 6.3) que usa dois índices: um começa no início e aumenta; o outro começa no final e diminui.</p>
<pre><code class="language-python">def is_palindrome(word):
    i = 0
    j = len(word)-1
    while i&lt;j:
        if word[i] != word[j]:
            return False
        i = i+1
        j = j-1
    return True
</code></pre>
<p>Ou podemos reduzir a um problema resolvido anteriormente e escrever:</p>
<pre><code class="language-python">def is_palindrome(word):
    return is_reverse(word, word)
</code></pre>
<p>Usando <code>is_reverse</code> da seção 8.11.</p>
<h2><a class="header" href="#95---depuração" id="95---depuração">9.5 - Depuração</a></h2>
<p>Testar programas é difícil. As funções neste capítulo são relativamente fáceis para testar porque é possível verificar os resultados à mão. Ainda assim, pode ser difícil ou até impossível escolher um grupo de palavras que teste todos os erros possíveis.</p>
<p>Tomando <code>has_no_e</code> como exemplo, há dois casos óbvios para verificar: as palavras que têm um ‘e’ devem retornar False, e as palavras que não têm devem retornar True. Não deverá ser um problema pensar em um exemplo de cada uma.</p>
<p>Dentro de cada caso, há alguns subcasos menos óbvios. Entre as palavras que têm um “e”, você deve testar palavras com um “e” no começo, no fim e em algum lugar no meio. Você deve testar palavras longas, palavras curtas e palavras muito curtas, como a string vazia. A string vazia é um exemplo de um <a href="09-estudo-de-caso-jogos-de-palavras/06-glossario.html#caso-especial">caso especial</a>, não óbvio, onde erros muitas vezes espreitam.</p>
<p>Além dos casos de teste que você gerar, também pode ser uma boa ideia testar seu programa com uma lista de palavras como words.txt. Ao analisar a saída, pode ser que os erros apareçam, mas tenha cuidado: você pode pegar um tipo de erro (palavras que não deveriam ser incluídas, mas foram) e não outro (palavras que deveriam ser incluídas, mas não foram).</p>
<p>Em geral, o teste pode ajudar a encontrar bugs, mas não é fácil gerar um bom conjunto de casos de teste, e, mesmo se conseguir, não há como ter certeza de que o programa está correto. Segundo um lendário cientista da computação:</p>
<p>Testar programas pode ser usado para mostrar a presença de bugs, mas nunca para mostrar a ausência deles! – Edsger W. Dijkstra</p>
<h2><a class="header" href="#96---glossário" id="96---glossário">9.6 - Glossário</a></h2>
<h5><a class="header" href="#objeto-de-arquivo" id="objeto-de-arquivo">objeto de arquivo</a></h5>
<p>    Um valor que representa um arquivo aberto.</p>
<h5><a class="header" href="#redução-a-um-problema-resolvido-anteriormente" id="redução-a-um-problema-resolvido-anteriormente">redução a um problema resolvido anteriormente</a></h5>
<p>    Um modo de resolver um problema expressando-o como uma instância de um problema resolvido anteriormente.</p>
<h5><a class="header" href="#caso-especial" id="caso-especial">caso especial</a></h5>
<p>    Um caso de teste que é atípico ou não é óbvio (e com probabilidade menor de ser tratado corretamente).</p>
<h2><a class="header" href="#97---exercícios" id="97---exercícios">9.7 - Exercícios</a></h2>
<h3><a class="header" href="#exercício-97" id="exercício-97">Exercício 9.7</a></h3>
<p>Esta pergunta é baseada em um quebra-cabeça veiculado em um programa de rádio chamado Car Talk (<a href="http://www.cartalk.com/content/puzzlers">http://www.cartalk.com/content/puzzlers</a>):</p>
<p>Dê uma palavra com três letras duplas consecutivas. Vou dar exemplos de palavras que quase cumprem a condição, mas não chegam lá. Por exemplo, a palavra committee, c-o-m-m-i-t-t-e-e. Seria perfeita se não fosse aquele ‘i’ que se meteu ali no meio. Ou Mississippi: M-i-s-s-i-s-s-i-p-p-i. Se pudesse tirar aqueles ‘is’, daria certo. Mas há uma palavra que tem três pares consecutivos de letras e, que eu saiba, pode ser a única palavra que existe. É claro que provavelmente haja mais umas 500, mas só consigo pensar nessa. Qual é a palavra?</p>
<p>Escreva um programa que a encontre.</p>
<p>Solução: <a href="http://thinkpython2.com/code/cartalk1.py">http://thinkpython2.com/code/cartalk1.py</a>.</p>
<h3><a class="header" href="#exercício-98" id="exercício-98">Exercício 9.8</a></h3>
<p>Aqui está outro quebra-cabeça do programa Car Talk (<a href="http://www.cartalk.com/content/puzzlers">http://www.cartalk.com/content/puzzlers</a>):</p>
<p>“Estava dirigindo outro dia e percebi algo no hodômetro que chamou a minha atenção. Como a maior parte dos hodômetros, ele mostra seis dígitos, apenas em milhas inteiras. Por exemplo, se o meu carro tivesse 300.000 milhas, eu veria 3-0-0-0-0-0.</p>
<p>“Agora, o que vi naquele dia foi muito interessante. Notei que os últimos 4 dígitos eram um palíndromo; isto é, podiam ser lidos da mesma forma no sentido correto e no sentido inverso. Por exemplo, 5-4-4-5 é um palíndromo, então no meu hodômetro poderia ser 3-1-5-4-4-5.</p>
<p>“Uma milha depois, os últimos 5 números formaram um palíndromo. Por exemplo, poderia ser 3-6-5-4-5-6. Uma milha depois disso, os 4 números do meio, dentro dos 6, formavam um palíndromo. E adivinhe só? Um milha depois, todos os 6 formavam um palíndromo!</p>
<p>“A pergunta é: o que estava no hodômetro quando olhei primeiro?”</p>
<p>Escreva um programa Python que teste todos os números de seis dígitos e imprima qualquer número que satisfaça essas condições.</p>
<p>Solução: <a href="http://thinkpython2.com/code/cartalk2.py">http://thinkpython2.com/code/cartalk2.py</a>.</p>
<h3><a class="header" href="#exercício-99" id="exercício-99">Exercício 9.9</a></h3>
<p>Aqui está outro problema do Car Talk que você pode resolver com uma busca (<a href="http://www.cartalk.com/content/puzzlers">http://www.cartalk.com/content/puzzlers</a>):</p>
<p>“Há pouco tempo recebi uma visita da minha mãe e percebemos que os dois dígitos que compõem a minha idade, quando invertidos, representavam a idade dela. Por exemplo, se ela tem 73 anos, eu tenho 37 anos. Ficamos imaginando com que frequência isto aconteceu nos anos anteriores, mas acabamos mudando de assunto e não chegamos a uma resposta.</p>
<p>“Quando cheguei em casa, cheguei à conclusão de que os dígitos das nossas idades tinham sido reversíveis seis vezes até então. Também percebi que, se tivéssemos sorte, isso aconteceria novamente dali a alguns anos, e se fôssemos muito sortudos, aconteceria mais uma vez depois disso. Em outras palavras, aconteceria 8 vezes no total. Então a pergunta é: quantos anos tenho agora?”</p>
<p>Escreva um programa em Python que busque soluções para esse problema. Dica: pode ser uma boa ideia usar o método de string zfill.</p>
<h1><a class="header" href="#capítulo-10-listas" id="capítulo-10-listas">Capítulo 10: Listas</a></h1>
<p>Este capítulo apresenta um dos tipos integrados mais úteis do Python: listas. Você também aprenderá mais sobre objetos e o que pode acontecer quando o mesmo <a href="10-listas/14-glossario.html#objeto">objeto</a> tem mais de um nome.</p>
<h2><a class="header" href="#101---uma-a-href10-listas14-glossariohtmllistalistaa-é-uma-sequência" id="101---uma-a-href10-listas14-glossariohtmllistalistaa-é-uma-sequência">10.1 - Uma <a href="10-listas/14-glossario.html#lista">lista</a> é uma sequência</a></h2>
<p>Como uma string, uma lista é uma sequência de valores. Em uma string, os valores são caracteres; em uma lista, eles podem ser de qualquer tipo. Os valores em uma lista são chamados de elementos, ou, algumas vezes, de itens.</p>
<p>Há várias formas para criar uma lista; a mais simples é colocar os elementos entre colchetes (<code>[</code> e <code>]</code>):</p>
<pre><code class="language-python">[10, 20, 30, 40]
['crunchy frog', 'ram bladder', 'lark vomit']
</code></pre>
<p>O primeiro exemplo é uma lista de quatro números inteiros. O segundo é uma lista de três strings. Os elementos de uma lista não precisam ser do mesmo tipo. A lista seguinte contém uma string, um número de ponto flutuante, um número inteiro e (olhe só!) outra lista:</p>
<pre><code class="language-python">['spam', 2.0, 5, [10, 20]]
</code></pre>
<p>Uma lista dentro de outra lista é uma <a href="10-listas/14-glossario.html#lista-aninhada">lista aninhada</a>.</p>
<p>Uma lista que não contém elementos é chamada de lista vazia; você pode criar uma com colchetes vazios [].</p>
<p>Como já se poderia esperar, podemos atribuir uma lista de valores a variáveis:</p>
<pre><code class="language-python">&gt;&gt;&gt; cheeses = ['Cheddar', 'Edam', 'Gouda']
&gt;&gt;&gt; numbers = [42, 123]
&gt;&gt;&gt; empty = []
&gt;&gt;&gt; print(cheeses, numbers, empty)
['Cheddar', 'Edam', 'Gouda'] [42, 123] []
</code></pre>
<h2><a class="header" href="#102---listas-são-mutáveis" id="102---listas-são-mutáveis">10.2 - Listas são mutáveis</a></h2>
<p>A sintaxe para acessar os elementos de uma <a href="10-listas/14-glossario.html#lista">lista</a> é a mesma que para acessar os caracteres de uma string: o operador de colchete. A expressão dentro dos colchetes especifica o índice. Lembre-se de que os índices começam em 0:</p>
<pre><code class="language-python">&gt;&gt;&gt; cheeses[0]
'Cheddar'
</code></pre>
<p>Diferente das strings, listas são mutáveis. Quando o operador de colchete aparece do lado esquerdo de uma atribuição, ele identifica o <a href="10-listas/14-glossario.html#elemento">elemento</a> da lista que será atribuído:</p>
<pre><code class="language-python">&gt;&gt;&gt; numbers = [42, 123]
&gt;&gt;&gt; numbers[1] = 5
&gt;&gt;&gt; numbers
[42, 5]
</code></pre>
<p>O primeiro elemento de numbers, que costumava ser 123, agora é 5.</p>
<p>A Figura 10.1 mostra o diagrama de estado para cheeses, numbers e empty.</p>
<p><img src="10-listas//fig/tnkp_1001.png" alt="Figura 10.1 – Diagrama de estado de três listas" />.
<br><em>Figura 10.1 – Diagrama de estado de três listas.</em></p>
<p>As listas são representadas pelas caixas com a palavra “lista” fora delas e os elementos da lista dentro delas. cheeses refere-se a uma lista com três elementos indexados como 0, 1 e 2. numbers contém dois elementos e o diagrama mostra que o valor do segundo elemento foi reatribuído de 123 para 5. empty refere-se a uma lista sem elementos.</p>
<p>Índices de listas funcionam da mesma forma que os índices de strings:</p>
<ul>
<li>
<p>Qualquer expressão de números inteiros pode ser usada como índice.</p>
</li>
<li>
<p>Se tentar ler ou escrever um elemento que não existe, você recebe um IndexError.</p>
</li>
<li>
<p>Se um índice tiver um valor negativo, ele conta de trás para a frente, a partir do final da lista.</p>
</li>
</ul>
<p>O operador in também funciona com listas:</p>
<pre><code class="language-python">&gt;&gt;&gt; cheeses = ['Cheddar', 'Edam', 'Gouda']
&gt;&gt;&gt; 'Edam' in cheeses
True
&gt;&gt;&gt; 'Brie' in cheeses
False
</code></pre>
<h2><a class="header" href="#103---percorrendo-uma-a-href10-listas14-glossariohtmllistalistaa" id="103---percorrendo-uma-a-href10-listas14-glossariohtmllistalistaa">10.3 - Percorrendo uma <a href="10-listas/14-glossario.html#lista">lista</a></a></h2>
<p>A forma mais comum de percorrer os elementos em uma lista é com um loop for. A sintaxe é a mesma que a das strings:</p>
<pre><code class="language-python">for cheese in cheeses:
    print(cheese)
</code></pre>
<p>Isso funciona bem se você precisa apenas ler os elementos da lista. Mas se você quer escrever ou atualizar os elementos, você precisa dos índices. Uma forma comum de fazer isso é combinar as funções integradas range e len:</p>
<pre><code class="language-python">for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2
</code></pre>
<p>Este loop percorre a lista e atualiza cada <a href="10-listas/14-glossario.html#elemento">elemento</a>. len retorna o número de elementos na lista. range retorna uma lista de índices de 0 a n-1, em que n é o comprimento da lista. Cada vez que passa pelo loop, i recebe o índice do próximo elemento. A instrução de atribuição no corpo usa i para ler o valor antigo do elemento e atribuir o novo valor.</p>
<p>Um loop for que passe por uma lista vazia nunca executa o corpo:</p>
<pre><code class="language-python">for x in []:
    print('This never happens.')
</code></pre>
<p>Apesar de uma lista poder conter outra lista, a <a href="10-listas/14-glossario.html#lista-aninhada">lista aninhada</a> ainda conta como um único elemento. O comprimento desta lista é quatro:</p>
<pre><code class="language-python">['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
</code></pre>
<h2><a class="header" href="#104---operações-com-listas" id="104---operações-com-listas">10.4 - Operações com listas</a></h2>
<p>O operador <code>+</code> concatena listas:</p>
<pre><code class="language-python">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [4, 5, 6]
&gt;&gt;&gt; c = a + b
&gt;&gt;&gt; c
[1, 2, 3, 4, 5, 6]
</code></pre>
<p>O operador <code>*</code> repete a <a href="10-listas/14-glossario.html#lista">lista</a> um dado número de vezes:</p>
<pre><code class="language-python">&gt;&gt;&gt; [0] * 4
[0, 0, 0, 0]
&gt;&gt;&gt; [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
</code></pre>
<p>O primeiro exemplo repete <code>[0]</code> quatro vezes. O segundo exemplo repete a lista <code>[1, 2, 3]</code> três vezes.</p>
<h2><a class="header" href="#105---fatias-de-listas" id="105---fatias-de-listas">10.5 - Fatias de listas</a></h2>
<p>O operador de fatiamento também funciona com listas:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; t[1:3]
['b', 'c']
&gt;&gt;&gt; t[:4]
['a', 'b', 'c', 'd']
&gt;&gt;&gt; t[3:]
['d', 'e', 'f']
</code></pre>
<p>Se você omitir o primeiro índice, a fatia começa no início. Se você omitir o segundo, a fatia vai até o final. Se você omitir ambos, a fatia é uma cópia da <a href="10-listas/14-glossario.html#lista">lista</a> inteira.</p>
<pre><code class="language-python">&gt;&gt;&gt; t[:]
['a', 'b', 'c', 'd', 'e', 'f']
</code></pre>
<p>Como as listas são mutáveis, pode ser útil fazer uma cópia antes de executar operações que as alterem.</p>
<p>Um operador de fatia à esquerda de uma atribuição pode atualizar vários elementos:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; t[1:3] = ['x', 'y']
&gt;&gt;&gt; t
['a', 'x', 'y', 'd', 'e', 'f']
</code></pre>
<h2><a class="header" href="#106---métodos-de-listas" id="106---métodos-de-listas">10.6 - Métodos de listas</a></h2>
<p>O Python oferece métodos que operam em listas. Por exemplo, <code>append</code> adiciona um novo <a href="10-listas/14-glossario.html#elemento">elemento</a> ao fim de uma <a href="10-listas/14-glossario.html#lista">lista</a>:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; t.append('d')
&gt;&gt;&gt; t
['a', 'b', 'c', 'd']
</code></pre>
<p><code>extend</code> toma uma lista como argumento e adiciona todos os elementos:</p>
<pre><code class="language-python">&gt;&gt;&gt; t1 = ['a', 'b', 'c']
&gt;&gt;&gt; t2 = ['d', 'e']
&gt;&gt;&gt; t1.extend(t2)
&gt;&gt;&gt; t1
['a', 'b', 'c', 'd', 'e']
</code></pre>
<p>Este exemplo deixa t2 intocado.</p>
<p><code>sort</code> classifica os elementos da lista em ordem ascendente:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = ['d', 'c', 'e', 'b', 'a']
&gt;&gt;&gt; t.sort()
&gt;&gt;&gt; t
['a', 'b', 'c', 'd', 'e']
</code></pre>
<p>A maior parte dos métodos de listas são nulos; eles alteram a lista e retornam None. Se você escrever t = t.sort() por acidente, ficará desapontado com o resultado.</p>
<h2><a class="header" href="#107---mapeamento-a-href10-listas14-glossariohtmlfiltragemfiltragema-e-a-href10-listas14-glossariohtmlreduc3a7c3a3oreduçãoa" id="107---mapeamento-a-href10-listas14-glossariohtmlfiltragemfiltragema-e-a-href10-listas14-glossariohtmlreduc3a7c3a3oreduçãoa">10.7 - Mapeamento, <a href="10-listas/14-glossario.html#filtragem">filtragem</a> e <a href="10-listas/14-glossario.html#redu%C3%A7%C3%A3o">redução</a></a></h2>
<p>Para somar o total de todos os números em uma <a href="10-listas/14-glossario.html#lista">lista</a>, você pode usar um loop como esse:</p>
<pre><code class="language-python">def add_all(t):
    total = 0
    for x in t:
        total += x
    return total
</code></pre>
<p><code>total</code> é inicializado com 0. Cada vez que o programa passa pelo loop, <code>x</code> recebe um <a href="10-listas/14-glossario.html#elemento">elemento</a> da lista. O operador <code>+=</code> oferece uma forma curta de atualizar uma variável. Esta instrução de <a href="10-listas/14-glossario.html#atribui%C3%A7%C3%A3o-aumentada">atribuição aumentada</a>,</p>
<pre><code class="language-python">total += x
</code></pre>
<p>é <a href="10-listas/14-glossario.html#equivalente">equivalente</a> a</p>
<pre><code class="language-python">total = total + x
</code></pre>
<p>No decorrer da execução do loop, <code>total</code> acumula a soma dos elementos; uma variável usada desta forma às vezes é chamada de <a href="10-listas/14-glossario.html#acumuladora">acumuladora</a>.</p>
<p>Somar todos elementos de uma lista é uma operação tão comum que o Python a oferece como uma função integrada, <code>sum</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; sum(t)
6
</code></pre>
<p>Uma operação como essa, que combina uma sequência de elementos em um único valor, às vezes é chamada de redução.</p>
<p>Algumas vezes você quer percorrer uma lista enquanto cria outra. Por exemplo, a função seguinte recebe uma lista de strings e retorna uma nova lista que contém strings com letras maiúsculas:</p>
<pre><code class="language-python">def capitalize_all(t):
    res = []
    for s in t:
        res.append(s.capitalize())
    return res
</code></pre>
<p><code>res</code> é inicializado com uma lista vazia; cada vez que o programa passa pelo loop, acrescentamos o próximo elemento. Então <code>res</code> é outro tipo de acumulador.</p>
<p>Uma operação como <code>capitalize_all</code> às vezes é chamada de <a href="10-listas/14-glossario.html#mapeamento">mapeamento</a> porque ela “mapeia” uma função (nesse caso o método <code>capitalize</code>) sobre cada um dos elementos em uma sequência.</p>
<p>Outra operação comum é selecionar alguns dos elementos de uma lista e retornar uma sublista. Por exemplo, a função seguinte recebe uma lista de strings e retorna uma lista que contém apenas strings em letra maiúscula:</p>
<pre><code class="language-python">def only_upper(t):
    res = []
    for s in t:
        if s.isupper():
            res.append(s)
    return res
</code></pre>
<p><code>isupper</code> é um método de string que retorna True se a string contiver apenas letras maiúsculas.</p>
<p>Uma operação como <code>only_upper</code> é chamada de filtragem porque filtra alguns dos elementos e desconsidera outros.</p>
<p>As operações de lista mais comuns podem ser expressas como uma combinação de mapeamento, filtragem e redução.</p>
<h2><a class="header" href="#108---como-excluir-elementos" id="108---como-excluir-elementos">10.8 - Como excluir elementos</a></h2>
<p>Há várias formas de excluir elementos de uma <a href="10-listas/14-glossario.html#lista">lista</a>. Se souber o índice do <a href="10-listas/14-glossario.html#elemento">elemento</a> que procura, você pode usar <code>pop</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; x = t.pop(1)
&gt;&gt;&gt; t
['a', 'c']
&gt;&gt;&gt; x
'b'
</code></pre>
<p><code>pop</code> altera a lista e retorna o elemento que foi excluído. Se você não incluir um índice, ele exclui e retorna o último elemento.</p>
<p>Se não precisar do valor removido, você pode usar a instrução <code>del</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; del t[1]
&gt;&gt;&gt; t
['a', 'c']
</code></pre>
<p>Se souber o elemento que quer excluir (mas não o índice), você pode usar <code>remove</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; t.remove('b')
&gt;&gt;&gt; t
['a', 'c']
</code></pre>
<p>O valor devolvido por <code>remove</code> é <code>None</code>.</p>
<p>Para remover mais de um elemento, você pode usar <code>del</code> com um índice de fatia:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; del t[1:5]
&gt;&gt;&gt; t
['a', 'f']
</code></pre>
<p>Como sempre, a fatia seleciona todos os elementos até, mas não incluindo, o segundo índice.</p>
<h2><a class="header" href="#109---listas-e-strings" id="109---listas-e-strings">10.9 - Listas e strings</a></h2>
<p>Uma string é uma sequência de caracteres e uma <a href="10-listas/14-glossario.html#lista">lista</a> é uma sequência de valores, mas uma lista de caracteres não é a mesma coisa que uma string. Para converter uma string em uma lista de caracteres, você pode usar list:</p>
<pre><code class="language-python">&gt;&gt;&gt; s = 'spam'
&gt;&gt;&gt; t = list(s)
&gt;&gt;&gt; t
['s', 'p', 'a', 'm']
</code></pre>
<p>Como <code>list</code> é o nome de uma função integrada, você deve evitar usá-lo como nome de variável. Também evito usar <code>l</code> porque parece demais com 1. É por isso que uso <code>t</code>.</p>
<p>A função <code>list</code> quebra uma string em letras individuais. Se você quiser quebrar uma string em palavras, você pode usar o método <code>split</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; s = 'pining for the fjords'
&gt;&gt;&gt; t = s.split()
&gt;&gt;&gt; t
['pining', 'for', 'the', 'fjords']
</code></pre>
<p>Um argumento opcional chamado delimiter especifica quais caracteres podem ser usados para demonstrar os limites das palavras. O exemplo seguinte usa um hífen como <a href="10-listas/14-glossario.html#delimitador">delimitador</a>:</p>
<pre><code class="language-python">&gt;&gt;&gt; s = 'spam-spam-spam'
&gt;&gt;&gt; delimiter = '-'
&gt;&gt;&gt; t = s.split(delimiter)
&gt;&gt;&gt; t
['spam', 'spam', 'spam']
</code></pre>
<p><code>join</code> é o contrário de <code>split</code>. Ele toma uma lista de strings e concatena os elementos. <code>join</code> é um método de string, então é preciso invocá-lo no delimitador e passar a lista como parâmetro:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = ['pining', 'for', 'the', 'fjords']
&gt;&gt;&gt; delimiter = ' '
&gt;&gt;&gt; s = delimiter.join(t)
&gt;&gt;&gt; s
'pining for the fjords'
</code></pre>
<p>Nesse caso, o delimitador é um caractere de espaço, então <code>join</code> coloca um espaço entre as palavras. Para concatenar strings sem espaços, você pode usar a string vazia <code>''</code>, como delimitador.</p>
<h2><a class="header" href="#1010---objetos-e-valores" id="1010---objetos-e-valores">10.10 - Objetos e valores</a></h2>
<p>Se executarmos essas instruções de atribuição:</p>
<pre><code class="language-python">a = 'banana'
b = 'banana'
</code></pre>
<p>Sabemos que a e b se referem a uma string, mas não sabemos se elas se referem à mesma string. Há dois estados possíveis, mostrados na Figura 10.2.</p>
<p><img src="10-listas//fig/tnkp_1002.png" alt="Figura 10.2 – Diagramas de estado possíveis com duas variáveis" />.
<br><em>Figura 10.2 – Diagramas de estado possíveis com duas variáveis.</em></p>
<p>Em um caso, a e b se referem a dois objetos diferentes que têm o mesmo valor. No segundo caso, elas se referem ao mesmo <a href="10-listas/14-glossario.html#objeto">objeto</a>.</p>
<p>Para verificar se duas variáveis se referem ao mesmo objeto, você pode usar o operador is:</p>
<pre><code class="language-python">&gt;&gt;&gt; a = 'banana'
&gt;&gt;&gt; b = 'banana'
&gt;&gt;&gt; a is b
True
</code></pre>
<p>Nesse exemplo, o Python criou apenas um objeto de string e tanto a quanto b se referem a ele. Mas quando você cria duas listas, você tem dois objetos:</p>
<pre><code class="language-python">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [1, 2, 3]
&gt;&gt;&gt; a is b
False
</code></pre>
<p>Então o diagrama de estado fica igual ao da Figura 10.3.</p>
<p><img src="10-listas//fig/tnkp_1003.png" alt="Figura 10.3 – Diagrama de estado com variáveis associadas a listas distintas, de mesmo valor" />.
<br><em>Figura 10.3 – Diagrama de estado com variáveis associadas a listas distintas, de mesmo valor.</em></p>
<p>Nesse caso, diríamos que as duas listas são equivalentes, porque elas têm os mesmos elementos, mas não idênticas, porque elas não são o mesmo objeto. Se dois objetos forem idênticos, eles também são equivalentes, mas se eles forem equivalentes, não são necessariamente idênticos.</p>
<p>Até agora, temos usado “objeto” e “valor” de forma intercambiável, mas é mais exato dizer que um objeto tem um valor. Se avaliar [1, 2, 3], você tem um objeto de <a href="10-listas/14-glossario.html#lista">lista</a> cujo valor é uma sequência de números inteiros. Se outra lista tem os mesmos elementos, dizemos que tem o mesmo valor, mas não é o mesmo objeto.</p>
<h2><a class="header" href="#1011---alias" id="1011---alias">10.11 - Alias</a></h2>
<p>Se a se refere a um <a href="10-listas/14-glossario.html#objeto">objeto</a> e você atribui b = a, então ambas as variáveis se referem ao mesmo objeto.</p>
<pre><code class="language-python">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; b is a
True
</code></pre>
<p>O diagrama de estado ficará igual à Figura 10.4.</p>
<p><img src="10-listas//fig/tnkp_1004.png" alt="Figura 10.4 – Diagrama de estado com duas variáveis associadas à mesma lista" />.
<br><em>Figura 10.4 – Diagrama de estado com duas variáveis associadas à mesma lista.</em></p>
<p>A associação de uma variável com um objeto é chamada de <a href="10-listas/14-glossario.html#refer%C3%AAncia">referência</a>. Neste exemplo, há duas referências ao mesmo objeto.</p>
<p>Um objeto com mais de uma referência tem mais de um nome, então dizemos que o objeto tem um <a href="10-listas/14-glossario.html#alias">alias</a>.</p>
<p>Se o objeto com alias é mutável, alterações feitas em um alias afetam o outro também.</p>
<pre><code class="language-python">&gt;&gt;&gt; b[0] = 42
&gt;&gt;&gt; a
[42, 2, 3]
</code></pre>
<p>Apesar de esse comportamento poder ser útil, ele é passível de erros. Em geral, é mais seguro evitar usar alias ao trabalhar com objetos mutáveis.</p>
<p>Para objetos imutáveis como strings, usar alias não é um problema tão grande. Neste exemplo:</p>
<pre><code class="language-python">a = 'banana'
b = 'banana'
</code></pre>
<p>Quase nunca faz diferença se a e b se referem à mesma string ou não.</p>
<h2><a class="header" href="#1012---argumentos-de-listas" id="1012---argumentos-de-listas">10.12 - Argumentos de listas</a></h2>
<p>Ao passar uma <a href="10-listas/14-glossario.html#lista">lista</a> a uma função, a função recebe uma <a href="10-listas/14-glossario.html#refer%C3%AAncia">referência</a> à lista. Se a função alterar a lista, quem faz a chamada vê a mudança. Por exemplo, delete_head remove o primeiro <a href="10-listas/14-glossario.html#elemento">elemento</a> de uma lista:</p>
<pre><code class="language-python">def delete_head(t):
    del t[0]
Ela é usada assim:
&gt;&gt;&gt; letters = ['a', 'b', 'c']
&gt;&gt;&gt; delete_head(letters)
&gt;&gt;&gt; letters
['b', 'c']
</code></pre>
<p>O parâmetro t e a variável letters são <a href="10-listas/14-glossario.html#alias">alias</a> para o mesmo <a href="10-listas/14-glossario.html#objeto">objeto</a>. O diagrama da pilha fica igual ao da Figura 10.5.</p>
<p><img src="10-listas//fig/tnkp_1005.png" alt="Figura 10.5 – Diagrama da pilha: __main__ e delete_head compartilham referências à mesma lista" />.
<br><em>Figura 10.5 – Diagrama da pilha:</em> <code>__main__</code> <em>e</em> <code>delete_head</code> <em>compartilham referências à mesma lista.</em></p>
<p>Como a lista é compartilhada por dois frames, desenhei-a entre eles.</p>
<p>É importante distinguir entre operações que alteram listas e operações que criam novas listas. Por exemplo, o método <code>append</code> altera a lista, mas o operador <code>+</code> cria uma nova lista:</p>
<pre><code class="language-python">&gt;&gt;&gt; t1 = [1, 2]
&gt;&gt;&gt; t2 = t1.append(3)
&gt;&gt;&gt; t1
[1, 2, 3]
&gt;&gt;&gt; t2
None
</code></pre>
<p>Note que <code>append</code> altera a lista e retorna <code>None</code> (na realidade, o console do Python omite o <code>None</code> da saída, mas você pode conferir usando <code>t2 is None</code>).</p>
<pre><code class="language-python">&gt;&gt;&gt; t3 = t1 + [4]
&gt;&gt;&gt; t1
[1, 2, 3]
&gt;&gt;&gt; t3
[1, 2, 3, 4]
&gt;&gt;&gt; t1
</code></pre>
<p>O operador <code>+</code> cria uma nova lista e deixa a lista original inalterada.</p>
<p>Essa diferença é importante quando você escreve funções que devem alterar listas. Por exemplo, esta função não remove a cabeça de uma lista:</p>
<pre><code class="language-python">def bad_delete_head(t):
    t = t[1:]              # ERRADO!
</code></pre>
<p>O operador de fatia cria uma nova lista e a atribuição faz t se referir a ela, mas isso não afeta quem faz chamada.</p>
<pre><code class="language-python">&gt;&gt;&gt; t4 = [1, 2, 3]
&gt;&gt;&gt; bad_delete_head(t4)
&gt;&gt;&gt; t4
[1, 2, 3]
</code></pre>
<p>No início de <code>bad_delete_head</code>, t e t4 se referem à mesma lista. No final, t se refere a uma nova lista, mas t4 ainda se refere à lista original, inalterada.</p>
<p>Uma alternativa é escrever uma função que crie e retorne uma nova lista. Por exemplo, <code>tail</code> retorna tudo, exceto o primeiro elemento de uma lista:</p>
<pre><code class="language-python">def tail(t):
    return t[1:]
</code></pre>
<p>Esta função deixa a lista original inalterada. Ela é usada assim:</p>
<pre><code class="language-python">&gt;&gt;&gt; letters = ['a', 'b', 'c']
&gt;&gt;&gt; rest = tail(letters)
&gt;&gt;&gt; rest
['b', 'c']
</code></pre>
<h2><a class="header" href="#1013---depuração" id="1013---depuração">10.13 - Depuração</a></h2>
<p>O uso descuidado de listas (e de outros objetos mutáveis) pode levar a longas horas de depuração. Aqui estão algumas armadilhas comuns e formas de evitá-las:</p>
<ol>
<li>A maior parte dos métodos de listas alteram o argumento e retornam None. Isto é o oposto dos métodos de strings, que retornam uma nova string e deixam a original intocada.</li>
</ol>
<p>        Se você está acostumado a escrever código de strings desta forma:</p>
<pre><code class="language-python">        word = word.strip()
</code></pre>
<p>        É tentador escrever código de listas como este:</p>
<pre><code class="language-python">        t = t.sort()            # ERRADO!
</code></pre>
<p>        Como sort retorna None, a próxima operação que você executar com t provavelmente vai falhar.</p>
<p>        Antes de usar métodos e operadores de listas, você deve ler a documentação com cuidado e testá-los no modo interativo.</p>
<ol start="2">
<li>Escolha o termo e fique com ele.</li>
</ol>
<p>        Parte do problema com listas é que há muitas formas de fazer coisas com elas. Por exemplo, para remover um <a href="10-listas/14-glossario.html#elemento">elemento</a> de uma <a href="10-listas/14-glossario.html#lista">lista</a> você pode usar pop, remove, del ou até uma atribuição de fatia.</p>
<p>        Para adicionar um elemento você pode usar o método append ou o operador +. Assumindo que t é uma lista e x é um elemento da lista, isto está correto:</p>
<pre><code class="language-python">        t.append(x)
        t = t + [x]
        t += [x]
        E isto está errado:
        t.append([x])          # ERRADO!
        t = t.append(x)        # ERRADO!
        t + [x]                # ERRADO!
        t = t + x              # ERRADO!
</code></pre>
<p>        Experimente cada um desses exemplos no modo interativo para conferir se você entendeu o que fazem. Note que apenas o último causa um erro de tempo de execução; os outros três são legais, mas eles fazem a coisa errada.</p>
<ol start="3">
<li>Faça cópias para evitar o uso de <a href="10-listas/14-glossario.html#alias">alias</a>.</li>
</ol>
<p>        Se quiser usar um método como sort, que altera o argumento, mas precisa manter a lista original, você pode fazer uma cópia:</p>
<pre><code class="language-python">        &gt;&gt;&gt; t = [3, 1, 2]
        &gt;&gt;&gt; t2 = t[:]
        &gt;&gt;&gt; t2.sort()
        &gt;&gt;&gt; t
        [3, 1, 2]
        &gt;&gt;&gt; t2
        [1, 2, 3]
</code></pre>
<p>        Neste exemplo você poderia usar também a função integrada sorted, que retorna uma nova lista classificada e deixa a original intocada.</p>
<pre><code class="language-python">        &gt;&gt;&gt; t2 = sorted(t)
        &gt;&gt;&gt; t
        [3, 1, 2]
        &gt;&gt;&gt; t2
        [1, 2, 3]
</code></pre>
<h2><a class="header" href="#1014---glossário" id="1014---glossário">10.14 - Glossário</a></h2>
<h5><a class="header" href="#lista" id="lista">lista</a></h5>
<p>    Uma sequência de valores.</p>
<h5><a class="header" href="#elemento" id="elemento">elemento</a></h5>
<p>    Um dos valores em uma lista (ou outra sequência), também chamado de item.</p>
<h5><a class="header" href="#lista-aninhada" id="lista-aninhada">lista aninhada</a></h5>
<p>    Uma lista que é um elemento de outra lista.</p>
<h5><a class="header" href="#acumuladora" id="acumuladora">acumuladora</a></h5>
<p>    Variável usada em um loop para adicionar ou acumular um resultado.</p>
<h5><a class="header" href="#atribuição-aumentada" id="atribuição-aumentada">atribuição aumentada</a></h5>
<p>    Instrução que atualiza o valor de uma variável usando um operador como +=.</p>
<h5><a class="header" href="#redução" id="redução">redução</a></h5>
<p>    Padrão de processamento que atravessa uma sequência e acumula os elementos em um único resultado.</p>
<h5><a class="header" href="#mapeamento" id="mapeamento">mapeamento</a></h5>
<p>    Padrão de processamento que atravessa uma sequência e executa uma operação em cada elemento.</p>
<h5><a class="header" href="#filtragem" id="filtragem">filtragem</a></h5>
<p>    Padrão de processamento que atravessa uma lista e seleciona os elementos que satisfazem algum critério.</p>
<h5><a class="header" href="#objeto-1" id="objeto-1">objeto</a></h5>
<p>    Algo a que uma variável pode se referir. Um objeto tem um tipo e um valor.</p>
<h5><a class="header" href="#equivalente" id="equivalente">equivalente</a></h5>
<p>    Ter o mesmo valor.</p>
<h5><a class="header" href="#idêntico" id="idêntico">idêntico</a></h5>
<p>    Ser o mesmo objeto (o que implica equivalência).</p>
<h5><a class="header" href="#referência" id="referência">referência</a></h5>
<p>    Associação entre uma variável e seu valor.</p>
<h5><a class="header" href="#alias" id="alias">alias</a></h5>
<p>    Uma circunstância onde duas ou mais variáveis se referem ao mesmo objeto.</p>
<h5><a class="header" href="#delimitador" id="delimitador">delimitador</a></h5>
<p>    Um caractere ou uma string usada para indicar onde uma string deve ser dividida.</p>
<h2><a class="header" href="#1015---exercícios" id="1015---exercícios">10.15 - Exercícios</a></h2>
<p>Você pode baixar as soluções para estes exercícios em <a href="http://thinkpython2.com/code/list_exercises.py">http://thinkpython2.com/code/list_exercises.py</a>.</p>
<h3><a class="header" href="#exercício-101" id="exercício-101">Exercício 10.1</a></h3>
<p>Escreva uma função chamada <code>nested_sum</code> que receba uma <a href="10-listas/14-glossario.html#lista">lista</a> de listas de números inteiros e adicione os elementos de todas as listas aninhadas. Por exemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = [[1, 2], [3], [4, 5, 6]]
&gt;&gt;&gt; nested_sum(t)
21
</code></pre>
<h3><a class="header" href="#exercício-102" id="exercício-102">Exercício 10.2</a></h3>
<p>Escreva uma função chamada cumsum que receba uma lista de números e retorne a soma cumulativa; isto é, uma nova lista onde o i-ésimo <a href="10-listas/14-glossario.html#elemento">elemento</a> é a soma dos primeiros i+1 elementos da lista original. Por exemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; cumsum(t)
[1, 3, 6]
</code></pre>
<h3><a class="header" href="#exercício-103" id="exercício-103">Exercício 10.3</a></h3>
<p>Escreva uma função chamada middle que receba uma lista e retorne uma nova lista com todos os elementos originais, exceto os primeiros e os últimos elementos. Por exemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = [1, 2, 3, 4]
&gt;&gt;&gt; middle(t)
[2, 3]
</code></pre>
<h3><a class="header" href="#exercício-104" id="exercício-104">Exercício 10.4</a></h3>
<p>Escreva uma função chamada chop que tome uma lista alterando-a para remover o primeiro e o último elementos, e retorne None. Por exemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = [1, 2, 3, 4]
&gt;&gt;&gt; chop(t)
&gt;&gt;&gt; t
[2, 3]
</code></pre>
<h3><a class="header" href="#exercício-105" id="exercício-105">Exercício 10.5</a></h3>
<p>Escreva uma função chamada is_sorted que tome uma lista como parâmetro e retorne True se a lista estiver classificada em ordem ascendente, e False se não for o caso. Por exemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; is_sorted([1, 2, 2])
True
&gt;&gt;&gt; is_sorted(['b', 'a'])
False
</code></pre>
<h3><a class="header" href="#exercício-106" id="exercício-106">Exercício 10.6</a></h3>
<p>Duas palavras são anagramas se você puder soletrar uma rearranjando as letras da outra. Escreva uma função chamada is_anagram que tome duas strings e retorne True se forem anagramas.</p>
<h3><a class="header" href="#exercício-107" id="exercício-107">Exercício 10.7</a></h3>
<p>Escreva uma função chamada has_duplicates que tome uma lista e retorne True se houver algum elemento que apareça mais de uma vez. Ela não deve modificar a lista original.</p>
<h3><a class="header" href="#exercício-108" id="exercício-108">Exercício 10.8</a></h3>
<p>Este exercício pertence ao assim chamado Paradoxo de aniversário, sobre o qual você pode ler em <a href="http://en.wikipedia.org/wiki/Birthday_paradox">http://en.wikipedia.org/wiki/Birthday_paradox</a>.</p>
<p>Se há 23 alunos na sua sala, quais são as chances de dois deles fazerem aniversário no mesmo dia? Você pode estimar esta probabilidade gerando amostras aleatórias de 23 dias de aniversário e verificando as correspondências. Dica: você pode gerar aniversários aleatórios com a função randint no módulo random.</p>
<p>Se quiser, você pode baixar minha solução em <a href="http://thinkpython2.com/code/birthday.py">http://thinkpython2.com/code/birthday.py</a>.</p>
<h3><a class="header" href="#exercício-109" id="exercício-109">Exercício 10.9</a></h3>
<p>Escreva uma função que leia o arquivo words.txt e construa uma lista com um elemento por palavra. Escreva duas versões desta função, uma usando o método append e outra usando a expressão <code>t = t + [x]</code>. Qual leva mais tempo para ser executada? Por quê?</p>
<p>Solução: <a href="http://thinkpython2.com/code/wordlist.py">http://thinkpython2.com/code/wordlist.py</a>.</p>
<h3><a class="header" href="#exercício-1010" id="exercício-1010">Exercício 10.10</a></h3>
<p>Para verificar se uma palavra está na lista de palavras, você pode usar o operador in, mas isso seria lento porque pesquisaria as palavras em ordem.</p>
<p>Como as palavras estão em ordem alfabética, podemos acelerar as coisas com uma busca por bisseção (também conhecida como pesquisa binária), que é semelhante ao que você faz quando procura uma palavra no dicionário. Você começa no meio e verifica se a palavra que está procurando vem antes da palavra no meio da lista. Se for o caso, procura na primeira metade da lista. Se não, procura na segunda metade.</p>
<p>De qualquer forma, você corta o espaço de busca restante pela metade. Se a lista de palavras tiver 113.809 palavras, o programa seguirá uns 17 passos para encontrar a palavra ou concluir que não está lá.</p>
<p>Escreva uma função chamada in_bisect que receba uma lista ordenada, um valor-alvo e devolva o índice do valor na lista se ele estiver lá, ou None se não estiver.</p>
<p>Ou você pode ler a documentação do módulo bisect e usá-lo!</p>
<p>Solução: <a href="http://thinkpython2.com/code/inlist.py">http://thinkpython2.com/code/inlist.py</a>.</p>
<h3><a class="header" href="#exercício-1011" id="exercício-1011">Exercício 10.11</a></h3>
<p>Duas palavras são um “par inverso” se uma for o contrário da outra. Escreva um programa que encontre todos os pares inversos na lista de palavras.</p>
<p>Solução: <a href="http://thinkpython2.com/code/reverse_pair.py">http://thinkpython2.com/code/reverse_pair.py</a>.</p>
<h3><a class="header" href="#exercício-1012" id="exercício-1012">Exercício 10.12</a></h3>
<p>Duas palavras “interligam-se” quando, ao tomarmos letras alternadas de cada uma, formamos uma palavra nova. Por exemplo, “shoe” e “cold” interligam-se para formar “schooled”.</p>
<p>Solução: <a href="http://thinkpython2.com/code/interlock.py">http://thinkpython2.com/code/interlock.py</a>. Crédito: este exercício foi inspirado por um exemplo em <a href="http://puzzlers.org">http://puzzlers.org</a>.</p>
<ol>
<li>
<p>Escreva um programa que encontre todos os pares de palavras que se interligam. Dica: não enumere todos os pares!</p>
</li>
<li>
<p>Você pode encontrar palavras que sejam interligadas de três em três; isto é, cada terceira letra forma uma palavra, começando da primeira, segunda ou terceira?</p>
</li>
</ol>
<h1><a class="header" href="#capítulo-11-dicionários" id="capítulo-11-dicionários">Capítulo 11: Dicionários</a></h1>
<p>Este capítulo apresenta outro tipo integrado chamado <a href="11-dicionarios/09-glossario.html#dicion%C3%A1rio">dicionário</a>. Dicionários são um dos melhores recursos do Python; eles são os blocos de montar de muitos algoritmos eficientes e elegantes.</p>
<h2><a class="header" href="#111---um-a-href11-dicionarios09-glossariohtmldicionc3a1riodicionárioa-é-um-a-href11-dicionarios09-glossariohtmlmapeamentomapeamentoa" id="111---um-a-href11-dicionarios09-glossariohtmldicionc3a1riodicionárioa-é-um-a-href11-dicionarios09-glossariohtmlmapeamentomapeamentoa">11.1 - Um <a href="11-dicionarios/09-glossario.html#dicion%C3%A1rio">dicionário</a> é um <a href="11-dicionarios/09-glossario.html#mapeamento">mapeamento</a></a></h2>
<p>Um dicionário se parece com uma lista, mas é mais geral. Em uma lista, os índices têm que ser números inteiros; em um dicionário, eles podem ser de (quase) qualquer tipo.</p>
<p>Um dicionário contém uma coleção de índices, que se chamam chaves e uma coleção de valores. Cada <a href="11-dicionarios/09-glossario.html#chave">chave</a> é associada com um único <a href="11-dicionarios/09-glossario.html#valor">valor</a>. A associação de uma chave e um valor chama-se <a href="11-dicionarios/09-glossario.html#par-chave-valor">par chave-valor</a> ou <a href="11-dicionarios/09-glossario.html#item">item</a>.</p>
<p>Em linguagem matemática, um dicionário representa um mapeamento de chaves a valores, para que você possa dizer que cada chave “mostra o mapa a” um valor. Como exemplo, vamos construir um dicionário que faz o mapa de palavras do inglês ao espanhol, portanto as chaves e os valores são todos strings.</p>
<p>A função dict cria um novo dicionário sem itens. Como dict é o nome de uma função integrada, você deve evitar usá-lo como nome de variável.</p>
<pre><code class="language-python">&gt;&gt;&gt; eng2sp = dict()
&gt;&gt;&gt; eng2sp
{}
</code></pre>
<p>As chaves {} representam um dicionário vazio. Para acrescentar itens ao dicionário, você pode usar colchetes:</p>
<pre><code class="language-python">&gt;&gt;&gt; eng2sp['one'] = 'uno'
</code></pre>
<p>Esta linha cria um item que mapeia da chave 'one' ao valor 'uno'. Se imprimirmos o dicionário novamente, vemos um par chave-valor com dois pontos entre a chave e o valor:</p>
<pre><code class="language-python">&gt;&gt;&gt; eng2sp
{'one': 'uno'}
</code></pre>
<p>Este formato de saída também é um formato de entrada. Por exemplo, você pode criar um dicionário com três itens:</p>
<pre><code class="language-python">&gt;&gt;&gt; eng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}
</code></pre>
<p>Porém, se exibir <code>eng2sp</code>, pode se surpreender:</p>
<pre><code class="language-python">&gt;&gt;&gt; eng2sp
{'one': 'uno', 'three': 'tres', 'two': 'dos'}
</code></pre>
<p>A ordem dos pares chave-valor pode não ser a mesma. Se você digitar o mesmo exemplo no seu computador, pode receber um resultado diferente. Em geral, a ordem dos itens em um dicionário é imprevisível.</p>
<p>No entanto, isso não é um problema porque os elementos de um dicionário nunca são indexados com índices de números inteiros. Em vez disso, você usa as chaves para procurar os valores correspondentes:</p>
<pre><code class="language-python">&gt;&gt;&gt; eng2sp['two']
'dos'
</code></pre>
<p>A chave <code>'two'</code> sempre mapeia ao valor <code>'dos'</code>, assim a ordem dos itens não importa.</p>
<p>Se a chave não estiver no dicionário, você recebe uma exceção:</p>
<pre><code class="language-python">&gt;&gt;&gt; eng2sp['four']
KeyError: 'four'
</code></pre>
<p>A função <code>len</code> é compatível com dicionários; ela devolve o número de pares chave-valor:</p>
<pre><code class="language-python">&gt;&gt;&gt; len(eng2sp)
3
</code></pre>
<p>O operador <code>in</code> funciona em dicionários também; ele acusa se algo aparece como chave no dicionário (aparecer como valor não é o suficiente).</p>
<pre><code class="language-python">&gt;&gt;&gt; 'one' in eng2sp
True
&gt;&gt;&gt; 'uno' in eng2sp
False
</code></pre>
<p>Para ver se algo aparece como um valor em um dicionário, você pode usar o método <code>values</code>, que devolve uma coleção de valores, e então usar o operador <code>in</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; vals = eng2sp.values()
&gt;&gt;&gt; 'uno' in vals
True
</code></pre>
<p>O operador <code>in</code> usa algoritmos diferentes para listas e dicionários. Para listas, ele procura os elementos da lista em ordem, como descrito em “Busca”, na página 123. Conforme a lista torna-se mais longa, o tempo de <a href="11-dicionarios/09-glossario.html#busca">busca</a> também fica proporcionalmente mais longo.</p>
<p>Para dicionários, o Python usa um algoritmo chamado <a href="11-dicionarios/09-glossario.html#hashtable">hashtable</a> (tabela de dispersão), que tem uma propriedade notável: o operador <code>in</code> leva praticamente o mesmo tempo na busca, não importa quantos itens estejam no dicionário. Eu explico como isso é possível em “Hashtables”, na página 302, mas a explicação pode não fazer sentido até que você tenha lido mais alguns capítulos.</p>
<h2><a class="header" href="#112---um-a-href11-dicionarios09-glossariohtmldicionc3a1riodicionárioa-como-uma-coleção-de-contadores" id="112---um-a-href11-dicionarios09-glossariohtmldicionc3a1riodicionárioa-como-uma-coleção-de-contadores">11.2 - Um <a href="11-dicionarios/09-glossario.html#dicion%C3%A1rio">dicionário</a> como uma coleção de contadores</a></h2>
<p>Suponha que você receba uma string e queira contar quantas vezes cada letra aparece nela. Há vários modos de fazer isso:</p>
<ol>
<li>
<p>Você pode criar 26 variáveis, uma para cada letra do alfabeto. Então pode atravessar a string e, para cada caractere, incrementar o contador correspondente, provavelmente usando uma condicional encadeada.</p>
</li>
<li>
<p>Você pode criar uma lista com 26 elementos. Então pode converter cada caractere em um número (com a função integrada ord), usar o número como índice na lista e incrementar o respectivo contador.</p>
</li>
<li>
<p>Você pode criar um dicionário com caracteres como chaves e contadores como valores correspondentes. Na primeira vez que visse um caractere, você acrescentaria um <a href="11-dicionarios/09-glossario.html#item">item</a> ao dicionário. Depois disso, incrementaria o <a href="11-dicionarios/09-glossario.html#valor">valor</a> de um item existente.</p>
</li>
</ol>
<p>Cada uma dessas opções executa o mesmo cálculo, mas o implementa de forma diferente.</p>
<p>Uma <a href="11-dicionarios/09-glossario.html#implementa%C3%A7%C3%A3o">implementação</a> é um modo de executar um cálculo; algumas implementações são melhores que outras. Por exemplo, uma vantagem da implementação de dicionários é que não precisamos saber de antemão quais letras aparecem na string e só é preciso criar espaço para as letras que realmente venham a aparecer.</p>
<p>O código poderia ser assim:</p>
<pre><code class="language-python">def histogram(s):
    d = dict()
    for c in s:
        if c not in d:
            d[c] = 1
        else:
            d[c] += 1
    return d
</code></pre>
<p>O nome da função é <code>histogram</code>, um termo estatístico para uma coleção de contadores (ou frequências).</p>
<p>A primeira linha da função cria um dicionário vazio. O loop for atravessa a string. Cada vez que passa pelo loop, se o caractere c não estiver no dicionário, criamos um item com a <a href="11-dicionarios/09-glossario.html#chave">chave</a> c e o valor inicial 1 (pois já vimos esta letra uma vez). Se o c já estiver no dicionário, incrementamos d [c].</p>
<p>Funciona assim:</p>
<pre><code class="language-python">&gt;&gt;&gt; h = histogram('brontosaurus')
&gt;&gt;&gt; h
{'a': 1, 'b': 1, 'o': 2, 'n': 1, 's': 2, 'r': 2, 'u': 2, 't': 1}
</code></pre>
<p>O histograma indica que as letras 'a' e 'b' aparecem uma vez; 'o' aparece duas vezes, e assim por diante.</p>
<p>Os dicionários têm um método chamado <code>get</code>, que toma uma chave e um valor padrão. Se a chave aparecer no dicionário, <code>get</code> retorna o valor correspondente; se não for o caso, ele retorna o valor padrão. Por exemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; h = histogram('a')
&gt;&gt;&gt; h
{'a': 1}
&gt;&gt;&gt; h.get('a', 0)
1
&gt;&gt;&gt; h.get('b', 0)
0
</code></pre>
<p>Como exercício, use o <code>get</code> para escrever a função <code>histogram</code> de forma mais concisa. Tente eliminar a instrução <code>if</code>.</p>
<h2><a class="header" href="#113---loop-e-dicionários" id="113---loop-e-dicionários">11.3 - Loop e dicionários</a></h2>
<p>Se usar um <a href="11-dicionarios/09-glossario.html#dicion%C3%A1rio">dicionário</a> em uma instrução <code>for</code>, ela percorre as chaves do dicionário. Por exemplo, <code>print_hist</code> exibe cada <a href="11-dicionarios/09-glossario.html#chave">chave</a> e o <a href="11-dicionarios/09-glossario.html#valor">valor</a> correspondente:</p>
<pre><code class="language-python">def print_hist(h):
    for c in h:
        print(c, h[c])
</code></pre>
<p>Isso é o que aparece:</p>
<pre><code class="language-python">&gt;&gt;&gt; h = histogram('parrot')
&gt;&gt;&gt; print_hist(h)
a 1
p 1
r 2
t 1
o 1
</code></pre>
<p>Novamente, as chaves não estão em nenhuma ordem determinada. Para atravessar as chaves em ordem ascendente, você pode usar a função integrada <code>sorted</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; for key in sorted(h):
...     print(key, h[key])
a 1
o 1
p 1
r 2
t 1
</code></pre>
<h2><a class="header" href="#114---busca-reversa" id="114---busca-reversa">11.4 - Busca reversa</a></h2>
<p>Considerando um <a href="11-dicionarios/09-glossario.html#dicion%C3%A1rio">dicionário</a> <code>d</code> e uma <a href="11-dicionarios/09-glossario.html#chave">chave</a> <code>k</code>, é fácil encontrar o <a href="11-dicionarios/09-glossario.html#valor">valor</a> correspondente <code>v = d [k]</code>. Esta operação chama-se <a href="11-dicionarios/09-glossario.html#busca">busca</a>.</p>
<p>Mas e se você tiver <code>v</code> e quiser encontrar <code>k</code>? Você tem dois problemas: em primeiro lugar, pode haver mais de uma chave que esteja mapeada ao valor <code>v</code>. Dependendo da aplicação, quem sabe você pode escolher um, ou talvez tenha de fazer uma lista que contenha todos eles. Em segundo lugar, não há sintaxe simples para fazer uma <a href="11-dicionarios/09-glossario.html#busca-reversa">busca reversa</a>; é preciso procurar.</p>
<p>Aqui está uma função que recebe um valor e retorna a primeira chave mapeada ao valor dado:</p>
<pre><code class="language-python">def reverse_lookup(d, v):
    for k in d:
        if d[k] == v:
            return k
    raise LookupError()
</code></pre>
<p>Essa função é mais um exemplo do padrão de busca, mas usa um recurso que ainda não tínhamos visto: <code>raise</code>. A instrução <code>raise</code> causa uma exceção; neste caso, causa um <code>LookupError</code>, que é uma exceção integrada, usada para indicar que uma operação de busca falhou.</p>
<p>Se chegarmos ao fim do loop significa que <code>v</code> não aparece no dicionário como um valor, portanto apresentaremos uma exceção.</p>
<p>Aqui está um exemplo de uma busca reversa bem sucedida:</p>
<pre><code class="language-python">&gt;&gt;&gt; h = histogram('parrot')
&gt;&gt;&gt; k = reverse_lookup(h, 2)
&gt;&gt;&gt; k
'r'
</code></pre>
<p>E uma mal sucedida:</p>
<pre><code class="language-python">&gt;&gt;&gt; k = reverse_lookup(h, 3)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;stdin&gt;&quot;, line 5, in reverse_lookup
LookupError
</code></pre>
<p>O efeito causado por você ao apresentar uma exceção é igual ao causado pelo Python quando faz o mesmo: ele exibe um traceback e uma mensagem de erro.</p>
<p>A <a href="11-dicionarios/09-glossario.html#instru%C3%A7%C3%A3o-raise">instrução raise</a> pode receber uma mensagem de erro detalhada como argumento opcional. Por exemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; raise LookupError('value does not appear in the dictionary')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
LookupError: value does not appear in the dictionary
</code></pre>
<p>Uma busca reversa é muito mais lenta que uma busca no sentido normal; se for preciso fazê-lo muitas vezes, ou se o dicionário ficar muito grande, o desempenho do seu programa será prejudicado.</p>
<h2><a class="header" href="#115---dicionários-e-listas" id="115---dicionários-e-listas">11.5 - Dicionários e listas</a></h2>
<p>As listas podem aparecer como valores em um <a href="11-dicionarios/09-glossario.html#dicion%C3%A1rio">dicionário</a>. Por exemplo, se você receber um dicionário que mapeie letras e frequências, é uma boa ideia invertê-lo; isto é, crie um dicionário que mapeie de frequências a letras. Como pode haver várias letras com a mesma frequência, cada <a href="11-dicionarios/09-glossario.html#valor">valor</a> no dicionário invertido deve ser uma lista de letras.</p>
<p>Aqui está uma função que inverte um dicionário:</p>
<pre><code class="language-python">def invert_dict(d):
    inverse = dict()
    for key in d:
        val = d[key]
        if val not in inverse:
            inverse[val] = [key]
        else:
            inverse[val].append(key)
    return inverse
</code></pre>
<p>Cada vez que o programa passar pelo loop, a key recebe uma <a href="11-dicionarios/09-glossario.html#chave">chave</a> de d e val recebe o valor correspondente. Se val não estiver em inverse significa que não foi vista antes, então criamos um <a href="11-dicionarios/09-glossario.html#item">item</a> e o inicializamos com um item avulso (em inglês, singleton, uma lista que contém um único elemento). Se não for o caso é porque vimos esse valor antes, então acrescentamos a chave correspondente à lista.</p>
<p>Aqui está um exemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; hist = histogram('parrot')
&gt;&gt;&gt; hist
{'a': 1, 'p': 1, 'r': 2, 't': 1, 'o': 1}
&gt;&gt;&gt; inverse = invert_dict(hist)
&gt;&gt;&gt; inverse
{1: ['a', 'p', 't', 'o'], 2: ['r']}
</code></pre>
<p>A Figura 11.1 é um diagrama de estado mostrando hist e inverse. Um dicionário é representado como uma caixa com o tipo dict acima dela e os pares chave-valor no interior. Se os valores forem números inteiros, de ponto flutuante ou strings, desenho-os dentro da caixa, mas normalmente prefiro desenhar listas do lado de fora, para manter o diagrama simples.</p>
<p><img src="11-dicionarios//fig/tnkp_1101.png" alt="Figura 11.1 – Diagrama de estado de um dicionário e seu inverso" />.
<br><em>Figura 11.1 – Diagrama de estado de um dicionário e seu inverso.</em></p>
<p>As listas podem ser valores em um dicionário, como mostra este exemplo, mas não podem ser chaves. Isso é o que acontece se você tentar:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; d = dict()
&gt;&gt;&gt; d[t] = 'oops'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
TypeError: list objects are unhashable
</code></pre>
<p>Já mencionei que um dicionário é implementado usando uma <a href="11-dicionarios/09-glossario.html#hashtable">hashtable</a> e isso significa que é preciso que as chaves possam ser <a href="11-dicionarios/09-glossario.html#hashable">hashable</a> (que seja possível computar seu hash, e que este valor de hash seja imutável).</p>
<p><code>hash</code> é uma função que recebe um valor (de qualquer tipo) e devolve um número inteiro. Dicionários usam esses números inteiros, chamados valores <code>hash</code>, para guardar e buscar pares chave-valor.</p>
<p>Este sistema funciona perfeitamente se as chaves forem imutáveis. Porém, se as chaves são mutáveis, como listas, coisas ruins acontecem. Por exemplo, quando você cria um <a href="11-dicionarios/09-glossario.html#par-chave-valor">par chave-valor</a>, o Python guarda a chave na posição correspondente. Se você modificar a chave e então guardá-la novamente, ela iria para uma posição diferente. Nesse caso, você poderia ter duas entradas para a mesma chave, ou pode não conseguir encontrar uma chave. De qualquer forma, o dicionário não funcionaria corretamente.</p>
<p>É por isso que as chaves têm de ser hashable, e tipos mutáveis como listas, não são. A forma mais simples de resolver esta limitação é usar tuplas, que serão vistas no próximo capítulo.</p>
<p>Como os dicionários são mutáveis, eles não podem ser usados como chaves, mas podem ser usados como valores.</p>
<h2><a class="header" href="#116---memos" id="116---memos">11.6 - Memos</a></h2>
<p>Se usou a função de fibonacci em “Mais um exemplo”, na página 101, pode ter notado que quanto maior o argumento dado mais tempo a função leva para ser executada. Além disso, o tempo de execução aumenta rapidamente.</p>
<p>Para entender por que, considere a Figura 11.2, que mostra o <a href="11-dicionarios/09-glossario.html#gr%C3%A1fico-de-chamada">gráfico de chamada</a> de <code>fibonacci</code> com n=4.</p>
<p><img src="11-dicionarios//fig/tnkp_1102.png" alt="Figura 11.2 – Gráfico de chamada para fibonacci" />.
<br><em>Figura 11.2 – Gráfico de chamada para</em> <code>fibonacci</code>.</p>
<p>Um gráfico de chamada mostra um conjunto de frames de função, com linhas que unem cada frame aos frames das funções que chama. Na parte de cima do gráfico, <code>fibonacci</code> com <code>n=4</code> chama <code>fibonacci</code> com <code>n=3</code> e <code>n=2</code>. Por sua vez, <code>fibonacci</code> com <code>n=3</code> chama <code>fibonacci</code> com <code>n=2</code> e <code>n=1</code>. E assim por diante.</p>
<p>Conte quantas vezes <code>fibonacci(0)</code> e <code>fibonacci(1)</code> são chamadas. Essa é uma solução ineficiente para o problema, e piora conforme o argumento se torna maior.</p>
<p>Uma solução é acompanhar os valores que já foram calculados, guardando-os em um <a href="11-dicionarios/09-glossario.html#dicion%C3%A1rio">dicionário</a>. Um <a href="11-dicionarios/09-glossario.html#valor">valor</a> calculado anteriormente que é guardado para uso posterior é chamado de <a href="11-dicionarios/09-glossario.html#memo">memo</a>. Aqui está uma versão com memos de <code>fibonacci</code>:</p>
<pre><code class="language-python">known = {0:0, 1:1}
def fibonacci(n):
    if n in known:
        return known[n]
    res = fibonacci(n-1) + fibonacci(n-2)
    known[n] = res
    return res
</code></pre>
<p><code>known</code> é um dicionário que monitora os números de Fibonacci que já conhecemos. Começa com dois itens: 0 mapeia a 0 e 1 mapeia a 1.</p>
<p>Sempre que <code>fibonacci</code> é chamada, ela verifica <code>known</code>. Se o resultado já estiver lá, pode voltar imediatamente. Se não for o caso, é preciso calcular o novo valor, acrescentá-lo ao dicionário e devolvê-lo.</p>
<p>Se você executar essa versão de <code>fibonacci</code> e a comparar com a original, descobrirá que é muito mais rápida.</p>
<h2><a class="header" href="#117---variáveis-globais" id="117---variáveis-globais">11.7 - Variáveis globais</a></h2>
<p>No exemplo anterior, known é criada fora da função, então pertence ao frame especial chamado <code>__main__</code>. As variáveis em <code>__main__</code> às vezes são chamadas de globais, porque podem ser acessadas de qualquer função. Em contraste com as variáveis locais, que desaparecem quando sua função termina, as variáveis globais persistem de uma chamada da função à seguinte.</p>
<p>É comum usar variáveis globais para <code>flags</code>; isto é, variáveis booleanas que indicam (“<a href="11-dicionarios/09-glossario.html#flag">flag</a>”) se uma condição é verdadeira. Por exemplo, alguns programas usam um <code>flag</code> denominado verbose para controlar o nível de detalhe da saída:</p>
<pre><code class="language-python">verbose = True
def example1():
    if verbose:
        print('Running example1')
</code></pre>
<p>Se tentar reatribuir uma <a href="11-dicionarios/09-glossario.html#vari%C3%A1vel-global">variável global</a>, você pode se surpreender. O próximo exemplo mostra como acompanhar se a função foi chamada:</p>
<pre><code class="language-python">been_called = False
def example2():
    been_called = True        # ERRADO
</code></pre>
<p>Porém, se executá-la, você verá que o <a href="11-dicionarios/09-glossario.html#valor">valor</a> de <code>been_called</code> não se altera. O problema é que <code>example2</code> cria uma nova variável local chamada <code>been_called</code>. A variável local some quando a função termina e não tem efeito sobre a variável global.</p>
<p>Para reatribuir uma variável global dentro de uma função é preciso declarar a variável como global antes de usá-la:</p>
<pre><code class="language-python">been_called = False
def example2():
    global been_called
    been_called = True
</code></pre>
<p>A instrução <code>global</code> diz ao interpretador algo como “Nesta função, quando digo <code>been_called</code>, estou falando da variável global; não crie uma local”.</p>
<p>Aqui está um exemplo que tenta atualizar uma variável global:</p>
<pre><code class="language-python">count = 0
def example3():
    count = count + 1        # ERRADO
</code></pre>
<p>Se executá-la, você recebe:</p>
<pre><code class="language-python">UnboundLocalError: local variable 'count' referenced before assignment
</code></pre>
<p>O Python supõe que <code>count</code> seja local, e dentro desta suposição, a variável está sendo lida antes de ser escrita. A solução, mais uma vez, é declarar <code>count</code> como global:</p>
<pre><code class="language-python">def example3():
    global count
    count += 1
</code></pre>
<p>Se uma variável global se referir a um valor mutável, você pode alterar o valor sem declarar a variável:</p>
<pre><code class="language-python">known = {0:0, 1:1}
def example4():
    known[2] = 1
</code></pre>
<p>Então você pode adicionar, retirar e substituir elementos de uma lista global ou <a href="11-dicionarios/09-glossario.html#dicion%C3%A1rio">dicionário</a>, mas se quiser reatribuir a variável, precisa declará-la:</p>
<pre><code class="language-python">def example5():
    global known
    known = dict()
</code></pre>
<p>As variáveis globais podem ser úteis, mas se você tiver muitas delas e alterá-las com frequência, isso poderá dificultar a depuração do programa.</p>
<h2><a class="header" href="#118---depuração" id="118---depuração">11.8 - Depuração</a></h2>
<p>Ao trabalhar com conjuntos de dados maiores, depurar exibindo e verificando a saída à mão pode ser trabalhoso. Aqui estão algumas sugestões para depurar grandes conjuntos de dados:</p>
<h5><a class="header" href="#reduza-a-entrada" id="reduza-a-entrada">Reduza a entrada</a></h5>
<p>    Se for possível, reduza o tamanho do conjunto de dados. Por exemplo, se o programa lê um arquivo de texto, comece com apenas as 10 primeiras linhas, ou com o menor exemplo que puder encontrar. Você pode editar os próprios arquivos ou alterar o programa para que leia só as primeiras n linhas (é melhor).</p>
<p>    Se houver um erro, você pode reduzir n ao menor <a href="11-dicionarios/09-glossario.html#valor">valor</a> que manifeste o erro, e então aumentá-lo gradativamente até encontrar e corrigir o erro.</p>
<h5><a class="header" href="#verifique-os-resumos-e-tipos" id="verifique-os-resumos-e-tipos">Verifique os resumos e tipos</a></h5>
<p>    Em vez de imprimir e verificar o conjunto de dados inteiro, pense em exibir resumos dos dados: por exemplo, o número de itens em um <a href="11-dicionarios/09-glossario.html#dicion%C3%A1rio">dicionário</a> ou o total de uma lista de números.</p>
<p>    Uma causa comum de erros em tempo de execução são valores de tipo incompatível. Para depurar essa espécie de erro, muitas vezes basta exibir o tipo de um valor.</p>
<h5><a class="header" href="#crie-autoverificações" id="crie-autoverificações">Crie autoverificações</a></h5>
<p>    É possível escrever o código para verificar erros automaticamente. Por exemplo, se estiver calculando a média de uma lista de números, você pode verificar se o resultado não é mais alto que o maior elemento da lista ou mais baixo que o menor. Isso é chamado de “verificação de sanidade” porque descobre resultados “insanos”.</p>
<p>    Outro tipo de verificação compara os resultados de dois cálculos diferentes para ver se são consistentes. Isso é chamado de “verificação de consistência”.</p>
<h5><a class="header" href="#formate-a-saída" id="formate-a-saída">Formate a saída</a></h5>
<p>    A formatação da saída para depuração pode facilitar a <a href="11-dicionarios/09-glossario.html#busca">busca</a> de erros. Vimos um exemplo em “Depuração”, na página 172. O módulo <code>pprint</code> apresenta uma função <code>pprint</code> que exibe tipos integrados em um formato mais legível para humanos (<code>pprint</code> é a abreviação de “pretty print” (bela exibição)).</p>
<p>Reforçando, o tempo que você passar construindo o scaffolding (o andaime) pode reduzir o tempo de depuração.</p>
<h2><a class="header" href="#119---glossário" id="119---glossário">11.9 - Glossário</a></h2>
<h5><a class="header" href="#mapeamento-1" id="mapeamento-1">mapeamento</a></h5>
<p>    Relação na qual cada elemento de um conjunto corresponde a um elemento de outro conjunto.</p>
<h5><a class="header" href="#dicionário" id="dicionário">dicionário</a></h5>
<p>    Mapeamento de chaves aos seus valores correspondentes.</p>
<h5><a class="header" href="#par-chave-valor" id="par-chave-valor">par chave-valor</a></h5>
<p>    Representação do mapeamento de uma chave a um valor.</p>
<h5><a class="header" href="#item-1" id="item-1">item</a></h5>
<p>    Em um dicionário, outro nome para um par chave-valor.</p>
<h5><a class="header" href="#chave" id="chave">chave</a></h5>
<p>    Objeto que aparece em um dicionário como a primeira parte de um par chave-valor.</p>
<h5><a class="header" href="#valor-1" id="valor-1">valor</a></h5>
<p>    Objeto que aparece em um dicionário como a segunda parte de um par chave-valor. Isso é mais específico que o nosso uso anterior da palavra “valor”.</p>
<h5><a class="header" href="#implementação" id="implementação">implementação</a></h5>
<p>    Uma forma de executar um cálculo.</p>
<h5><a class="header" href="#hashtable" id="hashtable">hashtable</a></h5>
<p>    Algoritmo usado para implementar dicionários de Python.</p>
<h5><a class="header" href="#função-hash" id="função-hash">função hash</a></h5>
<p>    Função usada por uma hashtable para calcular a posição de uma chave.</p>
<h5><a class="header" href="#hashable" id="hashable">hashable</a></h5>
<p>    Um tipo que tem uma função hash. Tipos imutáveis como números inteiros, de ponto flutuante e strings são hashable; tipos mutáveis, como listas e dicionários, não são.</p>
<h5><a class="header" href="#busca-1" id="busca-1">busca</a></h5>
<p>    Operação de dicionário que recebe uma chave e encontra o valor correspondente.</p>
<h5><a class="header" href="#busca-reversa" id="busca-reversa">busca reversa</a></h5>
<p>    Operação de dicionário que recebe um valor e encontra uma ou várias chaves que o mapeiem.</p>
<h5><a class="header" href="#instrução-raise" id="instrução-raise">instrução raise</a></h5>
<p>    Instrução que (deliberadamente) causa uma exceção.</p>
<h5><a class="header" href="#item-avulso-singleton" id="item-avulso-singleton">item avulso (singleton)</a></h5>
<p>    Uma lista (ou outra sequência) com um único elemento.</p>
<h5><a class="header" href="#gráfico-de-chamada" id="gráfico-de-chamada">gráfico de chamada</a></h5>
<p>    Um diagrama que mostra cada frame criado durante a execução de um programa, com uma flecha apontando quem chama a quem é chamado.</p>
<h5><a class="header" href="#memo" id="memo">memo</a></h5>
<p>    Valor já calculado, guardado para não ter que fazer o mesmo cálculo no futuro.</p>
<h5><a class="header" href="#variável-global" id="variável-global">variável global</a></h5>
<p>    Variável definida fora de uma função. As variáveis globais podem ser acessadas de qualquer função.</p>
<h5><a class="header" href="#instrução-global" id="instrução-global">instrução global</a></h5>
<p>    Instrução que declara um nome de variável global.</p>
<h5><a class="header" href="#flag" id="flag">flag</a></h5>
<p>    Variável booleana usada para indicar se uma condição é verdadeira.</p>
<h5><a class="header" href="#declaração" id="declaração">declaração</a></h5>
<p>    Instrução tal como global, que diz ao interpretador algo a respeito de uma variável.</p>
<h2><a class="header" href="#1110---exercícios" id="1110---exercícios">11.10 - Exercícios</a></h2>
<h3><a class="header" href="#exercício-111" id="exercício-111">Exercício 11.1</a></h3>
<p>Escreva uma função que leia as palavras em words.txt e guarde-as como chaves em um <a href="11-dicionarios/09-glossario.html#dicion%C3%A1rio">dicionário</a>. Não importa quais são os valores. Então você pode usar o operador in como uma forma rápida de verificar se uma string está no dicionário.</p>
<p>Se fez o Exercício 10.10, você pode comparar a velocidade desta <a href="11-dicionarios/09-glossario.html#implementa%C3%A7%C3%A3o">implementação</a> com o operador in de listas e a <a href="11-dicionarios/09-glossario.html#busca">busca</a> por bisseção.</p>
<h3><a class="header" href="#exercício-112" id="exercício-112">Exercício 11.2</a></h3>
<p>Leia a documentação do método de dicionário setdefault e use-o para escrever uma versão mais concisa de invert_dict.</p>
<p>Solução: <a href="http://thinkpython2.com/code/invert_dict.py">http://thinkpython2.com/code/invert_dict.py</a>.</p>
<h3><a class="header" href="#exercício-113" id="exercício-113">Exercício 11.3</a></h3>
<p>Memorize a função de Ackermann do Exercício 6.2 e veja se a memorização permite avaliar a função com argumentos maiores. Dica: não.</p>
<p>Solução: <a href="http://thinkpython2.com/code/ackermann_memo.py">http://thinkpython2.com/code/ackermann_memo.py</a>.</p>
<h3><a class="header" href="#exercício-114" id="exercício-114">Exercício 11.4</a></h3>
<p>Se fez o Exercício 10.7, você já tem uma função chamada has_duplicates, que recebe uma lista como parâmetro e retorna True se houver algum objeto que aparece mais de uma vez na lista.</p>
<p>Use um dicionário para escrever uma versão mais rápida e simples de has_duplicates.</p>
<p>Solução: <a href="http://thinkpython2.com/code/has_duplicates.py">http://thinkpython2.com/code/has_duplicates.py</a>.</p>
<h3><a class="header" href="#exercício-115" id="exercício-115">Exercício 11.5</a></h3>
<p>Duas palavras são “pares rotacionados” se for possível rotacionar um deles e chegar ao outro (ver <code>rotate_word</code> no Exercício 8.5).</p>
<p>Escreva um programa que leia uma lista de palavras e encontre todos os pares rotacionados.</p>
<p>Solução: <a href="http://thinkpython2.com/code/rotate_pairs.py">http://thinkpython2.com/code/rotate_pairs.py</a>.</p>
<h3><a class="header" href="#exercício-116" id="exercício-116">Exercício 11.6</a></h3>
<p>Aqui está outro quebra-cabeça do programa Car Talk (<a href="http://www.cartalk.com/content/puzzlers">http://www.cartalk.com/content/puzzlers</a>):</p>
<p>Ele foi enviado por Dan O’Leary. Dan descobriu uma palavra comum, com uma sílaba e cinco letras que tem a seguinte propriedade única. Ao removermos a primeira letra, as letras restantes formam um homófono da palavra original, que é uma palavra que soa exatamente da mesma forma. Substitua a primeira letra, isto é, coloque-a de volta, retire a segunda letra e o resultado é um outro homófono da palavra original. E a pergunta é, qual é a palavra?</p>
<p>Agora vou dar um exemplo que não funciona. Vamos usar a palavra de cinco letras, ‘wrack’ (mover, eliminar). W-R-A-C-K, como na expressão ‘wrack with pain’ (se contorcer de dor). Se eu retirar a primeira letra, sobra uma palavra de quatro letras, ‘R-A-C-K’ (galhada). Como na frase, ‘Holy cow, did you see the rack on that buck! It must have been a nine-pointer!’ (‘Minha nossa, você viu a galhada daquele cervo! Deve ter nove pontas!’). É um homófono perfeito. Se puser o ‘w’ de volta e retirar o ‘r’ em vez disso, sobra a palavra ‘wack’, que é uma palavra de verdade, mas não é um homófono das outras duas palavras.</p>
<p>Mas há pelo menos uma palavra que Dan e eu conhecemos, que produz dois homófonos se você retirar qualquer uma das duas primeiras letras, e duas novas palavras de quatro letras são formadas. A pergunta é, qual é a palavra?</p>
<p>Você pode usar o dicionário do Exercício 11.1 para verificar se uma string está na lista de palavras.</p>
<p>Para verificar se duas palavras são homófonas, você pode usar o Dicionário de pronúncia CMU. Ele pode ser baixado em <a href="http://www.speech.cs.cmu.edu/cgi-bin/cmudict">http://www.speech.cs.cmu.edu/cgi-bin/cmudict</a> ou em <a href="http://thinkpython2.com/code/c06d">http://thinkpython2.com/code/c06d</a>. Você também pode baixar <a href="http://thinkpython2.com/code/pronounce.py">http://thinkpython2.com/code/pronounce.py</a>, que tem uma função chamada <code>read_dictionary</code>, que lê o dicionário de pronúncia e retorna um dicionário de Python que mapeia cada palavra a uma string que descreve sua pronúncia primária.</p>
<p>Escreva um programa que liste todas as palavras que resolvem o quebra-cabeça.</p>
<p>Solução: <a href="http://thinkpython2.com/code/homophone.py">http://thinkpython2.com/code/homophone.py</a>.</p>
<h1><a class="header" href="#capítulo-12-tuplas" id="capítulo-12-tuplas">Capítulo 12: Tuplas</a></h1>
<p>Este capítulo apresenta mais um tipo integrado, a <a href="12-tuplas/09-glossario.html#tupla">tupla</a>, e descreve como as listas, os dicionários e as tuplas trabalham juntos. Além disso, apresento um recurso útil para listas de argumentos de comprimento variável: os operadores <a href="12-tuplas/09-glossario.html#gather">gather</a> e <a href="12-tuplas/09-glossario.html#scatter">scatter</a>.</p>
<p>Uma observação: não há consenso sobre como pronunciar “tuple” (em inglês). Algumas pessoas dizem “tuhple”, que rima com “supple”. Porém, no contexto da programação, a maioria das pessoas diz “too-ple”, que rima com “quadruple”.</p>
<h2><a class="header" href="#121---tuplas-são-imutáveis" id="121---tuplas-são-imutáveis">12.1 - Tuplas são imutáveis</a></h2>
<p>Uma <a href="12-tuplas/09-glossario.html#tupla">tupla</a> é uma sequência de valores. Os valores podem ser de qualquer tipo, e podem ser indexados por números inteiros, portanto, nesse sentido, as tuplas são muito parecidas com as listas. A diferença importante é que as tuplas são imutáveis.</p>
<p>Sintaticamente, uma tupla é uma lista de valores separados por vírgulas:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = 'a', 'b', 'c', 'd', 'e'
</code></pre>
<p>Embora não seja sempre necessário, é comum colocar tuplas entre parênteses:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = ('a', 'b', 'c', 'd', 'e')
</code></pre>
<p>Para criar uma tupla com um único elemento, é preciso incluir uma vírgula final:</p>
<pre><code class="language-python">&gt;&gt;&gt; t1 = 'a',
&gt;&gt;&gt; type(t1)
&lt;class 'tuple'&gt;
</code></pre>
<p>Um único valor entre parênteses não é uma tupla:</p>
<pre><code class="language-python">&gt;&gt;&gt; t2 = ('a')
&gt;&gt;&gt; type(t2)
&lt;class 'str'&gt;
</code></pre>
<p>Outra forma de criar uma tupla é com a função integrada <code>tuple</code>. Sem argumentos, cria uma tupla vazia:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = tuple()
&gt;&gt;&gt; t
()
</code></pre>
<p>Se os argumentos forem uma sequência (string, lista ou tupla), o resultado é uma tupla com os elementos da sequência:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = tuple('lupins')
&gt;&gt;&gt; t
('l', 'u', 'p', 'i', 'n', 's')
</code></pre>
<p>Como <code>tuple</code> é o nome de uma função integrada, você deve evitar usá-lo como nome de variável.</p>
<p>A maior parte dos operadores de lista também funciona em tuplas. O operador de colchetes indexa um elemento:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = ('a', 'b', 'c', 'd', 'e')
&gt;&gt;&gt; t[0]
'a'
</code></pre>
<p>E o operador de fatia seleciona vários elementos:</p>
<pre><code class="language-python">&gt;&gt;&gt; t[1:3]
('b', 'c')
</code></pre>
<p>Entretanto, se tentar alterar um dos elementos da tupla, vai receber um erro:</p>
<pre><code class="language-python">&gt;&gt;&gt; t[0] = 'A'
TypeError: object doesn't support item assignment
</code></pre>
<p>Como tuplas são imutáveis, você não pode alterar os elementos, mas pode substituir uma tupla por outra:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = ('A') + t[1:]
&gt;&gt;&gt; t
('A', 'b', 'c', 'd', 'e')
</code></pre>
<p>Essa instrução faz uma nova tupla e então a atribui a <code>t</code>.</p>
<p>Os operadores relacionais funcionam com tuplas e outras sequências; o Python começa comparando o primeiro elemento de cada sequência. Se forem iguais, vai para os próximos elementos, e assim por diante, até que encontre elementos que sejam diferentes. Os elementos subsequentes não são considerados (mesmo se forem muito grandes).</p>
<pre><code class="language-python">&gt;&gt;&gt; (0, 1, 2) &lt; (0, 3, 4)
True
&gt;&gt;&gt; (0, 1, 2000000) &lt; (0, 3, 4)
True
</code></pre>
<h2><a class="header" href="#122---atribuição-de-tuplas" id="122---atribuição-de-tuplas">12.2 - Atribuição de tuplas</a></h2>
<p>Muitas vezes, é útil trocar os valores de duas variáveis. Com a atribuição convencional, é preciso usar uma variável temporária. Por exemplo, trocar a e b.</p>
<pre><code class="language-python">&gt;&gt;&gt; temp = a
&gt;&gt;&gt; a = b
&gt;&gt;&gt; b = temp
</code></pre>
<p>Essa solução é trabalhosa; a atribuição de tuplas é mais elegante:</p>
<pre><code class="language-python">&gt;&gt;&gt; a, b = b, a
</code></pre>
<p>O lado esquerdo é uma <a href="12-tuplas/09-glossario.html#tupla">tupla</a> de variáveis; o lado direito é uma tupla de expressões. Cada valor é atribuído à sua respectiva variável. Todas as expressões no lado direito são avaliadas antes de todas as atribuições.</p>
<p>O número de variáveis à esquerda e o número de valores à direita precisam ser iguais:</p>
<pre><code class="language-python">&gt;&gt;&gt; a, b = 1, 2, 3
ValueError: too many values to unpack
</code></pre>
<p>De forma geral, o lado direito pode ter qualquer tipo de sequência (string, lista ou tupla). Por exemplo, para dividir um endereço de email em um nome de usuário e um domínio, você poderia escrever:</p>
<pre><code class="language-python">&gt;&gt;&gt; addr = 'monty@python.org'
&gt;&gt;&gt; uname, domain = addr.split('@')
</code></pre>
<p>O valor de retorno do <code>split</code> é uma lista com dois elementos; o primeiro elemento é atribuído a <code>uname</code>, o segundo a <code>domain</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; uname
'monty'
&gt;&gt;&gt; domain
'python.org'
</code></pre>
<h2><a class="header" href="#123---tuplas-como-valores-de-retorno" id="123---tuplas-como-valores-de-retorno">12.3 - Tuplas como valores de retorno</a></h2>
<p>Falando estritamente, uma função só pode retornar um valor, mas se o valor for uma <a href="12-tuplas/09-glossario.html#tupla">tupla</a>, o efeito é o mesmo que retornar valores múltiplos. Por exemplo, se você quiser dividir dois números inteiros e calcular o quociente e resto, não é eficiente calcular x/y e depois x%y. É melhor calcular ambos ao mesmo tempo.</p>
<p>A função integrada divmod toma dois argumentos e devolve uma tupla de dois valores: o quociente e o resto. Você pode guardar o resultado como uma tupla:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = divmod(7, 3)
&gt;&gt;&gt; t
(2, 1)
</code></pre>
<p>Ou usar a atribuição de tuplas para guardar os elementos separadamente:</p>
<pre><code class="language-python">&gt;&gt;&gt; quot, rem = divmod(7, 3)
&gt;&gt;&gt; quot
2
&gt;&gt;&gt; rem
1
</code></pre>
<p>Aqui está um exemplo de função que retorna uma tupla:</p>
<pre><code class="language-python">def min_max(t):
    return min(t), max(t)
</code></pre>
<p><code>max</code> e <code>min</code> são funções integradas que encontram os maiores e menores elementos de uma sequência. <code>min_max</code> calcula ambos e retorna uma tupla de dois valores.</p>
<h2><a class="header" href="#124---tuplas-com-argumentos-de-comprimento-variável" id="124---tuplas-com-argumentos-de-comprimento-variável">12.4 - Tuplas com argumentos de comprimento variável</a></h2>
<p>As funções podem receber um número variável de argumentos. Um nome de parâmetro que comece com <code>*</code> reúne vários argumentos em uma <a href="12-tuplas/09-glossario.html#tupla">tupla</a>. Por exemplo, <code>printall</code> recebe qualquer número de argumentos e os exibe:</p>
<pre><code class="language-python">def printall(*args):
    print(args)
</code></pre>
<p>O parâmetro com o prefixo <code>*</code> pode ter qualquer nome que você goste, mas <code>args</code> é o convencional. É assim que a função funciona:</p>
<pre><code class="language-python">&gt;&gt;&gt; printall(1, 2.0, '3')
(1, 2.0, '3')
</code></pre>
<p>O complemento de reunir é espalhar. Se você tiver uma sequência de valores e quiser passá-la a uma função como argumentos múltiplos, pode usar o operador <code>*</code>. Por exemplo, o <code>divmod</code> recebe exatamente dois argumentos; ele não funciona com uma tupla:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = (7, 3)
&gt;&gt;&gt; divmod(t)
TypeError: divmod expected 2 arguments, got 1
</code></pre>
<p>No entanto, se você espalhar a tupla, aí funciona:</p>
<pre><code class="language-python">&gt;&gt;&gt; divmod(*t)
(2, 1)
</code></pre>
<p>Muitas das funções integradas usam tuplas com argumentos de comprimento variável. Por exemplo, <code>max</code> e <code>min</code> podem receber qualquer número de argumentos:</p>
<pre><code class="language-python">&gt;&gt;&gt; max(1, 2, 3)
3
</code></pre>
<p>Mas sum, não:</p>
<pre><code class="language-python">&gt;&gt;&gt; sum(1, 2, 3)
TypeError: sum expected at most 2 arguments, got 3
</code></pre>
<p>Como exercício, escreva uma função chamada <code>sumall</code> que receba qualquer número de argumentos e retorne a soma deles.</p>
<h2><a class="header" href="#125---listas-e-tuplas" id="125---listas-e-tuplas">12.5 - Listas e tuplas</a></h2>
<p><code>zip</code> é uma função integrada que recebe duas ou mais sequências e devolve uma lista de tuplas onde cada <a href="12-tuplas/09-glossario.html#tupla">tupla</a> contém um elemento de cada sequência. O nome da função tem a ver com o zíper, que se junta e encaixa duas carreiras de dentes.</p>
<p>Este exemplo encaixa uma string e uma lista:</p>
<pre><code class="language-python">&gt;&gt;&gt; s = 'abc'
&gt;&gt;&gt; t = [0, 1, 2]
&gt;&gt;&gt; zip(s, t)
&lt;zip object at 0x7f7d0a9e7c48&gt;
</code></pre>
<p>O resultado é um objeto <code>zip</code> que sabe como percorrer os pares. O uso mais comum de <code>zip</code> é em um loop <code>for</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; for pair in zip(s, t):
...     print(pair)
...
('a', 0)
('b', 1)
('c', 2)
</code></pre>
<p>Um objeto <code>zip</code> é um tipo de <a href="12-tuplas/09-glossario.html#iterador">iterador</a>, ou seja, qualquer objeto que percorre ou itera sobre uma sequência. Iteradores são semelhantes a listas em alguns aspectos, mas, ao contrário de listas, não é possível usar um índice para selecionar um elemento de um iterador.</p>
<p>Se quiser usar operadores e métodos de lista, você pode usar um objeto <code>zip</code> para fazer uma lista:</p>
<pre><code class="language-python">&gt;&gt;&gt; list(zip(s, t))
[('a', 0), ('b', 1), ('c', 2)]
</code></pre>
<p>O resultado é uma lista de tuplas; neste exemplo, cada tupla contém um caractere da string e o elemento correspondente da lista.</p>
<p>Se as sequências não forem do mesmo comprimento, o resultado tem o comprimento da mais curta:</p>
<pre><code class="language-python">&gt;&gt;&gt; list(zip('Anne', 'Elk'))
[('A', 'E'), ('n', 'l'), ('n', 'k')]
</code></pre>
<p>Você pode usar a atribuição de tuplas em um loop for para atravessar uma lista de tuplas:</p>
<pre><code class="language-python">t = [('a', 0), ('b', 1), ('c', 2)]
for letter, number in t:
    print(number, letter)
</code></pre>
<p>Cada vez que o programa passa pelo loop, o Python seleciona a próxima tupla na lista e atribui os elementos letter e number. A saída deste loop é:</p>
<pre><code class="language-python">0 a
1 b
2 c
</code></pre>
<p>Se combinar <code>zip</code>, <code>for</code> e atribuição de tuplas, você pode fazer uma expressão útil para percorrer duas (ou mais) sequências ao mesmo tempo. Por exemplo, <code>has_match</code> recebe duas sequências, <code>t1</code> e <code>t2</code> e retorna <code>True</code> se houver um índice <code>i</code> tal que <code>t1[i] == t2[i]</code>:</p>
<pre><code class="language-python">def has_match(t1, t2):
    for x, y in zip(t1, t2):
        if x == y:
            return True
    return False
</code></pre>
<p>Se precisar atravessar os elementos de uma sequência e seus índices, você pode usar a função integrada <code>enumerate</code>:</p>
<pre><code class="language-python">for index, element in enumerate('abc'):
    print(index, element)
</code></pre>
<p>O resultado de <code>enumerate</code> é um objeto <code>enumerate</code>, que itera sobre uma sequência de pares; cada par contém um índice (começando de 0) e um elemento da sequência dada. Neste exemplo, a saída é</p>
<pre><code class="language-python">0 a
1 b
2 c
</code></pre>
<p>De novo.</p>
<h2><a class="header" href="#126---dicionários-e-tuplas" id="126---dicionários-e-tuplas">12.6 - Dicionários e tuplas</a></h2>
<p>Os dicionários têm um método chamado <code>items</code> que devolve uma sequência de tuplas, onde cada <a href="12-tuplas/09-glossario.html#tupla">tupla</a> é um par chave-valor:</p>
<pre><code class="language-python">&gt;&gt;&gt; d = {'a':0, 'b':1, 'c':2}
&gt;&gt;&gt; t = d.items()
&gt;&gt;&gt; t
dict_items([('c', 2), ('a', 0), ('b', 1)])
</code></pre>
<p>O resultado é um objeto <code>dict_items</code>, que é um <a href="12-tuplas/09-glossario.html#iterador">iterador</a> que percorre os pares chave-valor. Você pode usá-lo em um loop <code>for</code>, desta forma:</p>
<pre><code class="language-python">&gt;&gt;&gt; for key, value in d.items():
...     print(key, value)
...
c 2
a 0
b 1
</code></pre>
<p>Como se poderia esperar de um dicionário, os itens não estão em nenhuma ordem em particular.</p>
<p>Indo em outra direção, você pode usar uma lista de tuplas para inicializar um novo dicionário:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = [('a', 0), ('c', 2), ('b', 1)]
&gt;&gt;&gt; d = dict(t)
&gt;&gt;&gt; d
{'a': 0, 'c': 2, 'b': 1}
</code></pre>
<p>Combinar <code>dict</code> com <code>zip</code> produz uma forma concisa de criar um dicionário:</p>
<pre><code class="language-python">&gt;&gt;&gt; d = dict(zip('abc', range(3)))
&gt;&gt;&gt; d
{'a': 0, 'c': 2, 'b': 1}
</code></pre>
<p>O método de dicionário <code>update</code> também recebe uma lista de tuplas e as adiciona, como pares chave-valor, a um dicionário existente.</p>
<p>É comum usar tuplas como chaves em dicionários (principalmente porque você não pode usar listas). Por exemplo, uma lista telefônica poderia mapear pares de sobrenome e primeiro nome a números de telefone. Supondo que tenhamos definido last, first e number, podemos escrever:</p>
<pre><code class="language-python">directory[last, first] = number
</code></pre>
<p>A expressão entre chaves é uma tupla. Podemos usar atribuição de tuplas para atravessar este dicionário:</p>
<pre><code class="language-python">for last, first in directory:
    print(first, last, directory[last,first])
</code></pre>
<p>Este loop atravessa as chaves em directory, que são tuplas. Ele atribui os elementos de cada tupla para <code>last</code> e <code>first</code>, e então exibe o nome e número de telefone correspondente.</p>
<p>Há duas formas de representar tuplas em um diagrama de estado. A versão mais detalhada mostra os índices e elementos como aparecem em uma lista. Por exemplo, a tupla ('Cleese', 'John') apareceria como na Figura 12.1.</p>
<p><img src="12-tuplas//fig/tnkp_1201.png" alt="Figura 12.1 – Diagrama de estado de uma tupla" />.
<br><em>Figura 12.1 – Diagrama de estado de uma tupla.</em></p>
<p>No entanto, em um diagrama maior, você pode querer omitir os detalhes. Por exemplo, um diagrama da lista telefônica poderia ser como o da Figura 12.2.</p>
<p><img src="12-tuplas//fig/tnkp_1202.png" alt="Figura 12.2 – Diagrama de estado de um dicionário com chaves do tipo tupla" />.
<br><em>Figura 12.2 – Diagrama de estado de um dicionário com chaves do tipo tupla.</em></p>
<p>Aqui as tuplas são mostradas usando a sintaxe do Python para simplificar o gráfico. O número de telefone no diagrama é a linha de reclamações da BBC, então, por favor, não ligue para lá.</p>
<h2><a class="header" href="#127---sequências-de-sequências" id="127---sequências-de-sequências">12.7 - Sequências de sequências</a></h2>
<p>Eu me concentrei em listas de tuplas, mas quase todos os exemplos neste capítulo também funcionam com listas de listas, tuplas de tuplas e tuplas de listas. Para evitar enumerar as combinações possíveis, às vezes é mais fácil falar sobre sequências de sequências.</p>
<p>Em muitos contextos, os tipos diferentes de sequências (strings, listas e tuplas) podem ser usados de forma intercambiável. Então, como escolher uma em vez da outra?</p>
<p>Para começar com o óbvio, as strings são mais limitadas que outras sequências porque os elementos têm de ser caracteres. Também são imutáveis. Se precisar da capacidade de alterar caracteres em uma string (em vez de criar outra string) você pode querer usar uma lista de caracteres.</p>
<p>As listas são mais comuns que as tuplas, principalmente porque são mutáveis. Mas há alguns casos em que você pode preferir tuplas:</p>
<ol>
<li>
<p>Em alguns contextos, como em uma instrução <code>return</code>, é sintaticamente mais simples criar uma <a href="12-tuplas/09-glossario.html#tupla">tupla</a> que uma lista.</p>
</li>
<li>
<p>Se quiser usar uma sequência como uma chave de dicionário, é preciso usar um tipo imutável como uma tupla ou string.</p>
</li>
<li>
<p>Se estiver passando uma sequência como um argumento a uma função, usar tuplas reduz o potencial de comportamento inesperado devido a alias.</p>
</li>
</ol>
<p>Como tuplas são imutáveis, elas não fornecem métodos como <code>sort</code> e <code>reverse</code>, que alteram listas existentes. Porém, o Python fornece a função integrada <code>sorted</code>, que recebe qualquer sequência e retorna uma nova lista com os mesmos elementos ordenados, e <code>reversed</code>, que recebe uma sequência e retorna um <a href="12-tuplas/09-glossario.html#iterador">iterador</a> que percorre a lista em ordem reversa.</p>
<h2><a class="header" href="#128---depuração" id="128---depuração">12.8 - Depuração</a></h2>
<p>As listas, os dicionários e as tuplas são exemplos de estruturas de dados; neste capítulo estamos começando a ver estruturas de dados compostas, como as listas de tuplas ou dicionários que contêm tuplas como chaves e listas como valores. As estruturas de dados compostas são úteis, mas são propensas ao que chamo de erros de forma; isto é, erros causados quando uma <a href="12-tuplas/09-glossario.html#estrutura-de-dados">estrutura de dados</a> tem o tipo, tamanho ou estrutura incorretos. Por exemplo, se você estiver esperando uma lista com um número inteiro e eu der apenas o número inteiro (não em uma lista), não vai funcionar.</p>
<p>Para ajudar a depurar esses tipos de erro, escrevi um módulo chamado <code>structshape</code>, que fornece uma função, também chamada <code>structshape</code>, que recebe qualquer tipo de estrutura de dados como argumento e retorna uma string, que resume sua forma. Você pode baixá-la em <a href="http://thinkpython2.com/code/structshape.py">http://thinkpython2.com/code/structshape.py</a>.</p>
<p>Aqui está o resultado de uma lista simples:</p>
<pre><code class="language-python">&gt;&gt;&gt; from structshape import structshape
&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; structshape(t)
'list of 3 int'
</code></pre>
<p>Um programa mais sofisticado pode escrever “list of 3 ints”, mas é mais fácil não lidar com plurais. Aqui está uma lista de listas:</p>
<pre><code class="language-python">&gt;&gt;&gt; t2 = [[1,2], [3,4], [5,6]]
&gt;&gt;&gt; structshape(t2)
'list of 3 list of 2 int'
</code></pre>
<p>Se os elementos da lista não forem do mesmo tipo, <code>structshape</code> os agrupa, na ordem, por tipo:</p>
<pre><code class="language-python">&gt;&gt;&gt; t3 = [1, 2, 3, 4.0, '5', '6', [7], [8], 9]
&gt;&gt;&gt; structshape(t3)
'list of (3 int, float, 2 str, 2 list of int, int)'
</code></pre>
<p>Aqui está uma lista de tuplas:</p>
<pre><code class="language-python">&gt;&gt;&gt; s = 'abc'
&gt;&gt;&gt; lt = list(zip(t, s))
&gt;&gt;&gt; structshape(lt)
'list of 3 tuple of (int, str)'
</code></pre>
<p>E aqui está um dicionário com três itens que mapeia números inteiros a strings:</p>
<pre><code class="language-python">&gt;&gt;&gt; d = dict(lt)
&gt;&gt;&gt; structshape(d)
'dict of 3 int-&gt;str'
</code></pre>
<p>Se estiver com problemas para monitorar suas estruturas de dados, o <code>structshape</code> pode ajudar.</p>
<h2><a class="header" href="#129---glossário" id="129---glossário">12.9 - Glossário</a></h2>
<h5><a class="header" href="#tupla" id="tupla">tupla</a></h5>
<p>    Sequência imutável de elementos.</p>
<h5><a class="header" href="#atribuição-de-tupla" id="atribuição-de-tupla">atribuição de tupla</a></h5>
<p>    Atribuição com uma sequência no lado direito e uma tupla de variáveis à esquerda. O lado direito é avaliado e então seus elementos são atribuídos às variáveis à esquerda.</p>
<h5><a class="header" href="#gather" id="gather">gather</a></h5>
<p>    Operação para montar uma tupla com argumento de comprimento variável.</p>
<h5><a class="header" href="#scatter" id="scatter">scatter</a></h5>
<p>    Operação para tratar uma sequência como uma lista de argumentos.</p>
<h5><a class="header" href="#objeto-zip" id="objeto-zip">objeto zip</a></h5>
<p>    O resultado de chamar uma função integrada zip; um objeto que se repete por uma sequência de tuplas.</p>
<h5><a class="header" href="#iterador" id="iterador">iterador</a></h5>
<p>    Objeto que pode se repetir por uma sequência, mas que não oferece operadores de lista e métodos.</p>
<h5><a class="header" href="#estrutura-de-dados" id="estrutura-de-dados">estrutura de dados</a></h5>
<p>    Coleção de valores relacionados, muitas vezes organizados em listas, dicionários, tuplas etc.</p>
<h5><a class="header" href="#erro-de-forma" id="erro-de-forma">erro de forma</a></h5>
<p>    Erro causado pelo fato de o valor ter a forma incorreta; isto é, tipo ou tamanho incorreto.</p>
<h2><a class="header" href="#1210---exercícios" id="1210---exercícios">12.10 - Exercícios</a></h2>
<h3><a class="header" href="#exercício-121" id="exercício-121">Exercício 12.1</a></h3>
<p>Escreva uma função chamada <code>most_frequent</code> que receba uma string e exiba as letras em ordem decrescente de frequência. Encontre amostras de texto de vários idiomas diferentes e veja como a frequência das letras varia entre os idiomas. Compare seus resultados com as tabelas em <a href="http://en.wikipedia.org/wiki/Letter_frequencies">http://en.wikipedia.org/wiki/Letter_frequencies</a>.</p>
<p>Solução: <a href="http://thinkpython2.com/code/most_frequent.py">http://thinkpython2.com/code/most_frequent.py</a>.</p>
<h3><a class="header" href="#exercício-122" id="exercício-122">Exercício 12.2</a></h3>
<p>Mais anagramas!</p>
<ol>
<li>Escreva um programa que leia uma lista de palavras de um arquivo (veja “Leitura de listas de palavras”, na página 133) e imprima todos os conjuntos de palavras que são anagramas.</li>
</ol>
<p>        Aqui está um exemplo de como a saída pode parecer:</p>
<pre><code class="language-python">        ['deltas', 'desalt', 'lasted', 'salted', 'slated', 'staled']
        ['retainers', 'ternaries']
        ['generating', 'greatening']
        ['resmelts', 'smelters', 'termless']
</code></pre>
<p>        Dica: você pode querer construir um dicionário que mapeie uma coleção de letras a uma lista de palavras que podem ser soletradas com essas letras. A pergunta é: como representar a coleção de letras de forma que possa ser usada como uma chave?</p>
<ol start="2">
<li>
<p>Altere o programa anterior para que exiba a lista mais longa de anagramas primeiro, seguido pela segunda mais longa, e assim por diante.</p>
</li>
<li>
<p>No Scrabble, um “bingo” é quando você joga todas as sete peças na sua estante, junto com uma peça no tabuleiro, para formar uma palavra de oito letras. Que coleção de oito letras forma o maior número possível de bingos? Dica: há sete.</p>
</li>
</ol>
<p>Solução: <a href="http://thinkpython2.com/code/anagram_sets.py">http://thinkpython2.com/code/anagram_sets.py</a>.</p>
<h3><a class="header" href="#exercício-123" id="exercício-123">Exercício 12.3</a></h3>
<p>Duas palavras formam um “par de metátese” se você puder transformar uma na outra trocando duas letras, por exemplo, “converse” e “conserve”. Escreva um programa que descubra todos os pares de metátese no dicionário. Dica: não teste todos os pares de palavras e não teste todas as trocas possíveis.</p>
<p>Solução: <a href="http://thinkpython2.com/code/metathesis.py">http://thinkpython2.com/code/metathesis.py</a>. Crédito: este exercício foi inspirado por um exemplo em <a href="http://puzzlers.org">http://puzzlers.org</a>.</p>
<h3><a class="header" href="#exercício-124" id="exercício-124">Exercício 12.4</a></h3>
<p>Aqui está outro quebra-cabeça do programa Car Talk (<a href="http://www.cartalk.com/content/puzzlers">http://www.cartalk.com/content/puzzlers</a>):</p>
<p>Qual é a palavra inglesa mais longa, que permanece uma palavra inglesa válida, conforme vai removendo suas letras, uma após a outra?</p>
<p>Agora, as letras podem ser retiradas do fim ou do meio, mas você não pode reajustar nenhuma delas. Cada vez que remove uma letra, você acaba com outra palavra inglesa. Se fizer isto, eventualmente você acabará com uma letra e isso também será uma palavra inglesa; uma encontrada no dicionário. Quero saber qual é a palavra mais longa e quantas letras tem?</p>
<p>Vou dar um pequeno exemplo modesto: Sprite. Ok? Você começa com sprite, tira uma letra do interior da palavra, tira o r, e ficamos com a palavra spite, então tiramos o e do fim, ficamos com spit, tiramos o s, ficamos com pit, it e I.</p>
<p>Escreva um programa que encontre todas as palavras que podem ser reduzidas desta forma, e então encontre a mais longa.</p>
<p>Este exercício é um pouco mais desafiador que a maioria, então aqui estão algumas sugestões:</p>
<ol>
<li>
<p>Você pode querer escrever uma função que receba uma palavra e calcule uma lista de todas as palavras que podem ser formadas retirando uma letra. Esses são os “filhos” da palavra.</p>
</li>
<li>
<p>Recursivamente, uma palavra é redutível se algum de seus filhos for redutível. Como caso base, você pode considerar a string vazia redutível.</p>
</li>
<li>
<p>A lista de palavras que forneci, words.txt, não contém palavras de uma letra só. Portanto, você pode querer acrescentar “I”, “a”, e a string vazia.</p>
</li>
<li>
<p>Para melhorar o desempenho do seu programa, você pode querer memorizar as palavras conhecidas por serem redutíveis.</p>
</li>
</ol>
<p>Solução: <a href="http://thinkpython2.com/code/reducible.py">http://thinkpython2.com/code/reducible.py</a>.</p>
<h1><a class="header" href="#capítulo-13-estudo-de-caso-seleção-de-estrutura-de-dados" id="capítulo-13-estudo-de-caso-seleção-de-estrutura-de-dados">Capítulo 13: Estudo de caso: seleção de estrutura de dados</a></h1>
<p>Neste ponto você já aprendeu sobre as principais estruturas de dados do Python, e viu alguns algoritmos que as usam. Se quiser saber mais sobre algoritmos, pode ler o Capítulo 21. Mas isso não é necessário para continuar, pode lê-lo a qualquer momento em que tenha interesse.</p>
<p>Este capítulo apresenta um estudo de caso com exercícios que fazem pensar sobre a escolha de estruturas de dados e práticas de uso delas.</p>
<h2><a class="header" href="#131---análise-de-frequência-de-palavras" id="131---análise-de-frequência-de-palavras">13.1 - Análise de frequência de palavras</a></h2>
<p>Como de hábito, você deve pelo menos tentar fazer os exercícios antes de ler as minhas soluções.</p>
<h3><a class="header" href="#exercício-131" id="exercício-131">Exercício 13.1</a></h3>
<p>Escreva um programa que leia um arquivo, quebre cada linha em palavras, remova os espaços em branco e a pontuação das palavras, e as converta em letras minúsculas.</p>
<p>Dica: O módulo <code>string</code> oferece uma string chamada <code>whitespace</code>, que contém espaço, tab, newline etc., e <code>punctuation</code>, que contém os caracteres de pontuação. Vamos ver se conseguimos fazer o Python falar palavrões:</p>
<pre><code class="language-python">&gt;&gt;&gt; import string
&gt;&gt;&gt; string.punctuation
'!&quot;#$%&amp;\'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~'
</code></pre>
<p>Além disso, você pode usar os métodos de string, strip, replace e translate.</p>
<h3><a class="header" href="#exercício-132" id="exercício-132">Exercício 13.2</a></h3>
<p>Acesse o Projeto Gutenberg (<a href="https://gutenberg.org">https://gutenberg.org</a>) e baixe seu livro favorito em domínio público em formato de texto simples.</p>
<p>Altere seu programa do exercício anterior para ler o livro que você baixou, pulando as informações do cabeçalho no início do arquivo e processando o resto das palavras como antes.</p>
<p>Então altere o programa para contar o número total de palavras no livro e o número de vezes que cada palavra é usada.</p>
<p>Exiba o número de palavras diferentes usadas no livro. Compare livros diferentes de autores diferentes, escritos em eras diferentes. Que autor usa o vocabulário mais extenso?</p>
<h3><a class="header" href="#exercício-133" id="exercício-133">Exercício 13.3</a></h3>
<p>Altere o programa do exercício anterior para exibir as 20 palavras mais frequentes do livro.</p>
<h3><a class="header" href="#exercício-134" id="exercício-134">Exercício 13.4</a></h3>
<p>Altere o programa anterior para ler uma lista de palavras (ver “Leitura de listas de palavras”, na página 133) e então exiba todas as palavras do livro que não estão na lista de palavras. Quantas delas são erros ortográficos? Quantas delas são palavras comuns que deveriam estar na lista de palavras, e quantas são muito obscuras?</p>
<h2><a class="header" href="#132---números-aleatórios" id="132---números-aleatórios">13.2 - Números aleatórios</a></h2>
<p>Com as mesmas entradas, a maior parte dos programas gera as mesmas saídas a cada vez, então eles são chamados de deterministas. Determinismo normalmente é uma coisa boa, já que esperamos que o mesmo cálculo produza o mesmo resultado. Para algumas aplicações, entretanto, queremos que o computador seja imprevisível. Os jogos são um exemplo óbvio, mas há outros.</p>
<p>Fazer um programa não <a href="13-estudo-de-caso-selecao-de-estrutura-de-dados/11-glossario.html#determinista">determinista</a> de verdade é difícil; mas há formas de, pelo menos, fazê-los parecer que não são. Uma delas é usar algoritmos que geram números pseudoaleatórios. Os números pseudoaleatórios não são aleatórios mesmo porque são gerados por um cálculo determinista, mas é quase impossível distingui-los dos aleatórios só olhando para os números.</p>
<p>O módulo random fornece funções que geram números pseudoaleatórios (que chamarei apenas de “aleatórios” daqui em diante).</p>
<p>A função random retorna um número de ponto flutuante entre 0,0 e 1,0 (incluindo 0,0, mas não 1,0). Cada vez que random é chamada, você recebe o próximo número em uma longa série. Para ver uma amostra, execute este loop:</p>
<pre><code class="language-python">import random
for i in range(10):
    x = random.random()
    print(x)
</code></pre>
<p>A função <code>randint</code> recebe os parâmetros <code>low</code> e <code>high</code> e retorna um número inteiro entre <code>low</code> e <code>high</code> (inclusive ambos):</p>
<pre><code class="language-python">&gt;&gt;&gt; random.randint(5, 10)
5
&gt;&gt;&gt; random.randint(5, 10)
9
</code></pre>
<p>Para escolher aleatoriamente um elemento de uma sequência, você pode usar choice:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; random.choice(t)
2
&gt;&gt;&gt; random.choice(t)
3
</code></pre>
<p>O módulo random também fornece funções para gerar valores aleatórios de distribuições contínuas, incluindo gaussianas, exponenciais, gamma e algumas outras.</p>
<h3><a class="header" href="#exercício-135" id="exercício-135">Exercício 13.5</a></h3>
<p>Escreva uma função chamada <code>choose_from_hist</code> que receba um histograma como definido em “Um dicionário como uma coleção de contadores”, na página 163, e retorne um valor aleatório do histograma, escolhido por probabilidade em proporção à frequência. Por exemplo, para este histograma:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = ['a', 'a', 'b']
&gt;&gt;&gt; hist = histogram(t)
&gt;&gt;&gt; hist
{'a': 2, 'b': 1}
</code></pre>
<p>sua função deve retornar 'a' com a probabilidade de 2/3 e 'b' com a probabilidade 1/3.</p>
<h2><a class="header" href="#133---histograma-de-palavras" id="133---histograma-de-palavras">13.3 - Histograma de palavras</a></h2>
<p>É uma boa ideia tentar fazer os exercícios anteriores antes de continuar. Você pode baixar minha solução em <a href="http://thinkpython2.com/code/analyze_book1.py">http://thinkpython2.com/code/analyze_book1.py</a>. Também vai precisar de <a href="http://thinkpython2.com/code/emma.txt">http://thinkpython2.com/code/emma.txt</a>.</p>
<p>Aqui está um programa que lê um arquivo e constrói um histograma das palavras no arquivo:</p>
<pre><code class="language-python">import string

def process_file(filename):
    hist = dict()
    fp = open(filename)
    for line in fp:
        process_line(line, hist)
    return hist

def process_line(line, hist):
    line = line.replace('-', ' ')
    for word in line.split():
        word = word.strip(string.punctuation + string.whitespace)
        word = word.lower()
        hist[word] = hist.get(word, 0) + 1

hist = process_file('emma.txt')
</code></pre>
<p>Este programa lê <code>emma.txt</code>, que contém o texto de <em>Emma</em>, de Jane Austen.</p>
<p><code>process_file</code> faz o loop pelas linhas do arquivo, passando-as uma a uma para <code>process_line</code>. O histograma hist está sendo usado como um acumulador.</p>
<p><code>process_line</code> usa o método de string replace para substituir hifens por espaços antes de usar split para quebrar a linha em uma lista de strings. Ele atravessa a lista de palavras e usa strip e lower para retirar a pontuação e converter tudo em letras minúsculas. (Dizer que as strings “são convertidas” é uma forma simples de explicar a coisa; lembre-se de que as strings são imutáveis, então métodos como strip e lower retornam novas strings)</p>
<p>Finalmente, <code>process_line</code> atualiza o histograma, criando um novo item ou incrementando um existente.</p>
<p>Para contar o número total de palavras no arquivo, podemos somar as frequências no histograma:</p>
<pre><code class="language-python">def total_words(hist):
    return sum(hist.values())
</code></pre>
<p>O número de palavras diferentes é somente o número de itens no dicionário:</p>
<pre><code class="language-python">def different_words(hist):
    return len(hist)
</code></pre>
<p>Aqui está o código para exibir os resultados:</p>
<pre><code class="language-python">print('Total number of words:', total_words(hist))
print('Number of different words:', different_words(hist))
</code></pre>
<p>E os resultados:</p>
<pre><code class="language-python">Total number of words: 161080
Number of different words: 7214
</code></pre>
<h2><a class="header" href="#134---palavras-mais-comuns" id="134---palavras-mais-comuns">13.4 - Palavras mais comuns</a></h2>
<p>Para encontrar as palavras mais comuns, podemos fazer uma lista de tuplas, onde cada tupla contenha uma palavra e a sua frequência, e ordenar a lista.</p>
<p>A função seguinte recebe um histograma e retorna uma lista de tuplas de palavras e frequências:</p>
<pre><code class="language-python">def most_common(hist):
    t = []
    for key, value in hist.items():
        t.append((value, key))
    t.sort(reverse=True)
    return t
</code></pre>
<p>Em cada tupla, a frequência aparece primeiro, então a lista resultante é ordenada por frequência. Aqui está um loop que imprime as 10 palavras mais comuns:</p>
<pre><code class="language-python">t = most_common(hist)
print('The most common words are:')
for freq, word in t[:10]:
    print(word, freq, sep='\\t')
</code></pre>
<p>Uso o argumento de palavra-chave <code>sep</code> para que <code>print</code> use um caractere <code>tab</code> como separador, em vez de um espaço, assim a segunda coluna fica alinhada verticalmente. Aqui estão os resultados de Emma:</p>
<pre><code>The most common words are:
to      5242
the     5205
and     4897
of      4295
i       3191
a       3130
it      2529
her     2483
was     2400
she     2364
</code></pre>
<p>Este código pode ser simplificado usando o parâmetro <code>key</code> da função <code>sort</code>. Se tiver curiosidade, pode ler sobre ele em <a href="https://wiki.python.org/moin/HowTo/Sorting">https://wiki.python.org/moin/HowTo/Sorting</a>.</p>
<h2><a class="header" href="#135---parâmetros-opcionais" id="135---parâmetros-opcionais">13.5 - Parâmetros opcionais</a></h2>
<p>Vimos funções integradas e métodos que recebem argumentos opcionais. É possível escrever funções definidas pelos programadores com argumentos opcionais, também. Por exemplo, aqui está uma função que exibe as palavras mais comuns em um histograma:</p>
<pre><code class="language-python">def print_most_common(hist, num=10):
    t = most_common(hist)
    print('The most common words are:')
    for freq, word in t[:num]:
        print(word, freq, sep='\\t')
</code></pre>
<p>O primeiro parâmetro é necessário; o segundo é opcional. O <a href="13-estudo-de-caso-selecao-de-estrutura-de-dados/11-glossario.html#valor-padr%C3%A3o">valor padrão</a> de <code>num</code> é 10.</p>
<p>Se você só fornecer um argumento:</p>
<pre><code class="language-python">print_most_common(hist)
</code></pre>
<p>num recebe o valor padrão. Se fornecer dois argumentos:</p>
<pre><code class="language-python">print_most_common(hist, 20)
</code></pre>
<p>num recebe o valor do argumento em vez disso. Em outras palavras, o argumento opcional ignora o valor padrão.</p>
<p>Se uma função tem ambos os parâmetros obrigatório e opcional, todos os parâmetros necessários têm que vir primeiro, seguidos pelos opcionais.</p>
<h2><a class="header" href="#136---subtração-de-dicionário" id="136---subtração-de-dicionário">13.6 - Subtração de dicionário</a></h2>
<p>Encontrar as palavras do livro que não estão na lista de palavras de words.txt é um problema que você pode reconhecer como subtração de conjuntos; isto é, queremos encontrar todas as palavras de um conjunto (as palavras no livro) que não estão no outro (as palavras na lista).</p>
<p><code>subtract</code> recebe os dicionários <code>d1</code> e <code>d2</code> e devolve um novo dicionário que contém todas as chaves de <code>d1</code> que não estão em <code>d2</code>. Como não nos preocupamos com os valores, estabelecemos todos como <code>None</code>:</p>
<pre><code class="language-python">def subtract(d1, d2):
    res = dict()
    for key in d1:
        if key not in d2:
            res[key] = None
    return res
</code></pre>
<p>Para encontrar as palavras no livro que não estão em words.txt, podemos usar <code>process_file</code> para construir um histograma para words.txt, e então subtrair:</p>
<pre><code class="language-python">words = process_file('words.txt')
diff = subtract(hist, words)
print(&quot;Words in the book that aren't in the word list:&quot;)
for word in diff:
    print(word, end=' ')
</code></pre>
<p>Aqui estão alguns resultados de Emma:</p>
<pre><code>Words in the book that aren't in the word list:
rencontre jane's blanche woodhouses disingenuousness
friend's venice apartment ...
</code></pre>
<p>Algumas dessas palavras são nomes e possessivos. Os outros, como “rencontre”, já não são de uso comum. Mas algumas são palavras comuns que realmente deveriam estar na lista!</p>
<h3><a class="header" href="#exercício-136" id="exercício-136">Exercício 13.6</a></h3>
<p>O Python fornece uma estrutura de dados chamada <code>set</code>, que fornece muitas operações de conjunto. Você pode ler sobre elas em “Conjuntos”, na página 274, ou ler a documentação em <a href="http://docs.python.org/3/library/stdtypes.html#types-set">http://docs.python.org/3/library/stdtypes.html#types-set</a>.</p>
<p>Escreva um programa que use a subtração de conjuntos para encontrar palavras no livro que não estão na lista de palavras.</p>
<p>Solução: <a href="http://thinkpython2.com/code/analyze_book2.py">http://thinkpython2.com/code/analyze_book2.py</a>.</p>
<h2><a class="header" href="#137---palavras-aleatórias" id="137---palavras-aleatórias">13.7 - Palavras aleatórias</a></h2>
<p>Para escolher uma palavra aleatória do histograma, o algoritmo mais simples é construir uma lista com várias cópias de cada palavra, segundo a frequência observada, e então escolher da lista:</p>
<pre><code class="language-python">def random_word(h):
    t = []
    for word, freq in h.items():
        t.extend([word] * freq)
    return random.choice(t)
</code></pre>
<p>A expressão <code>[word] * freq</code> cria uma lista com <code>freq</code> cópias da string <code>word</code>. O método <code>extend</code> é similar a <code>append</code>, exceto pelo argumento, que é uma sequência.</p>
<p>Esse algoritmo funciona, mas não é muito eficiente; cada vez que você escolhe uma palavra aleatória, ele reconstrói a lista, que é tão grande quanto o livro original. Uma melhoria óbvia é construir a lista uma vez e então fazer seleções múltiplas, mas a lista ainda é grande.</p>
<p>Uma alternativa é:</p>
<ol>
<li>
<p>Usar <code>keys</code> para conseguir uma lista das palavras no livro.</p>
</li>
<li>
<p>Construir uma lista que contenha a soma cumulativa das frequências das palavras (veja o Exercício 10.2). O último item desta lista é o número total de palavras no livro, n.</p>
</li>
<li>
<p>Escolher um número aleatório de 1 a n. Use uma pesquisa de bisseção (veja o Exercício 10.10) para encontrar o índice onde o número aleatório seria inserido na soma cumulativa.</p>
</li>
<li>
<p>Usar o índice para encontrar a palavra correspondente na lista de palavras.</p>
</li>
</ol>
<h3><a class="header" href="#exercício-137" id="exercício-137">Exercício 13.7</a></h3>
<p>Escreva um programa que use este algoritmo para escolher uma palavra aleatória do livro.</p>
<p>Solução: <a href="http://thinkpython2.com/code/analyze_book3.py">http://thinkpython2.com/code/analyze_book3.py</a>.</p>
<h2><a class="header" href="#138---análise-de-markov" id="138---análise-de-markov">13.8 - Análise de Markov</a></h2>
<p>Se escolher palavras do livro aleatoriamente, você pode até captar certo sentido a partir do vocabulário, mas provavelmente não vai conseguir uma sentença completa:</p>
<pre><code>this the small regard harriet which knightley's it most things
</code></pre>
<p>Uma série de palavras aleatórias raramente faz sentido porque não há nenhuma relação entre palavras sucessivas. Por exemplo, em uma sentença de verdade você esperaria que um artigo como “o” fosse seguido de um adjetivo ou um substantivo, e provavelmente não um verbo ou advérbio.</p>
<p>Uma forma de medir estes tipos de relações é a análise de Markov, que caracteriza, para uma dada sequência de palavras, o que poderia vir a seguir, segundo a probabilidade. Por exemplo, a canção “Eric, the Half a Bee” começa assim:</p>
<pre><code class="language-python">Half a bee, philosophically,
Must, ipso facto, half not be.
But half the bee has got to be
Vis a vis, its entity. D’you see?
But can a bee be said to be
Or not to be an entire bee
When half the bee is not a bee
Due to some ancient injury?
</code></pre>
<p>Nesse texto, a frase “half the” sempre é seguida pela palavra “bee”, mas a frase “the bee” pode ser seguida por “has” ou “is”.</p>
<p>O resultado da análise de Markov é um mapeamento de cada prefixo (como “half the” e “the bee”) a todos os sufixos possíveis (como “has” e “is”).</p>
<p>Com este mapeamento você pode gerar um texto aleatório, começando com qualquer prefixo e escolhendo a esmo entre os sufixos possíveis. Em seguida, você pode combinar o fim do prefixo e o novo sufixo para formar o próximo prefixo e repetir.</p>
<p>Por exemplo, se você começar com o prefixo “Half a”, então a próxima palavra tem que ser “bee”, porque o prefixo só aparece uma vez no texto. O prefixo seguinte é “a bee”, então o próximo sufixo poderia ser “philosophically”, “be” ou “due”.</p>
<p>Neste exemplo, o comprimento do prefixo é sempre dois, mas você pode fazer a análise de Markov com qualquer comprimento de prefixo.</p>
<h3><a class="header" href="#exercício-138" id="exercício-138">Exercício 13.8</a></h3>
<p>Análise de Markov:</p>
<p><strong>a)</strong> Escreva um programa que leia o texto de um arquivo e execute a análise de Markov. O resultado deve ser um dicionário que mapeie prefixos a uma coleção de possíveis sufixos. A coleção pode ser uma lista, tupla ou dicionário; você é que deverá fazer a escolha adequada. Você pode testar seu programa com um comprimento de prefixo 2, mas deve escrever o programa de forma que seja fácil testar outros comprimentos.</p>
<p><strong>b)</strong> Acrescente uma função ao programa anterior para gerar texto aleatório baseado na análise de Markov. Aqui está um exemplo de exemplo de <em>Emma</em> com o comprimento de prefixo 2.</p>
<blockquote>
<p>He was very clever, be it sweetness or be angry, ashamed or only amused, at such a stroke. She had never thought of Hannah till you were never meant for me?” “I cannot make speeches, Emma:” he soon cut it all himself.</p>
</blockquote>
<p>Para este exemplo, deixei a pontuação anexada às palavras. O resultado é quase sintaticamente correto, mas não exatamente. Semanticamente, quase faz sentido, mas não exatamente.</p>
<p>O que acontece se você aumentar o comprimento dos prefixos? O texto aleatório faz mais sentido?</p>
<p><strong>c)</strong> Uma vez que o seu programa esteja funcionando, você pode querer tentar uma mistura: se combinar o texto de dois ou mais livros, o texto aleatório gerado misturará o vocabulário e frases das fontes de formas  interessantes.</p>
<p>Crédito: este estudo de caso é baseado em um exemplo de Kernighan and Pike, The Practice of Programming, Addison-Wesley, 1999.</p>
<p>É uma boa ideia tentar fazer este exercício antes de continuar; depois você pode baixar a minha solução em <a href="http://thinkpython2.com/code/markov.py">http://thinkpython2.com/code/markov.py</a>. Também vai precisar de <a href="http://thinkpython2.com/code/emma.txt">http://thinkpython2.com/code/emma.txt</a>.</p>
<h2><a class="header" href="#139---estruturas-de-dados" id="139---estruturas-de-dados">13.9 - Estruturas de dados</a></h2>
<p>Usar análise de Markov para gerar o texto aleatório é divertido, mas também há uma razão para este exercício: a seleção da estrutura de dados. Na sua solução para os exercícios anteriores, você teve que selecionar:</p>
<ul>
<li>
<p>como representar os prefixos;</p>
</li>
<li>
<p>como representar a coleção de sufixos possíveis;</p>
</li>
<li>
<p>como representar o mapeamento de cada prefixo à coleção de possíveis sufixos.</p>
</li>
</ul>
<p>O último é fácil: um dicionário é a escolha óbvia para um mapeamento de chaves a valores correspondentes.</p>
<p>Para os prefixos, as opções mais óbvias são strings, listas de strings ou tuplas de strings.</p>
<p>Para os sufixos, uma opção é uma lista; outra é um histograma (dicionário).</p>
<p>Como você deve escolher? O primeiro passo é pensar nas operações que você vai precisar implementar para cada estrutura de dados. Para os prefixos, é preciso poder retirar palavras do começo e acrescentar no fim. Por exemplo, se o prefixo atual é “Half a” e a próxima palavra é “bee”, você tem que poder formar o próximo prefixo, “a bee”.</p>
<p>Sua primeira escolha pode ser uma lista, pois é fácil acrescentar e retirar elementos, mas também precisamos poder usar os prefixos como chaves em um dicionário, para excluir listas. Com tuplas, você não pode acrescentar ou retirar, mas pode usar o operador de adição para formar uma nova tupla:</p>
<pre><code class="language-python">def shift(prefix, word):
    return prefix[1:] + (word)
</code></pre>
<p><code>shift</code> recebe uma tupla de palavras, prefix, e uma string, word, e forma uma nova tupla que tem todas as palavras em prefix, exceto a primeira e word adicionada no final.</p>
<p>Para a coleção de sufixos, as operações que precisamos executar incluem a soma de um novo sufixo (ou aumento da frequência de um existente), e a escolha de um sufixo aleatório.</p>
<p>Acrescentar um novo sufixo é igualmente fácil para a implementação da lista ou do histograma. Escolher um elemento aleatório de uma lista é fácil; escolher de um histograma é mais difícil de fazer de forma eficiente (ver o Exercício 13.7).</p>
<p>Por enquanto, falamos principalmente sobre a facilidade de implementação, mas há outros fatores a considerar na escolha das estruturas de dados. Um deles é o tempo de execução. Às vezes, há uma razão teórica para esperar que uma estrutura de dados seja mais rápida que outra; por exemplo, eu mencionei que o operador in é mais rápido para dicionários que para listas, pelo menos quando o número de elementos é grande.</p>
<p>Porém, muitas vezes não se sabe de antemão qual implementação será mais rápida. Uma opção é implementar ambas e ver qual é melhor. Esta abordagem é chamada de <a href="13-estudo-de-caso-selecao-de-estrutura-de-dados/11-glossario.html#benchmarking">benchmarking</a>. Uma alternativa prática é escolher a estrutura de dados mais fácil para implementar, e então ver se é rápida o suficiente para a aplicação desejada. Se for o caso, não é preciso continuar. Do contrário, há ferramentas, como o módulo profile, que podem identificar os lugares em um programa que tomam mais tempo de execução.</p>
<p>Outro fator a considerar é o espaço de armazenamento. Por exemplo, usar um histograma para a coleção de sufixos pode tomar menos espaço porque só é preciso armazenar cada palavra uma vez, não importa quantas vezes apareça no texto. Em alguns casos, a economia de espaço também pode fazer o seu programa rodar mais rápido e, em casos extremos, seu programa pode simplesmente nem rodar se ficar sem memória. Porém, para muitas aplicações, o espaço é uma consideração secundária depois do tempo de execução.</p>
<p>Um último comentário: nessa discussão, a ideia implícita é que devemos usar uma estrutura de dados tanto para análise como para geração. Entretanto, como essas fases são separadas, também seria possível usar uma estrutura para a análise e então convertê-la em outra estrutura para a geração. Isso seria uma vantagem se o tempo poupado durante a geração excedesse o tempo decorrido na conversão.</p>
<h2><a class="header" href="#1310---depuração" id="1310---depuração">13.10 - Depuração</a></h2>
<p>Quando estiver depurando um programa, especialmente se estiver trabalhando em um erro difícil, há cinco coisas que você pode tentar:</p>
<h5><a class="header" href="#leitura" id="leitura">Leitura</a></h5>
<p>    Examine seu código, leia-o para você mesmo e verifique se diz o que você pensou em dizer.</p>
<h5><a class="header" href="#execução" id="execução">Execução</a></h5>
<p>    Experimente fazer alterações e executar versões diferentes. Muitas vezes, ao se expor a coisa certa no lugar certo do programa, o problema fica óbvio, mas pode ser necessário construir o scaffolding.</p>
<h5><a class="header" href="#ruminação" id="ruminação">Ruminação</a></h5>
<p>    Pense por algum tempo! Qual é o tipo do erro: de sintaxe, de tempo de execução ou semântico? Quais informações você consegue obter a partir das mensagens de erro, ou da saída do programa? Que tipo de erro pode causar o problema que está vendo? O que você mudou por último, antes que o problema aparecesse?</p>
<h5><a class="header" href="#conversa-com-o-pato-de-borracha-rubberducking" id="conversa-com-o-pato-de-borracha-rubberducking">Conversa com o pato de borracha (rubberducking)</a></h5>
<p>    Ao explicar o problema a alguém, às vezes você consegue encontrar a resposta antes de terminar a explicação. Muitas vezes, não é preciso nem haver outra pessoa; você pode falar até com um pato de borracha. E essa é a origem de uma estratégia bem conhecida chamada de <a href="13-estudo-de-caso-selecao-de-estrutura-de-dados/11-glossario.html#depura%C3%A7%C3%A3o-do-pato-de-borracha">depuração do pato de borracha</a>. Não estou inventando isso, veja <a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging.">https://en.wikipedia.org/wiki/Rubber_duck_debugging.</dd></a></p>
<h5><a class="header" href="#retirada" id="retirada">Retirada</a></h5>
<p>    Em um determinado ponto, a melhor coisa a fazer é voltar atrás e desfazer as alterações recentes, até chegar de volta a um programa que funcione e que você entenda. Então você pode começar a reconstruir.</p>
<p>Programadores iniciantes às vezes ficam presos em uma dessas atividades e esquecem das outras. Cada atividade vem com o seu próprio modo de falha.</p>
<p>Por exemplo, a leitura do seu código pode ajudar se o problema é um erro tipográfico, mas não se o problema for conceitual. Se você não entende o que o seu programa faz, pode lê-lo cem vezes e nunca verá o erro, porque o erro está na sua cabeça.</p>
<p>Fazer experiências pode ajudar, especialmente se você executar testes pequenos e simples. No entanto, se executar experiências sem pensar ou ler seu código, pode cair em um padrão que chamo de “programação aleatória”, que é o processo de fazer alterações aleatórias até que o programa faça a coisa certa. Obviamente, a programação aleatória pode levar muito tempo.</p>
<p>É preciso pensar um pouco. A depuração é como ciência experimental. Deve haver pelo menos uma hipótese sobre qual é o problema. Se houver duas ou mais possibilidades, tente pensar em um teste que eliminaria uma delas.</p>
<p>Não obstante, até as melhores técnicas de depuração falharão se houver erros demais, ou se o código que está tentando corrigir for grande e complicado demais. Às vezes, a melhor opção é voltar atrás, simplificando o programa até chegar a algo que funcione e que você entenda.</p>
<p>Programadores iniciantes muitas vezes relutam em voltar atrás porque não suportam a ideia de eliminar sequer uma linha de código (mesmo se estiver errada). Para você se sentir melhor, copie seu programa em outro arquivo antes de começar a desmontá-lo. Então você pode copiar as partes de volta, uma a uma.</p>
<p>Encontrar um erro difícil exige leitura, execução, ruminação, e, às vezes, a retirada. Se empacar em alguma dessas atividades, tente as outras.</p>
<h2><a class="header" href="#1311---glossário" id="1311---glossário">13.11 - Glossário</a></h2>
<h5><a class="header" href="#determinista" id="determinista">determinista</a></h5>
<p>    Relativo a um programa que faz a mesma coisa cada vez que é executado, se receber as mesmas entradas.</p>
<h5><a class="header" href="#pseudoaleatório" id="pseudoaleatório">pseudoaleatório</a></h5>
<p>    Relativo a uma sequência de números que parecem ser aleatórios, mas que são gerados por um programa determinista.</p>
<h5><a class="header" href="#valor-padrão" id="valor-padrão">valor padrão</a></h5>
<p>    Valor dado a um parâmetro opcional se não houver nenhum argumento.</p>
<h5><a class="header" href="#ignorar-override" id="ignorar-override">ignorar (override)</a></h5>
<p>    Substituir um valor padrão por um argumento.</p>
<h5><a class="header" href="#benchmarking" id="benchmarking">benchmarking</a></h5>
<p>    Processo de escolha entre estruturas de dados pela implementação de alternativas e testes em uma amostra de entradas possíveis.</p>
<h5><a class="header" href="#depuração-do-pato-de-borracha" id="depuração-do-pato-de-borracha">depuração do pato de borracha</a></h5>
<p>    Depurar explicando o problema a um objeto inanimado como um pato de borracha. Articular o problema pode ajudar a resolvê-lo, mesmo se o pato de borracha não conhecer Python.</p>
<h2><a class="header" href="#1312---exercícios" id="1312---exercícios">13.12 - Exercícios</a></h2>
<h3><a class="header" href="#exercício-139" id="exercício-139">Exercício 13.9</a></h3>
<p>A “classificação” de uma palavra é a sua posição em uma lista de palavras classificadas por frequência: a palavra mais comum tem a classificação 1, a segunda mais comum é 2 etc.</p>
<p>A lei de Zipf descreve a relação entre classificações e frequências das palavras em linguagens naturais (http://en.wikipedia.org/wiki/Zipf's_law). Ela prevê especificamente que a frequência, f, da palavra com classificação r é:</p>
<pre><code class="language-python">f = cr−s
</code></pre>
<p>onde s e c são parâmetros que dependem do idioma e do texto. Se você tomar o logaritmo de ambos os lados desta equação, obtém:</p>
<pre><code class="language-python">log f = log c − s log r
</code></pre>
<p>Se você traçar o log de f contra o log de r, terá uma linha reta com uma elevação -s e interceptar o log de c.</p>
<p>Escreva um programa que leia um texto em um arquivo, conte as frequências das palavras e exiba uma linha para cada palavra, em ordem descendente da frequência, com log de f e log de r. Use o programa gráfico de sua escolha para traçar os resultados e verifique se formam uma linha reta. Você pode estimar o valor de s?</p>
<p>Solução: <a href="http://thinkpython2.com/code/zipf.py">http://thinkpython2.com/code/zipf.py</a>. Para executar a minha solução, você vai precisar do módulo de gráficos <code>matplotlib</code>. Se você instalou o Anaconda, já tem o <code>matplotlib</code>; se não tiver, é preciso instalá-lo.</p>
<h1><a class="header" href="#capítulo-14-arquivos" id="capítulo-14-arquivos">Capítulo 14: Arquivos</a></h1>
<p>Este capítulo apresenta a ideia de programas “persistentes”, que mantêm dados em armazenamento permanente, e mostra como usar tipos diferentes de armazenamento permanente, como arquivos e bancos de dados.</p>
<h2><a class="header" href="#141---persistência" id="141---persistência">14.1 - Persistência</a></h2>
<p>A maioria dos programas que vimos até agora são transitórios, porque são executados por algum tempo e produzem alguma saída, mas, quando terminam, seus dados desaparecem. Se executar o programa novamente, ele começa novamente do zero.</p>
<p>Outros programas são persistentes: rodam por muito tempo (ou todo o tempo); mantêm pelo menos alguns dos seus dados em armazenamento permanente (uma unidade de disco rígido, por exemplo); e se são desligados e reiniciados, continuam de onde pararam.</p>
<p>Exemplos de programas persistentes são sistemas operacionais, que rodam praticamente durante todo o tempo em que um computador está ligado, e servidores web, que rodam todo o tempo, esperando pedidos de entrada na rede.</p>
<p>Uma das formas mais simples para programas manterem seus dados é lendo e escrevendo arquivos de texto. Já vimos programas que leem arquivos de texto; neste capítulo veremos programas que os escrevem.</p>
<p>Uma alternativa é armazenar o estado do programa em um <a href="14-arquivos/11-glossario.html#banco-de-dados">banco de dados</a>. Neste capítulo apresentarei um banco de dados simples e um módulo, pickle, que facilita o armazenamento de dados de programas.</p>
<h2><a class="header" href="#142---leitura-e-escrita" id="142---leitura-e-escrita">14.2 - Leitura e escrita</a></h2>
<p>Um <a href="14-arquivos/11-glossario.html#arquivo-de-texto">arquivo de texto</a> é uma sequência de caracteres armazenados em um meio permanente como uma unidade de disco rígido, pendrive ou CD-ROM. Vimos como abrir e ler um arquivo em “Leitura de listas de palavras” na página 133.</p>
<p>Para escrever um arquivo texto, é preciso abri-lo com o modo <code>'w'</code> como segundo parâmetro:</p>
<pre><code class="language-python">&gt;&gt;&gt; fout = open('output.txt', 'w')
</code></pre>
<p>Se o arquivo já existe, abri-lo em modo de escrita elimina os dados antigos e começa tudo de novo, então tenha cuidado! Se o arquivo não existir, é criado um arquivo novo.</p>
<p><code>open</code> retorna um objeto de arquivo que fornece métodos para trabalhar com o arquivo. O método write põe dados no arquivo:</p>
<pre><code class="language-python">&gt;&gt;&gt; line1 = &quot;This here's the wattle,\n&quot;
&gt;&gt;&gt; fout.write(line1)
24
</code></pre>
<p>O valor devolvido é o número de caracteres que foram escritos. O objeto de arquivo monitora a posição em que está, então se você chamar <code>write</code> novamente, os novos dados são acrescentados ao fim do arquivo:</p>
<pre><code class="language-python">&gt;&gt;&gt; line2 = &quot;the emblem of our land.\n&quot;
&gt;&gt;&gt; fout.write(line2)
24
</code></pre>
<p>Ao terminar de escrever, você deve fechar o arquivo:</p>
<pre><code class="language-python">&gt;&gt;&gt; fout.close()
</code></pre>
<p>Se não fechar o arquivo, ele é fechado para você quando o programa termina.</p>
<h2><a class="header" href="#143---operador-de-formatação" id="143---operador-de-formatação">14.3 - Operador de formatação</a></h2>
<p>O argumento de <code>write</code> tem que ser uma string, então, se quisermos inserir outros valores em um arquivo, precisamos convertê-los em strings. O modo mais fácil de fazer isso é com <code>str</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = 52
&gt;&gt;&gt; fout.write(str(x))
</code></pre>
<p>Uma alternativa é usar o <a href="14-arquivos/11-glossario.html#operador-de-formata%C3%A7%C3%A3o">operador de formatação</a>, <code>%</code>. Quando aplicado a números inteiros, <code>%</code> é o operador de módulo. No entanto, quando o primeiro operando é uma string, <code>%</code> é o operador de formatação.</p>
<p>O primeiro operando é a <a href="14-arquivos/11-glossario.html#string-de-formata%C3%A7%C3%A3o">string de formatação</a>, que contém uma ou várias sequências de formatação que especificam como o segundo operando deve ser formatado. O resultado é uma string.</p>
<p>Por exemplo, a <a href="14-arquivos/11-glossario.html#sequ%C3%AAncia-de-formata%C3%A7%C3%A3o">sequência de formatação</a> '%d' significa que o segundo operando deve ser formatado como um número inteiro decimal:</p>
<pre><code class="language-python">&gt;&gt;&gt; camels = 42
&gt;&gt;&gt; '%d' % camels
'42'
</code></pre>
<p>O resultado é a string <code>'42'</code>, que não deve ser confundida com o valor inteiro <code>42</code>.</p>
<p>Uma sequência de formatação pode aparecer em qualquer lugar na string, então você pode embutir um valor em uma sentença:</p>
<pre><code class="language-python">&gt;&gt;&gt; 'I have spotted %d camels.' % camels
'I have spotted 42 camels.'
</code></pre>
<p>Se houver mais de uma sequência de formatação na string, o segundo argumento tem que ser uma tupla. Cada sequência de formatação é combinada com um elemento da tupla, nesta ordem.</p>
<p>O seguinte exemplo usa <code>'%d'</code> para formatar um número inteiro, <code>'%g'</code> para formatar um número de ponto flutuante e <code>'%s'</code> para formatar qualquer objeto como uma string:</p>
<pre><code class="language-python">&gt;&gt;&gt; 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')
'In 3 years I have spotted 0.1 camels.'
</code></pre>
<p>O número de elementos na tupla tem de corresponder ao número de sequências de formatação na string. Além disso, os tipos dos elementos têm de corresponder às sequências de formatação:</p>
<pre><code class="language-python">&gt;&gt;&gt; '%d %d %d' % (1, 2)
TypeError: not enough arguments for format string
&gt;&gt;&gt; '%d' % 'dollars'
TypeError: %d format: a number is required, not str
</code></pre>
<p>No primeiro exemplo não há elementos suficientes; no segundo, o elemento é do tipo incorreto.</p>
<p>Para obter mais informações sobre o operador de formato, veja <a href="https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting">https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting</a>. Você pode ler sobre uma alternativa mais eficiente, o método de formatação de strings, em <a href="https://docs.python.org/3/library/stdtypes.html#str.format">https://docs.python.org/3/library/stdtypes.html#str.format</a>.</p>
<h2><a class="header" href="#144---nomes-de-arquivo-e-caminhos" id="144---nomes-de-arquivo-e-caminhos">14.4 - Nomes de arquivo e caminhos</a></h2>
<p>Os arquivos são organizados em diretórios (também chamados de “pastas”). Cada programa em execução tem um “<a href="14-arquivos/11-glossario.html#diret%C3%B3rio">diretório</a> atual”, que é o diretório-padrão da maior parte das operações. Por exemplo, quando você abre um arquivo de leitura, Python o procura no diretório atual.</p>
<p>O módulo <code>os</code> fornece funções para trabalhar com arquivos e diretórios (“os” é a abreviação de “sistema operacional” em inglês). <code>os.getcwd</code> devolve o nome do diretório atual:</p>
<pre><code class="language-python">&gt;&gt;&gt; import os
&gt;&gt;&gt; cwd = os.getcwd()
&gt;&gt;&gt; cwd
'/home/dinsdale'
</code></pre>
<p><code>cwd</code> é a abreviação de “diretório de trabalho atual” em inglês. O resultado neste exemplo é <code>/home/dinsdale</code>, que é o diretório-padrão de um usuário chamado “dinsdale”.</p>
<p>Uma string como <code>'/home/dinsdale'</code>, que identifica um arquivo ou diretório, é chamada de <a href="14-arquivos/11-glossario.html#caminho">caminho</a> (path).</p>
<p>Um nome de arquivo simples, como <code>memo.txt</code>, também é considerado um caminho, mas é um <a href="14-arquivos/11-glossario.html#caminho-relativo">caminho relativo</a>, porque se relaciona ao diretório atual. Se o diretório atual é <code>/home/dinsdale</code>, o nome de arquivo <code>memo.txt</code> se referiria a <code>/home/dinsdale/memo.txt</code>.</p>
<p>Um caminho que começa com <code>/</code> não depende do diretório atual; isso é chamado de <a href="14-arquivos/11-glossario.html#caminho-absoluto">caminho absoluto</a>. Para encontrar o caminho absoluto para um arquivo, você pode usar <code>os.path.abspath</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; os.path.abspath('memo.txt')
'/home/dinsdale/memo.txt'
</code></pre>
<p><code>os.path</code> fornece outras funções para trabalhar com nomes de arquivo e caminhos. Por exemplo, <code>os.path.exists</code> que verifica se um arquivo ou diretório existe:</p>
<pre><code class="language-python">&gt;&gt;&gt; os.path.exists('memo.txt')
True
</code></pre>
<p>Se existir, <code>os.path.isdir</code> verifica se é um diretório:</p>
<pre><code class="language-python">&gt;&gt;&gt; os.path.isdir('memo.txt')
False
&gt;&gt;&gt; os.path.isdir('/home/dinsdale')
True
</code></pre>
<p>De forma similar, <code>os.path.isfile</code> verifica se é um arquivo.</p>
<p>os.listdir retorna uma lista dos arquivos (e outros diretórios) no diretório dado:</p>
<pre><code class="language-python"> &gt;&gt;&gt; os.listdir(cwd)
['music', 'photos', 'memo.txt']
</code></pre>
<p>Para demonstrar essas funções, o exemplo seguinte “passeia” por um diretório, exibe os nomes de todos os arquivos e chama a si mesmo recursivamente em todos os diretórios:</p>
<pre><code class="language-python">def walk(dirname):
    for name in os.listdir(dirname):
        path = os.path.join(dirname, name)
        if os.path.isfile(path):
            print(path)
        else:
            walk(path)
</code></pre>
<p><code>os.path.join</code> recebe um diretório e um nome de arquivo e os une em um caminho completo.</p>
<p>O módulo <code>os</code> fornece uma função chamada <code>walk</code>, que é semelhante, só que mais versátil. Como exercício, leia a documentação e use-a para exibir os nomes dos arquivos em um diretório dado e seus subdiretórios. Você pode baixar minha solução em <a href="http://thinkpython2.com/code/walk.py">http://thinkpython2.com/code/walk.py</a>.</p>
<h2><a class="header" href="#145---captura-de-exceções" id="145---captura-de-exceções">14.5 - Captura de exceções</a></h2>
<p>Muitas coisas podem dar errado quando você tenta ler e escrever arquivos. Se tentar abrir um arquivo que não existe, você recebe um <code>IOError</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; fin = open('bad_file')
IOError: [Errno 2] No such file or directory: 'bad\_file'
</code></pre>
<p>Se não tiver permissão para acessar um arquivo:</p>
<pre><code class="language-python">&gt;&gt;&gt; fout = open('/etc/passwd', 'w')
PermissionError: [Errno 13] Permission denied: '/etc/passwd'
</code></pre>
<p>E se tentar abrir um <a href="14-arquivos/11-glossario.html#diret%C3%B3rio">diretório</a> para leitura, recebe</p>
<pre><code class="language-python">&gt;&gt;&gt; fin = open('/home')
IsADirectoryError: [Errno 21] Is a directory: '/home'
</code></pre>
<p>Para evitar esses erros, você pode usar funções como <code>os.path.exists</code> e <code>os.path.isfile</code>, mas levaria muito tempo e código para verificar todas as possibilidades (se &quot;Errno 21&quot; significa algo, pode ser que pelo menos 21 coisas podem dar errado).</p>
<p>É melhor ir em frente e tentar, e lidar com problemas se eles surgirem, que é exatamente o que a instrução <code>try</code> faz. A sintaxe é semelhante à da instrução <code>if…else</code>:</p>
<pre><code class="language-python">try:
    fin = open('bad_file')
except:
    print('Something went wrong.')
</code></pre>
<p>O Python começa executando a cláusula <code>try</code>. Se tudo for bem, ele ignora a cláusula <code>except</code> e prossegue. Se ocorrer uma exceção, o programa sai da cláusula <code>try</code> e executa a cláusula <code>except</code>.</p>
<p>Lidar com exceções usando uma instrução <code>try</code> chama-se <a href="14-arquivos/11-glossario.html#capturar">capturar</a> uma exceção. Neste exemplo, a cláusula <code>except</code> exibe uma mensagem de erro que não é muito útil. Em geral, a captura de uma exceção oferece a oportunidade de corrigir o problema ou tentar novamente, ou, ao menos, de terminar o programa adequadamente.</p>
<h2><a class="header" href="#146---bancos-de-dados" id="146---bancos-de-dados">14.6 - Bancos de dados</a></h2>
<p>Um <a href="14-arquivos/11-glossario.html#banco-de-dados">banco de dados</a> é um arquivo organizado para armazenar dados. Muitos bancos de dados são organizados como um dicionário, porque mapeiam chaves a valores. A maior diferença entre um banco de dados e um dicionário é que o banco de dados está em um disco (ou outro armazenamento permanente), portanto persiste depois que o programa termina.</p>
<p>O módulo dbm fornece uma interface para criar e atualizar arquivos de banco de dados. Como exemplo, criarei um banco de dados que contém legendas de arquivos de imagem.</p>
<p>Abrir um banco de dados é semelhante à abertura de outros arquivos:</p>
<pre><code class="language-python">&gt;&gt;&gt; import dbm
&gt;&gt;&gt; db = dbm.open('captions', 'c')
</code></pre>
<p>O modo 'c' significa que o banco de dados deve ser criado, se ainda não existir. O resultado é um objeto de banco de dados que pode ser usado (para a maior parte das operações) como um dicionário.</p>
<p>Quando você cria um novo item, dbm atualiza o arquivo de banco de dados:</p>
<pre><code class="language-python">&gt;&gt;&gt; db['cleese.png'] = 'Photo of John Cleese.'
</code></pre>
<p>Quando você acessa um dos itens, dbm lê o arquivo:</p>
<pre><code class="language-python">&gt;&gt;&gt; db['cleese.png']
b'Photo of John Cleese.'
</code></pre>
<p>O resultado é um objeto <code>bytes</code>, o que explica o prefixo <code>b</code>. Um objeto <code>bytes</code> é semelhante a uma string, em muitos aspectos. Quando você avançar no Python, a diferença se tornará importante, mas, por enquanto, podemos ignorá-la.</p>
<p>Se fizer outra atribuição a uma chave existente, o dbm substitui o valor antigo:</p>
<pre><code class="language-python">&gt;&gt;&gt; db['cleese.png'] = 'Photo of John Cleese doing a silly walk.'
&gt;&gt;&gt; db['cleese.png']
b'Photo of John Cleese doing a silly walk.'
</code></pre>
<p>Alguns métodos de dicionário, como keys e items, não funcionam com objetos de banco de dados. No entanto, a iteração com um loop <code>for</code>, sim:</p>
<pre><code class="language-python">for key in db:
    print(key, db[key])
</code></pre>
<p>Como em outros arquivos, você deve fechar o banco de dados quando terminar:</p>
<pre><code class="language-python">&gt;&gt;&gt; db.close()
</code></pre>
<h2><a class="header" href="#147---usando-o-pickle" id="147---usando-o-pickle">14.7 - Usando o Pickle</a></h2>
<p>Uma limitação de <code>dbm</code> é que as chaves e os valores têm que ser strings ou bytes. Se tentar usar algum outro tipo, vai receber um erro.</p>
<p>O módulo <code>pickle</code> pode ajudar. Ele traduz quase qualquer tipo de objeto em uma string conveniente para o armazenamento em um <a href="14-arquivos/11-glossario.html#banco-de-dados">banco de dados</a>, e então traduz strings de volta em objetos.</p>
<p>pickle.dumps recebe um objeto como parâmetro e retorna uma representação de string:</p>
<pre><code class="language-python">&gt;&gt;&gt; import pickle
&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; pickle.dumps(t)
b'\x80\x03]q\x00(K\x01K\x02K\x03e.'
</code></pre>
<p>O formato não é óbvio para leitores humanos; o objetivo é que seja fácil para o <code>pickle</code> interpretar. <code>pickle.loads</code> reconstitui o objeto:</p>
<pre><code class="language-python">&gt;&gt;&gt; t1 = [1, 2, 3]
&gt;&gt;&gt; s = pickle.dumps(t1)
&gt;&gt;&gt; t2 = pickle.loads(s)
&gt;&gt;&gt; t2
[1, 2, 3]
</code></pre>
<p>Embora o novo objeto tenha o mesmo valor que o antigo, não é (em geral) o mesmo objeto:</p>
<pre><code class="language-python">&gt;&gt;&gt; t1 == t2
True
&gt;&gt;&gt; t1 is t2
False
</code></pre>
<p>Em outras palavras, usar o <code>pickle.dumps</code> e <code>pickle.loads</code> tem o mesmo efeito que copiar o objeto.</p>
<p>Você pode usar o <code>pickle</code> para guardar variáveis que não são strings em um banco de dados. Na verdade, esta combinação é tão comum que foi encapsulada em um módulo chamado <code>shelve</code>.</p>
<h2><a class="header" href="#148---pipes" id="148---pipes">14.8 - Pipes</a></h2>
<p>A maior parte dos sistemas operacionais fornece uma interface de linha de comando, conhecida como <a href="14-arquivos/11-glossario.html#shell">shell</a>. Shells normalmente fornecem comandos para navegar nos sistemas de arquivos e executar programas. Por exemplo, em Unix você pode alterar diretórios com <code>cd</code>, exibir o conteúdo de um <a href="14-arquivos/11-glossario.html#diret%C3%B3rio">diretório</a> com <code>ls</code> e abrir um navegador web digitando (por exemplo) <code>firefox</code>.</p>
<p>Qualquer programa que possa ser aberto no shell também pode ser aberto no Python usando um <a href="14-arquivos/11-glossario.html#objeto-pipe">objeto pipe</a>, que representa um programa em execução.</p>
<p>Por exemplo, o comando Unix <code>ls -l</code> normalmente exibe o conteúdo do diretório atual no formato longo. Você pode abrir ls com <code>os.popen[1]</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; cmd = 'ls -l'
&gt;&gt;&gt; fp = os.popen(cmd)
</code></pre>
<p>O argumento é uma string que contém um comando shell. O valor de retorno é um objeto que se comporta como um arquivo aberto. É possível ler a saída do processo ls uma linha por vez com readline ou receber tudo de uma vez com read:</p>
<pre><code class="language-python">&gt;&gt;&gt; res = fp.read()
</code></pre>
<p>Ao terminar, feche o pipe como se fosse um arquivo:</p>
<pre><code class="language-python">&gt;&gt;&gt; stat = fp.close()
&gt;&gt;&gt; print(stat)
None
</code></pre>
<p>O valor de retorno é o status final do processo <code>ls</code>; <code>None</code> significa que terminou normalmente (sem erros).</p>
<p>Por exemplo, a maior parte dos sistemas Unix oferece um comando chamado <code>md5sum</code>, que lê o conteúdo de um arquivo e calcula uma assinatura digital. Você pode ler sobre o MD5 em <a href="http://en.wikipedia.org/wiki/Md5">http://en.wikipedia.org/wiki/Md5</a>. Este comando fornece uma forma eficiente de verificar se dois arquivos têm o mesmo conteúdo. A probabilidade de dois conteúdos diferentes produzirem a mesma assinatura digital é muito pequena (isto é, muito pouco provável que aconteça antes do colapso do universo).</p>
<p>Você pode usar um pipe para executar o <code>md5sum</code> do Python e receber o resultado:</p>
<pre><code class="language-python">&gt;&gt;&gt; filename = 'book.tex'
&gt;&gt;&gt; cmd = 'md5sum ' + filename
&gt;&gt;&gt; fp = os.popen(cmd)
&gt;&gt;&gt; res = fp.read()
&gt;&gt;&gt; stat = fp.close()
&gt;&gt;&gt; print(res)
1e0033f0ed0656636de0d75144ba32e0 book.tex
&gt;&gt;&gt; print(stat)
None
</code></pre>
<h2><a class="header" href="#149---escrevendo-módulos" id="149---escrevendo-módulos">14.9 - Escrevendo módulos</a></h2>
<p>Qualquer arquivo que contenha código do Python pode ser importado como um módulo. Por exemplo, vamos supor que você tenha um arquivo chamado <code>wc.py</code> com o seguinte código:</p>
<pre><code class="language-python">def linecount(filename):
    count = 0
    for line in open(filename):
        count += 1
    return count

print(linecount('wc.py'))
</code></pre>
<p>Quando este programa é executado, ele lê a si mesmo e exibe o número de linhas no arquivo, que é 7. Você também pode importá-lo desta forma:</p>
<pre><code class="language-python">&gt;&gt;&gt; import wc
7
</code></pre>
<p>Agora você tem um objeto de módulo wc:</p>
<pre><code class="language-python">&gt;&gt;&gt; wc
&lt;module 'wc' from 'wc.py'&gt;
</code></pre>
<p>O objeto de módulo fornece o linecount:</p>
<pre><code class="language-python">&gt;&gt;&gt; wc.linecount('wc.py')
7
</code></pre>
<p>Então é assim que se escreve módulos no Python.</p>
<p>O único problema com este exemplo é que quando você importa o módulo, ele executa o código de teste no final. Normalmente, quando se importa um módulo, ele define novas funções, mas não as executa.</p>
<p>Os programas que serão importados como módulos muitas vezes usam a seguinte expressão:</p>
<pre><code class="language-python">if __name__ == '__main__':
    print(linecount('wc.py'))
</code></pre>
<p><code>__name__</code> é uma variável integrada, estabelecida quando o programa inicia. Se o programa estiver rodando como um script, <code>__name__</code> tem o valor <code>'__main__'</code>; neste caso, o código de teste é executado. Do contrário, se o módulo está sendo importado, o código de teste é ignorado.</p>
<p>Como exercício, digite este exemplo em um arquivo chamado wc.py e execute-o como um script. Então execute o interpretador do Python e import wc. Qual é o valor de <code>__name__</code> quando o módulo está sendo importado?</p>
<p>Atenção: se você importar um módulo que já tenha sido importado, o Python não faz nada. Ele não relê o arquivo, mesmo se tiver sido alterado.</p>
<p>Se quiser recarregar um módulo, você pode usar a função integrada <code>reload</code>, mas isso pode causar problemas, então o mais seguro é reiniciar o interpretador e importar o módulo novamente.</p>
<h2><a class="header" href="#1410---depuração" id="1410---depuração">14.10 - Depuração</a></h2>
<p>Quando estiver lendo e escrevendo arquivos, você pode ter problemas com whitespace. Esses erros podem ser difíceis para depurar, porque os espaços, tabulações e quebras de linha normalmente são invisíveis:</p>
<pre><code class="language-python">&gt;&gt;&gt; s = '1 2\t 3\n 4'
&gt;&gt;&gt; print(s)
1 2      3
 4
</code></pre>
<p>A função integrada <code>repr</code> pode ajudar. Ela recebe qualquer objeto como argumento e retorna uma representação em string do objeto. Para strings, representa caracteres de whitespace com sequências de barras invertidas:</p>
<pre><code class="language-python">&gt;&gt;&gt; print(repr(s))
'1 2\t 3\n 4'
</code></pre>
<p>Isso pode ser útil para a depuração.</p>
<p>Outro problema que você pode ter é que sistemas diferentes usam caracteres diferentes para indicar o fim de uma linha. Alguns sistemas usam newline, representado por <code>\n</code>. Outros usam um caractere de retorno, representado por <code>\r</code>. Alguns usam ambos. Se mover arquivos entre sistemas diferentes, essas inconsistências podem causar problemas.</p>
<p>Para a maior parte dos sistemas há aplicações para converter de um formato a outro. Você pode encontrá-los (e ler mais sobre o assunto) em <a href="http://en.wikipedia.org/wiki/Newline">http://en.wikipedia.org/wiki/Newline</a>. Ou, é claro, você pode escrever um por conta própria.</p>
<h2><a class="header" href="#1411---glossário" id="1411---glossário">14.11 - Glossário</a></h2>
<h5><a class="header" href="#persistente" id="persistente">persistente</a></h5>
<p>    Relativo a um programa que roda indefinidamente e mantém pelo menos alguns dos seus dados em armazenamento permanente.</p>
<h5><a class="header" href="#operador-de-formatação" id="operador-de-formatação">operador de formatação</a></h5>
<p>    Um operador, %, que recebe uma string de formatação e uma tupla e gera uma string que inclui os elementos da tupla formatada como especificado pela string de formatação.</p>
<h5><a class="header" href="#string-de-formatação" id="string-de-formatação">string de formatação</a></h5>
<p>    String usada com o operador de formatação, que contém sequências de formatação.</p>
<h5><a class="header" href="#sequência-de-formatação" id="sequência-de-formatação">sequência de formatação</a></h5>
<p>    Sequência de caracteres em uma string de formatação, como %d, que especifica como um valor deve ser formatado.</p>
<h5><a class="header" href="#arquivo-de-texto" id="arquivo-de-texto">arquivo de texto</a></h5>
<p>    Sequência de caracteres guardados em armazenamento permanente, como uma unidade de disco rígido.</p>
<h5><a class="header" href="#diretório" id="diretório">diretório</a></h5>
<p>    Uma coleção de arquivos nomeada, também chamada de pasta.</p>
<h5><a class="header" href="#caminho" id="caminho">caminho</a></h5>
<p>    String que identifica um arquivo.</p>
<h5><a class="header" href="#caminho-relativo" id="caminho-relativo">caminho relativo</a></h5>
<p>    Caminho que inicia no diretório atual.</p>
<h5><a class="header" href="#caminho-absoluto" id="caminho-absoluto">caminho absoluto</a></h5>
<p>    Caminho que inicia no diretório de posição mais alta (raiz) no sistema de arquivos.</p>
<h5><a class="header" href="#capturar" id="capturar">capturar</a></h5>
<p>    Impedir uma exceção de encerrar um programa usando as instruções try e except.</p>
<h5><a class="header" href="#banco-de-dados" id="banco-de-dados">banco de dados</a></h5>
<p>    Um arquivo cujo conteúdo é organizado como um dicionário, com chaves que correspondem a valores.</p>
<h5><a class="header" href="#objeto-bytes" id="objeto-bytes">objeto bytes</a></h5>
<p>    Objeto semelhante a uma string.</p>
<h5><a class="header" href="#shell" id="shell">shell</a></h5>
<p>    Programa que permite aos usuários digitar comandos e executá-los para iniciar outros programas.</p>
<h5><a class="header" href="#objeto-pipe" id="objeto-pipe">objeto pipe</a></h5>
<p>    Objeto que representa um programa em execução, permitindo que um programa do Python execute comandos e leia os resultados.</p>
<h2><a class="header" href="#1412---exercícios" id="1412---exercícios">14.12 - Exercícios</a></h2>
<h3><a class="header" href="#exercício-141" id="exercício-141">Exercício 14.1</a></h3>
<p>Escreva uma função chamada sed que receba como argumentos uma string-padrão, uma string de substituição e dois nomes de arquivo; ela deve ler o primeiro arquivo e escrever o conteúdo no segundo arquivo (criando-o, se necessário). Se a string-padrão aparecer em algum lugar do arquivo, ela deve ser substituída pela string de substituição.</p>
<p>Se ocorrer um erro durante a abertura, leitura, escrita ou fechamento dos arquivos, seu programa deve <a href="14-arquivos/11-glossario.html#capturar">capturar</a> a exceção, exibir uma mensagem de erro e encerrar.</p>
<p>Solução: <a href="http://thinkpython2.com/code/sed.py">http://thinkpython2.com/code/sed.py</a>.</p>
<h3><a class="header" href="#exercício-142" id="exercício-142">Exercício 14.2</a></h3>
<p>Se você baixar minha solução do Exercício 12.2 em <a href="http://thinkpython2.com/code/anagram_sets.py">http://thinkpython2.com/code/anagram_sets.py</a>, verá que ela cria um dicionário que mapeia uma string ordenada de letras à lista de palavras que podem ser soletradas com aquelas letras. Por exemplo, <code>'opst'</code> mapeia à lista <code>['opts', 'post', 'pots', 'spot', 'stop', 'tops']</code>.</p>
<p>Escreva um módulo que importe <code>anagram_sets</code> e forneça duas novas funções: <code>store_anagrams</code> deve guardar o dicionário de anagramas em uma “prateleira” (objeto criado pelo módulo <code>sheve</code>); <code>read_anagrams</code> deve procurar uma palavra e devolver uma lista dos seus anagramas.</p>
<p>Solução: <a href="http://thinkpython2.com/code/anagram_db.py">http://thinkpython2.com/code/anagram_db.py</a>.</p>
<h3><a class="header" href="#exercício-143" id="exercício-143">Exercício 14.3</a></h3>
<p>Em uma grande coleção de arquivos MP3 pode haver mais de uma cópia da mesma música, guardada em diretórios diferentes ou com nomes de arquivo diferentes. A meta deste exercício é procurar duplicatas.</p>
<ol>
<li>
<p>Escreva um programa que procure um <a href="14-arquivos/11-glossario.html#diret%C3%B3rio">diretório</a> e todos os seus subdiretórios, recursivamente, e retorne uma lista de caminhos completos de todos os arquivos com um dado sufixo (como .mp3). Dica: os.path fornece várias funções úteis para manipular nomes de caminhos e de arquivos.</p>
</li>
<li>
<p>Para reconhecer duplicatas, você pode usar md5sum para calcular uma “soma de controle” para cada arquivo. Se dois arquivos tiverem a mesma soma de controle, provavelmente têm o mesmo conteúdo.</p>
</li>
<li>
<p>Para conferir o resultado, você pode usar o comando Unix <code>diff</code>.</p>
</li>
</ol>
<p>Solução: <a href="http://thinkpython2.com/code/find_duplicates.py">http://thinkpython2.com/code/find_duplicates.py</a>.</p>
<h1><a class="header" href="#capítulo-15-classes-e-objetos" id="capítulo-15-classes-e-objetos">Capítulo 15: Classes e objetos</a></h1>
<p>A esta altura você já sabe como usar funções para organizar código e tipos integrados para organizar dados. O próximo passo é aprender “programação orientada a objeto”, que usa tipos definidos pelos programadores para organizar tanto o código quanto os dados. A programação orientada a objeto é um tópico abrangente; será preciso passar por alguns capítulos para abordar o tema.</p>
<p>Os exemplos de código deste capítulo estão disponíveis em <a href="http://thinkpython2.com/code/Point1.py">http://thinkpython2.com/code/Point1.py</a>; as soluções para os exercícios estão disponíveis em <a href="http://thinkpython2.com/code/Point1_soln.py">http://thinkpython2.com/code/Point1_soln.py</a>.</p>
<h2><a class="header" href="#151---tipos-definidos-pelos-programadores" id="151---tipos-definidos-pelos-programadores">15.1 - Tipos definidos pelos programadores</a></h2>
<p>Já usamos muitos tipos integrados do Python; agora vamos definir um tipo próprio. Como exemplo, criaremos um tipo chamado <code>Point</code>, que representa um ponto no espaço bidimensional.</p>
<p>Na notação matemática, os pontos muitas vezes são escritos entre parênteses, com uma vírgula separando as coordenadas. Por exemplo, (0,0) representa a origem e (x, y) representa o ponto que está x unidades à direita e y unidades acima da origem.</p>
<p>Há várias formas para representar pontos no Python:</p>
<ul>
<li>
<p>Podemos armazenar as coordenadas separadamente em duas variáveis, x e y.</p>
</li>
<li>
<p>Podemos armazenar as coordenadas como elementos em uma lista ou tupla.</p>
</li>
<li>
<p>Podemos criar um tipo para representar pontos como objetos.</p>
</li>
</ul>
<p>Criar um tipo é mais complicado que outras opções, mas tem vantagens que logo ficarão evidentes.</p>
<p>Um tipo definido pelo programador também é chamado de <a href="15-classes-e-objetos/08-glossario.html#classe">classe</a>. Uma definição de classe pode ser assim:</p>
<pre><code class="language-python">class Point:
    &quot;&quot;&quot;Represents a point in 2-D space.&quot;&quot;&quot;
</code></pre>
<p>O cabeçalho indica que a nova classe se chama <code>Point</code>. O corpo é uma docstring que explica para que a classe serve. Você pode definir variáveis e métodos dentro de uma definição de classe, mas voltaremos a isso depois.</p>
<p>Definir uma classe denominada <code>Point</code> cria um <a href="15-classes-e-objetos/08-glossario.html#objeto-de-classe">objeto de classe</a>:</p>
<pre><code class="language-python">&gt;&gt;&gt; Point
&lt;class '__main__.Point'&gt;
</code></pre>
<p>Como <code>Point</code> é definido no nível superior, seu “nome completo” é <code>__main__.Point</code>.</p>
<p>O objeto de classe é como uma fábrica para criar objetos. Para criar um <code>Point</code>, você chama <code>Point</code> como se fosse uma função:</p>
<pre><code class="language-python">&gt;&gt;&gt; blank = Point()
&gt;&gt;&gt; blank
&lt;__main__.Point object at 0xb7e9d3ac&gt;
</code></pre>
<p>O valor de retorno é uma referência a um objeto <code>Point</code>, ao qual atribuímos blank.</p>
<p>Criar um objeto chama-se instanciação, e o objeto é uma <a href="15-classes-e-objetos/08-glossario.html#inst%C3%A2ncia">instância</a> da classe.</p>
<p>Quando você exibe uma instância, o Python diz a que classe ela pertence e onde está armazenada na memória (o prefixo o 0x significa que o número seguinte está em formato hexadecimal).</p>
<p>Cada objeto é uma instância de alguma classe, então “objeto” e “instância” são intercambiáveis. Porém, neste capítulo uso “instância” para indicar que estou falando sobre um tipo definido pelo programador.</p>
<h2><a class="header" href="#152---atributos" id="152---atributos">15.2 - Atributos</a></h2>
<p>Você pode atribuir valores a uma <a href="15-classes-e-objetos/08-glossario.html#inst%C3%A2ncia">instância</a> usando a notação de ponto:</p>
<pre><code class="language-python">&gt;&gt;&gt; blank.x = 3.0
&gt;&gt;&gt; blank.y = 4.0
</code></pre>
<p>Essa sintaxe é semelhante à usada para selecionar uma variável de um módulo, como math.pi ou string.whitespace. Nesse caso, entretanto, estamos atribuindo valores a elementos nomeados de um objeto. Esses elementos chamam-se atributos.</p>
<p>Em inglês, quando é um substantivo, a palavra “AT-trib-ute” é pronunciada com ênfase na primeira sílaba, ao contrário de “a-TRIB-ute”, que é um verbo.</p>
<p>O diagrama seguinte mostra o resultado dessas atribuições. Um diagrama de estado que mostra um objeto e seus atributos chama-se <a href="15-classes-e-objetos/08-glossario.html#diagrama-de-objeto">diagrama de objeto</a>; veja a Figura 15.1.</p>
<p><img src="15-classes-e-objetos//fig/tnkp_1501.png" alt="Figura 15.1 – Diagrama de um objeto Point" />.
<br><em>Figura 15.1 – Diagrama de um objeto</em> <code>Point</code>.</p>
<p>A variável blank refere-se a um objeto <code>Point</code>, que contém dois atributos. Cada <a href="15-classes-e-objetos/08-glossario.html#atributo">atributo</a> refere-se a um número de ponto flutuante.</p>
<p>Você pode ler o valor de um atributo usando a mesma sintaxe:</p>
<pre><code class="language-python">&gt;&gt;&gt; blank.y
4.0
&gt;&gt;&gt; x = blank.x
&gt;&gt;&gt; x
3.0
</code></pre>
<p>A expressão <code>blank.x</code> significa “Vá ao objeto a que blank se refere e pegue o valor de x”. No exemplo, atribuímos este valor a uma variável <code>x</code>. Não há nenhum conflito entre a variável <code>x</code> e o atributo <code>x</code>.</p>
<p>Você pode usar a notação de ponto como parte de qualquer expressão. Por exemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; '(%g, %g)' % (blank.x, blank.y)
'(3.0, 4.0)'
&gt;&gt;&gt; distance = math.sqrt(blank.x ** 2 + blank.y ** 2)
&gt;&gt;&gt; distance
5.0
</code></pre>
<p>Você pode passar uma instância como argumento da forma habitual. Por exemplo:</p>
<pre><code class="language-python">def print_point(p):
    print('(%g, %g)' % (p.x, p.y))
</code></pre>
<p><code>print_point</code> toma um ponto como argumento e o exibe em notação matemática. Para invocá-lo, você pode passar <code>blank</code> como argumento:</p>
<pre><code class="language-python">&gt;&gt;&gt; print_point(blank)
(3.0, 4.0)
</code></pre>
<p>Dentro da função, <code>p</code> é um alias para <code>blank</code>, então, se a função altera <code>p</code>, <code>blank</code> também muda.</p>
<p>Como exercício, escreva uma função chamada <code>distance_between_points</code>, que toma dois pontos como argumentos e retorna a distância entre eles.</p>
<h2><a class="header" href="#153---retângulos" id="153---retângulos">15.3 - Retângulos</a></h2>
<p>Às vezes, é óbvio quais deveriam ser os atributos de um objeto, mas outras é preciso decidir entre as possibilidades. Por exemplo, vamos supor que você esteja criando uma <a href="15-classes-e-objetos/08-glossario.html#classe">classe</a> para representar retângulos. Que atributos usaria para especificar a posição e o tamanho de um retângulo? Você pode ignorar ângulo; para manter as coisas simples, suponha que o retângulo seja vertical ou horizontal.</p>
<p>Há duas possibilidades, no mínimo:</p>
<ul>
<li>
<p>Você pode especificar um canto do retângulo (ou o centro), a largura e a altura.</p>
</li>
<li>
<p>Você pode especificar dois cantos opostos.</p>
</li>
</ul>
<p>Nesse ponto é difícil dizer qual opção é melhor, então implementaremos a primeira, como exemplo.</p>
<p>Aqui está a definição de classe:</p>
<pre><code class="language-python">class Rectangle:
    &quot;&quot;&quot;Represents a rectangle.
    attributes: width, height, corner.
    &quot;&quot;&quot;
</code></pre>
<p>A docstring lista os atributos: width e height são números; corner é um objeto <code>Point</code> que especifica o canto inferior esquerdo.</p>
<p>Para representar um retângulo, você tem que <a href="15-classes-e-objetos/08-glossario.html#instanciar">instanciar</a> um objeto <code>Rectangle</code> e atribuir valores aos atributos:</p>
<pre><code class="language-python">box = Rectangle()
box.width = 100.0
box.height = 200.0
box.corner = Point()
box.corner.x = 0.0
box.corner.y = 0.0
</code></pre>
<p>A expressão <code>box.corner.x</code> significa “Vá ao objeto ao qual <code>box</code> se refere e pegue o <a href="15-classes-e-objetos/08-glossario.html#atributo">atributo</a> denominado <code>corner</code>; então vá a este objeto e pegue o atributo denominado <code>x</code>”.</p>
<p>A Figura 15.2 mostra o estado deste objeto. Um objeto que é um atributo de outro objeto é integrado.</p>
<p>A Figura 10.1 mostra o diagrama de estado para cheeses, numbers e empty.</p>
<p><img src="15-classes-e-objetos//fig/tnkp_1502.png" alt="Figura 15.2 – Diagrama de um objeto Rectangle" />.
<br><em>Figura 15.2 – Diagrama de um objeto</em> <code>Rectangle</code>.</p>
<h2><a class="header" href="#154---instâncias-como-valores-de-retorno" id="154---instâncias-como-valores-de-retorno">15.4 - Instâncias como valores de retorno</a></h2>
<p>As funções podem retornar instâncias. Por exemplo, <code>find_center</code> recebe um <code>Rectangle</code> como argumento e devolve um <code>Point</code>, que contém as coordenadas do centro do retângulo:</p>
<pre><code class="language-python">def find_center(rect):
    p = Point()
    p.x = rect.corner.x + rect.width/2
    p.y = rect.corner.y + rect.height/2
    return p
</code></pre>
<p>Aqui está um exemplo que passa <code>box</code> como um argumento para <code>find_center</code> e atribui o <code>ponto</code> resultante à variável <code>center</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; center = find_center(box)
&gt;&gt;&gt; print_point(center)
(50, 100)
</code></pre>
<h2><a class="header" href="#155---objetos-são-mutáveis" id="155---objetos-são-mutáveis">15.5 - Objetos são mutáveis</a></h2>
<p>Você pode alterar o estado de um objeto fazendo uma atribuição a um dos seus atributos. Por exemplo, para mudar o tamanho de um retângulo sem mudar sua posição, você pode alterar os valores de width e height:</p>
<pre><code class="language-python">box.width = box.width + 50
box.height = box.height + 100
</code></pre>
<p>Você também pode escrever funções que alteram objetos. Por exemplo, <code>grow_rectangle</code> recebe um objeto <code>Rectangle</code> e dois números, <code>dwidth</code> e <code>dheight</code>, e adiciona os números à largura e altura do retângulo:</p>
<pre><code class="language-python">def grow_rectangle(rect, dwidth, dheight):
    rect.width += dwidth
    rect.height += dheight
</code></pre>
<p>Eis um exemplo que demonstra o efeito:</p>
<pre><code class="language-python">&gt;&gt;&gt; box.width, box.height
(150.0, 300.0)
&gt;&gt;&gt; grow_rectangle(box, 50, 100)
&gt;&gt;&gt; box.width, box.height
(200.0, 400.0)
</code></pre>
<p>Dentro da função, <code>rect</code> é um alias de <code>box</code>, então quando a função altera <code>rect</code>, <code>box</code> aponta para o objeto alterado.</p>
<p>Como exercício, escreva uma função chamada <code>move_rectangle</code> que toma um Rectangle e dois números chamados dx e dy. Ela deve alterar a posição do retângulo, adicionando dx à coordenada x de corner e adicionando dy à coordenada y de corner.</p>
<h2><a class="header" href="#156---cópia" id="156---cópia">15.6 - Cópia</a></h2>
<p>Alias podem tornar um programa difícil de ler porque as alterações em um lugar podem ter efeitos inesperados em outro lugar. É difícil monitorar todas as variáveis que podem referir-se a um dado objeto.</p>
<p>Em vez de usar alias, copiar o objeto pode ser uma alternativa. O módulo <code>copy</code> contém uma função chamada <code>copy</code> que pode duplicar qualquer objeto:</p>
<pre><code class="language-python">&gt;&gt;&gt; p1 = Point()
&gt;&gt;&gt; p1.x = 3.0
&gt;&gt;&gt; p1.y = 4.0
&gt;&gt;&gt; import copy
&gt;&gt;&gt; p2 = copy.copy(p1)
</code></pre>
<p><code>p1</code> e <code>p2</code> contêm os mesmos dados, mas não são o mesmo <code>Point</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; print_point(p1)
(3, 4)
&gt;&gt;&gt; print_point(p2)
(3, 4)
&gt;&gt;&gt; p1 is p2
False
&gt;&gt;&gt; p1 == p2
False
</code></pre>
<p>O operador <code>is</code> indica que <code>p1</code> e <code>p2</code> não são o mesmo objeto, que é o que esperamos. Porém, você poderia ter esperado que <code>==</code> fosse apresentado como <code>True</code>, porque esses pontos contêm os mesmos dados. Nesse caso, pode ficar desapontado ao saber que, para instâncias, o comportamento padrão do operador <code>==</code> é o mesmo que o do operador <code>is</code>; ele verifica a identidade dos objetos, não a sua equivalência. Isso acontece porque, para tipos definidos pelo programador, o Python não sabe o que deve ser considerado equivalente. Pelo menos, ainda não.</p>
<p>Se você usar <code>copy.copy</code> para duplicar um retângulo, descobrirá que ele copia o objeto <code>Rectangle</code>, mas não o <code>Point</code> embutido nele:</p>
<pre><code class="language-python">&gt;&gt;&gt; box2 = copy.copy(box)
&gt;&gt;&gt; box2 is box
False
&gt;&gt;&gt; box2.corner is box.corner
True
</code></pre>
<p>A Figura 15.3 mostra como fica o <a href="15-classes-e-objetos/08-glossario.html#diagrama-de-objeto">diagrama de objeto</a>. Esta operação chama-se <a href="15-classes-e-objetos/08-glossario.html#c%C3%B3pia-superficial">cópia superficial</a> porque copia o objeto e qualquer referência que contenha, mas não os objetos integrados.</p>
<p><img src="15-classes-e-objetos//fig/tnkp_1503.png" alt="Figura 15.3 – Diagrama: dois objetos Rectangle compartilhando o mesmo Point" />.
<br><em>Figura 15.3 – Diagrama: dois objetos</em> <code>Rectangle</code> <em>compartilhando o mesmo</em> <code>Point</code>.</p>
<p>Para a maior parte das aplicações, não é isso que você quer. Nesse exemplo, invocar <code>grow_rectangle</code> em um dos Rectangles não afetaria o outro, mas invocar <code>move_rectangle</code> em qualquer um deles afetaria a ambos! Esse comportamento é confuso e propenso a erros.</p>
<p>Felizmente, o módulo <code>copy</code> oferece um método chamado <code>deepcopy</code> que copia não só o objeto, mas também os objetos aos quais ele se refere, e os objetos aos quais estes se referem, e assim por diante. Você não se surpreenderá ao descobrir que esta operação se chama <a href="15-classes-e-objetos/08-glossario.html#c%C3%B3pia-profunda">cópia profunda</a>.</p>
<pre><code class="language-python">&gt;&gt;&gt; box3 = copy.deepcopy(box)
&gt;&gt;&gt; box3 is box
False
&gt;&gt;&gt; box3.corner is box.corner
False
box3 e box são objetos completamente separados.
</code></pre>
<p>Como exercício, escreva uma versão de <code>move_rectangle</code> que cria e retorne um novo retângulo em vez de alterar o antigo.</p>
<h2><a class="header" href="#157---depuração" id="157---depuração">15.7 - Depuração</a></h2>
<p>Ao começar a trabalhar com objetos, provavelmente você encontrará algumas novas exceções. Se tentar acessar um <a href="15-classes-e-objetos/08-glossario.html#atributo">atributo</a> que não existe, recebe um <code>AttributeError</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; p = Point()
&gt;&gt;&gt; p.x = 3
&gt;&gt;&gt; p.y = 4
&gt;&gt;&gt; p.z
AttributeError: Point instance has no attribute 'z'
</code></pre>
<p>Se não estiver certo sobre o tipo que um objeto é, pode perguntar:</p>
<pre><code class="language-python">&gt;&gt;&gt; type(p)
&lt;class '__main__.Point'&gt;
</code></pre>
<p>Você também pode usar <code>isinstance</code> para verificar se um objeto é uma <a href="15-classes-e-objetos/08-glossario.html#inst%C3%A2ncia">instância</a> de uma <a href="15-classes-e-objetos/08-glossario.html#classe">classe</a>:</p>
<pre><code class="language-python">&gt;&gt;&gt; isinstance(p, Point)
True
</code></pre>
<p>Caso não tenha certeza se um objeto tem determinado atributo, você pode usar a função integrada <code>hasattr</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; hasattr(p, 'x')
True
&gt;&gt;&gt; hasattr(p, 'z')
False
</code></pre>
<p>O primeiro argumento pode ser qualquer objeto; o segundo argumento é uma <code>string</code> com o nome do atributo.</p>
<p>Você também pode usar uma instrução <code>try</code> para ver se o objeto tem os atributos de que precisa:</p>
<pre><code class="language-python">try:
    x = p.x
except AttributeError:
    x = 0
</code></pre>
<p>Essa abordagem pode facilitar a escrita de funções que atuam com tipos diferentes; você verá mais informações sobre isso em “Polimorfismo”, na página 248.</p>
<h2><a class="header" href="#158---glossário" id="158---glossário">15.8 - Glossário</a></h2>
<h5><a class="header" href="#classe" id="classe">classe</a></h5>
<p>    Tipo definido pelo programador. Uma definição de classe cria um objeto de classe.</p>
<h5><a class="header" href="#objeto-de-classe" id="objeto-de-classe">objeto de classe</a></h5>
<p>    Objeto que contém a informação sobre um tipo definido pelo programador. O objeto de classe pode ser usado para criar instâncias do tipo.</p>
<h5><a class="header" href="#instância" id="instância">instância</a></h5>
<p>    Objeto que pertence a uma classe.</p>
<h5><a class="header" href="#instanciar" id="instanciar">instanciar</a></h5>
<p>    Criar um objeto.</p>
<h5><a class="header" href="#atributo" id="atributo">atributo</a></h5>
<p>    Um dos valores denominados associados a um objeto.</p>
<h5><a class="header" href="#objeto-integrado" id="objeto-integrado">objeto integrado</a></h5>
<p>    Objeto que é armazenado como um atributo de outro objeto.</p>
<h5><a class="header" href="#cópia-superficial" id="cópia-superficial">cópia superficial</a></h5>
<p>    Copiar o conteúdo de um objeto, inclusive qualquer referência a objetos integrados; implementada pela função copy no módulo copy.</p>
<h5><a class="header" href="#cópia-profunda" id="cópia-profunda">cópia profunda</a></h5>
<p>    Copiar o conteúdo de um objeto, bem como qualquer objeto integrado, e qualquer objeto integrado a estes, e assim por diante; implementado pela função deepcopy no módulo copy.</p>
<h5><a class="header" href="#diagrama-de-objeto" id="diagrama-de-objeto">diagrama de objeto</a></h5>
<p>    Diagrama que mostra objetos, seus atributos e os valores dos atributos.</p>
<h2><a class="header" href="#159---exercícios" id="159---exercícios">15.9 - Exercícios</a></h2>
<h3><a class="header" href="#exercício-151" id="exercício-151">Exercício 15.1</a></h3>
<ol>
<li>
<p>Escreva uma definição para uma <a href="15-classes-e-objetos/08-glossario.html#classe">classe</a> denominada <code>Circle</code>, com os atributos center e radius, onde center é um objeto <code>Point</code> e radius é um número.</p>
</li>
<li>
<p>Instancie um objeto <code>Circle</code>, que represente um círculo com o centro em 150, 100 e raio 75.</p>
</li>
<li>
<p>Escreva uma função denominada <code>point_in_circle</code>, que tome um <code>Circle</code> e um <code>Point</code> e retorne <code>True</code>, se o ponto estiver dentro ou no limite do círculo.</p>
</li>
<li>
<p>Escreva uma função chamada <code>rect_in_circle</code>, que tome um <code>Circle</code> e um Rectangle e retorne <code>True</code>, se o retângulo estiver totalmente dentro ou no limite do círculo.</p>
</li>
<li>
<p>Escreva uma função denominada <code>rect_circle_overlap</code>, que tome um <code>Circle</code> e um Rectangle e retorne <code>True</code>, se algum dos cantos do retângulo cair dentro do círculo. Ou, em uma versão mais desafiadora, retorne <code>True</code> se alguma parte do retângulo cair dentro do círculo.</p>
</li>
</ol>
<p>Solução: <a href="http://thinkpython2.com/code/Circle.py">http://thinkpython2.com/code/Circle.py</a>.</p>
<h3><a class="header" href="#exercício-152" id="exercício-152">Exercício 15.2</a></h3>
<ol>
<li>
<p>Escreva uma função chamada <code>draw_rect</code> que receba um objeto <code>Turtle</code> e um <code>Rectangle</code> e use o <code>Turtle</code> para desenhar o retângulo. Veja no Capítulo 4 os exemplos de uso de objetos <code>Turtle</code>.</p>
</li>
<li>
<p>Escreva uma função chamada <code>draw_circle</code>, que tome um Turtle e um <code>Circle</code> e desenhe o círculo.</p>
</li>
</ol>
<h1><a class="header" href="#capítulo-16-classes-e-funções" id="capítulo-16-classes-e-funções">Capítulo 16: Classes e funções</a></h1>
<p>Agora que sabemos como criar tipos, o próximo passo deve ser escrever funções que recebam objetos definidos pelo programador como parâmetros e os retornem como resultados. Neste capítulo também vou apresentar o “estilo funcional de programação” e dois novos planos de desenvolvimento de programas.</p>
<p>Os exemplos de código deste capítulo estão disponíveis em <a href="http://thinkpython2.com/code/Time1.py">http://thinkpython2.com/code/Time1.py</a>. As soluções para os exercícios estão em <a href="http://thinkpython2.com/code/Time1_soln.py">http://thinkpython2.com/code/Time1_soln.py</a>.</p>
<h2><a class="header" href="#161---time" id="161---time">16.1 - Time</a></h2>
<p>Para ter mais um exemplo de tipo definido pelo programador, criaremos uma classe chamada <code>Time</code> (hora), que registra um horário no dia. A definição da classe é assim:</p>
<pre><code class="language-python">class Time:
    &quot;&quot;&quot;Represents the time of day.
    attributes: hour, minute, second
    &quot;&quot;&quot;
</code></pre>
<p>Podemos criar um objeto <code>Time</code> e ter atributos para horas, minutos e segundos:</p>
<pre><code class="language-python">time = Time()
time.hour = 11
time.minute = 59
time.second = 30
</code></pre>
<p>O diagrama de estado do objeto Time está na Figura 16.1.</p>
<p><img src="16-classes-e-funcoes//fig/tnkp_1601.png" alt="Figura 16.1 – Diagrama de um objeto Time" />.
<br><em>Figura 16.1 – Diagrama de um objeto</em> <code>Time</code>.</p>
<p>Como exercício, escreva uma função chamada <code>print_time</code>, que receba um objeto Time e o exiba na forma hour:minute:second. Dica: a sequência de formatação <code>'%.2d'</code> exibe um número inteiro com, pelo menos, dois dígitos, incluindo um zero à esquerda, se for necessário.</p>
<p>Escreva uma função booleana chamada <code>is_after</code>, que receba dois objetos Time, <code>t1</code> e <code>t2</code>, e devolva <code>True</code> se <code>t1</code> for cronologicamente depois de <code>t2</code> e <code>False</code> se não for. Desafio: não use uma instrução <code>if</code>.</p>
<h2><a class="header" href="#162---funções-puras" id="162---funções-puras">16.2 - Funções puras</a></h2>
<p>Nas próximas seções, vamos escrever duas funções que adicionam valores de tempo. Elas demonstram dois tipos de funções: funções puras e modificadores. Também demonstram um plano de desenvolvimento que chamarei de <a href="16-classes-e-funcoes/06-glossario.html#prot%C3%B3tipo-e-corre%C3%A7%C3%A3o">protótipo e correção</a>, que é uma forma de atacar um problema complexo começando com um protótipo simples e lidando com as complicações de forma incremental.</p>
<p>Aqui está um protótipo simples de <code>add_time</code>:</p>
<pre><code class="language-python">def add_time(t1, t2):
    sum = Time()
    sum.hour = t1.hour + t2.hour
    sum.minute = t1.minute + t2.minute
    sum.second = t1.second + t2.second
    return sum
</code></pre>
<p>A função cria um novo objeto <code>Time</code>, inicializa seus atributos e retorna uma referência ao novo objeto. A <a href="16-classes-e-funcoes/06-glossario.html#fun%C3%A7%C3%A3o-pura">função pura</a> é chamada assim porque não altera nenhum dos objetos passados a ela como argumentos; além disso, ela não tem efeitos, como exibir um valor ou receber entradas de usuário, apenas retorna um valor.</p>
<p>Para testar esta função, criarei objetos <code>Time</code>: <code>start</code>, que contém o tempo de início de um filme, como <em>Monty Python e o cálice sagrado</em>, e <code>duration</code>, que contém o tempo de execução do filme, que é de 1 hora e 35 minutos.</p>
<p><code>add_time</code> calcula quando o filme acaba:</p>
<pre><code class="language-python">&gt;&gt;&gt; start = Time()
&gt;&gt;&gt; start.hour = 9
&gt;&gt;&gt; start.minute = 45
&gt;&gt;&gt; start.second = 0
&gt;&gt;&gt; duration = Time()
&gt;&gt;&gt; duration.hour = 1
&gt;&gt;&gt; duration.minute = 35
&gt;&gt;&gt; duration.second = 0
&gt;&gt;&gt; done = add_time(start, duration)
&gt;&gt;&gt; print_time(done)
10:80:00
</code></pre>
<p>O resultado, 10:80:00, pode não ser o que você esperava. O problema é que esta função não trata casos onde o número de segundos ou minutos é maior que 60. Quando isso acontece, precisamos transportar os segundos extras à coluna dos minutos ou os minutos extras à coluna das horas.</p>
<p>Aqui está uma versão melhorada:</p>
<pre><code class="language-python">def add_time(t1, t2):
    sum = Time()
    sum.hour = t1.hour + t2.hour
    sum.minute = t1.minute + t2.minute
    sum.second = t1.second + t2.second
    if sum.second &gt;= 60:
        sum.second -= 60
        sum.minute += 1
    if sum.minute &gt;= 60:
        sum.minute -= 60
        sum.hour += 1
    return sum
</code></pre>
<p>Embora esta função esteja correta, é um pouco extensa. Veremos uma alternativa menor mais adiante.</p>
<h2><a class="header" href="#163---modificadores" id="163---modificadores">16.3 - Modificadores</a></h2>
<p>Às vezes é útil uma função alterar os objetos que recebe como parâmetros. Nesse caso, as mudanças são visíveis a quem chama a função. As funções que fazem isso chamam-se modificadores.</p>
<p><code>increment</code>, que acrescenta um dado número de segundos a um objeto <code>Time</code>, pode ser escrita naturalmente como um <a href="16-classes-e-funcoes/06-glossario.html#modificador">modificador</a>. Aqui está um primeiro esboço:</p>
<pre><code class="language-python">def increment(time, seconds):
    time.second += seconds
    if time.second &gt;= 60:
        time.second -= 60
        time.minute += 1
    if time.minute &gt;= 60:
        time.minute -= 60
        time.hour += 1
</code></pre>
<p>A primeira linha executa a operação básica; o resto lida com os casos especiais que vimos antes.</p>
<p>Esta função está correta? O que acontece se <code>second</code> for muito mais que 60?</p>
<p>Neste caso não basta transportar uma vez, temos que continuar fazendo isso até que time.second seja menos de 60. Uma solução é substituir a instrução <code>if</code> pela instrução <code>while</code>. Isso tornaria a função correta, mas não muito eficiente. Como exercício, escreva uma versão correta de <code>increment</code> que não contenha loops.</p>
<p>O que se faz com modificadores também pode ser feito com funções puras. Na verdade, algumas linguagens de programação só permitem funções puras. Há evidências de que os programas que usam funções puras são mais rápidos para serem desenvolvidos e menos propensos a erros que programas que usam modificadores. No entanto, modificadores são convenientes de vez em quando, e os programas funcionais tendem a ser menos eficientes.</p>
<p>De forma geral, recomendo que você escreva funções puras sempre que achar razoável e recorra a modificadores só se houver alguma vantagem clara. Esta abordagem pode ser chamada de <strong>programação funcional</strong>.</p>
<p>Como exercício, escreva uma versão “pura” de increment que cria e retorna um objeto <code>Time</code> em vez de alterar o parâmetro.</p>
<h2><a class="header" href="#164---prototipação-versus-planejamento" id="164---prototipação-versus-planejamento">16.4 - Prototipação versus planejamento</a></h2>
<p>O plano de desenvolvimento que estou demonstrando chama-se “<a href="16-classes-e-funcoes/06-glossario.html#prot%C3%B3tipo-e-corre%C3%A7%C3%A3o">protótipo e correção</a>”. Para cada função, escrevi um protótipo que executa o cálculo básico e então testa a função, corrigindo erros no decorrer do caminho.</p>
<p>Esta abordagem pode ser eficaz, especialmente se você ainda não tem uma compreensão profunda do problema. Porém, as correções incrementais podem gerar código que se complica desnecessariamente (pois trata de muitos casos especiais) e pouco confiáveis (já que é difícil saber se todos os erros foram encontrados).</p>
<p>Uma alternativa é o <a href="16-classes-e-funcoes/06-glossario.html#desenvolvimento-planejado">desenvolvimento planejado</a>, no qual a compreensão de alto nível do problema pode facilitar muito a programação. Neste caso, descobre-se que um objeto Time é, na verdade, um número de três dígitos na base 60 (veja <a href="http://en.wikipedia.org/wiki/Sexagesimal">http://en.wikipedia.org/wiki/Sexagesimal</a>)! O atributo second é a “coluna de unidades”, o atributo minute é a “coluna dos 60”, e o atributo hour é a “coluna do 3.600”.</p>
<p>Quando escrevemos <code>add_time</code> e <code>increment</code>, estávamos na verdade fazendo adições na base 60, e por isso transportávamos os resultados de uma coluna à seguinte.</p>
<p>Essa observação sugere outra abordagem para o problema inteiro – podemos converter objetos <code>Time</code> em números inteiros e aproveitar o fato de que o computador sabe trabalhar com aritmética de números inteiros.</p>
<p>Aqui está uma função que converte objetos <code>Time</code> em números inteiros:</p>
<pre><code class="language-python">def time_to_int(time):
    minutes = time.hour * 60 + time.minute
    seconds = minutes * 60 + time.second
    return seconds
</code></pre>
<p>E aqui está uma função que converte um número inteiro em um <code>Time</code> (lembre-se de que <code>divmod</code> divide o primeiro argumento pelo segundo e devolve o quociente e o resto como uma tupla):</p>
<pre><code class="language-python">def int_to_time(seconds):
    time = Time()
    minutes, time.second = divmod(seconds, 60)
    time.hour, time.minute = divmod(minutes, 60)
    return time
</code></pre>
<p>Você pode ter que pensar um pouco e fazer alguns testes, para se convencer de que essas funções estão corretas. Um modo de testá-las é ver se <code>time_to_int(int_to_time(x)) == x</code> para muitos valores de <code>x</code>. Este é um exemplo de uma verificação de consistência.</p>
<p>Uma vez que esteja convencido de que estão corretas, você pode usá-las para reescrever <code>add_time</code>:</p>
<pre><code class="language-python">def add_time(t1, t2):
    seconds = time_to_int(t1) + time_to_int(t2)
    return int_to_time(seconds)
</code></pre>
<p>Esta versão é mais curta que a original, e mais fácil de verificar. Como exercício, reescreva <code>increment</code> usando <code>time_to_int</code> e <code>int_to_time</code>.</p>
<p>Em algumas situações, converter da base 60 para a base 10 e de volta é mais difícil que apenas lidar com as horas. A conversão de base é mais abstrata; nossa intuição para lidar com valores temporais é melhor.</p>
<p>No entanto, se tivermos discernimento para lidar com horas como números de base 60 e investirmos esforço em escrever as funções de conversão (<code>time_to_int</code> e <code>int_to_time</code>), chegamos a um programa que é mais curto, mais fácil de ler e depurar, e mais confiável.</p>
<p>Também é mais fácil acrescentar recursos depois. Por exemplo, imagine subtrair dois objetos <code>Time</code> para encontrar a duração entre eles. Uma abordagem ingênua seria implementar a subtração com transporte. Porém, usar funções de conversão seria mais fácil e, provavelmente, mais correto.</p>
<p>Ironicamente, tornar um problema mais difícil (ou mais geral) facilita (porque há menos casos especiais e menos oportunidades de erro).</p>
<h2><a class="header" href="#165---depuração" id="165---depuração">16.5 - Depuração</a></h2>
<p>Um objeto <code>Time</code> é bem formado se os valores de <code>minute</code> e <code>second</code> estiverem entre 0 e 60 (incluindo 0, mas não 60) e se <code>hour</code> for positivo. <code>hour</code> e <code>minute</code> devem ser valores inteiros, mas podemos permitir que <code>second</code> tenha uma parte fracionária.</p>
<p>Requisitos como esses chamam-se invariáveis porque sempre devem ser verdadeiros. Para dizer de outra forma, se não forem verdadeiros, algo deu errado.</p>
<p>Escrever código para verificar requisitos invariáveis pode ajudar a descobrir erros e encontrar suas causas. Por exemplo, você pode ter uma função como valid_time, que receba um objeto Time e retorne False se ele violar um requisito <a href="16-classes-e-funcoes/06-glossario.html#invari%C3%A1vel">invariável</a>:</p>
<pre><code class="language-python">def valid_time(time):
    if time.hour &lt; 0 or time.minute &lt; 0 or time.second &lt; 0:
        return False
    if time.minute &gt;= 60 or time.second &gt;= 60:
        return False
    return True
</code></pre>
<p>No início de cada função você pode verificar os argumentos para ter certeza de que são válidos:</p>
<pre><code class="language-python">def add_time(t1, t2):
    if not valid_time(t1) or not valid_time(t2):
        raise ValueError('invalid Time object in add_time')

    seconds = time_to_int(t1) + time_to_int(t2)
    return int_to_time(seconds)
</code></pre>
<p>Ou você pode usar uma instrução <code>assert</code>, que verifica determinado requisito invariável e cria uma exceção se ela falhar:</p>
<pre><code class="language-python">def add_time(t1, t2):
    assert valid_time(t1) and valid_time(t2)
    seconds = time_to_int(t1) + time_to_int(t2)
    return int_to_time(seconds)
</code></pre>
<p>Instruções assert são úteis porque distinguem o código que lida com condições normais do código que verifica erros.</p>
<h2><a class="header" href="#166---glossário" id="166---glossário">16.6 - Glossário</a></h2>
<h5><a class="header" href="#protótipo-e-correção" id="protótipo-e-correção">protótipo e correção</a></h5>
<p>    Plano de desenvolvimento no qual a escrita do programa parte de um esboço inicial, e depois segue ao teste e correção de erros, conforme sejam encontrados.</p>
<h5><a class="header" href="#desenvolvimento-planejado" id="desenvolvimento-planejado">desenvolvimento planejado</a></h5>
<p>    Plano de desenvolvimento que implica uma compreensão de alto nível do problema e mais planejamento que desenvolvimento incremental ou desenvolvimento prototipado.</p>
<h5><a class="header" href="#função-pura" id="função-pura">função pura</a></h5>
<p>    Função que não altera nenhum dos objetos que recebe como argumento. A maior parte das funções puras gera resultado.</p>
<h5><a class="header" href="#modificador" id="modificador">modificador</a></h5>
<p>    Função que modifica um ou vários dos objetos que recebe como argumento. A maior parte dos modificadores são nulos; isto é, retornam None.</p>
<h5><a class="header" href="#programação-funcional" id="programação-funcional">programação funcional</a></h5>
<p>    Estilo de projeto de programa no qual a maioria das funções são puras.</p>
<h5><a class="header" href="#invariável" id="invariável">invariável</a></h5>
<p>    Condição que sempre deve ser verdadeira durante a execução de um programa.</p>
<h5><a class="header" href="#instrução-assert" id="instrução-assert">instrução assert</a></h5>
<p>    Instrução que verifica uma condição e levanta uma exceção se esta falhar.</p>
<h2><a class="header" href="#167---exercícios" id="167---exercícios">16.7 - Exercícios</a></h2>
<p>Os exemplos de código deste capítulo estão disponíveis em <a href="http://thinkpython2.com/code/Time1.py">http://thinkpython2.com/code/Time1.py</a>; as soluções para os exercícios estão disponíveis em <a href="http://thinkpython2.com/code/Time1_soln.py">http://thinkpython2.com/code/Time1_soln.py</a>.</p>
<h3><a class="header" href="#exercício-161" id="exercício-161">Exercício 16.1</a></h3>
<p>Escreva uma função chamada <code>mul_time</code> que receba um objeto <code>Time</code> e um número e retorne um novo objeto <code>Time</code> que contenha o produto do <code>Time</code> original e do número.</p>
<p>Então use <code>mul_time</code> para escrever uma função que receba um objeto <code>Time</code> representando o tempo até o fim de uma corrida e um número que represente a distância, e retorne um objeto <code>Time</code> com o passo médio (tempo por milha).</p>
<h3><a class="header" href="#exercício-162" id="exercício-162">Exercício 16.2</a></h3>
<p>O módulo <code>datetime</code> fornece objetos <code>time</code> que são semelhantes aos objetos <code>Time</code> deste capítulo, mas ele oferece um grande conjunto de métodos e operadores. Leia a documentação em <a href="http://docs.python.org/3/library/datetime.html">http://docs.python.org/3/library/datetime.html</a>.</p>
<ol>
<li>
<p>Use o módulo <code>datetime</code> para escrever um programa que receba a data atual e exiba o dia da semana.</p>
</li>
<li>
<p>Escreva um programa que receba um aniversário como entrada e exiba a idade do usuário e o número de dias, horas, minutos e segundos até o seu próximo aniversário.</p>
</li>
<li>
<p>Para duas pessoas nascidas em dias diferentes, há um dia em que a idade de uma equivale a duas vezes a da outra. Este é o Dia Duplo delas. Escreva um programa que receba dois aniversários e calcule o Dia Duplo dos aniversariantes.</p>
</li>
<li>
<p>Para um desafio um pouco maior, escreva a versão mais geral que calcule o dia em que uma pessoa é N vezes mais velha que a outra.</p>
</li>
</ol>
<h1><a class="header" href="#capítulo-17-classes-e-métodos" id="capítulo-17-classes-e-métodos">Capítulo 17: Classes e métodos</a></h1>
<p>Embora estejamos usando alguns recursos de orientação a objeto do Python, os programas dos dois últimos capítulos não são realmente orientados a objeto, porque não representam as relações entre os tipos definidos pelo programador e as funções que os produzem. O próximo passo é transformar essas funções em métodos que tornem as relações claras.</p>
<p>Os exemplos de código deste capítulo estão disponíveis em <a href="http://thinkpython2.com/code/Time2.py">http://thinkpython2.com/code/Time2.py</a> e as soluções para os exercícios estão em <a href="http://thinkpython2.com/code/Point2_soln.py">http://thinkpython2.com/code/Point2_soln.py</a>.</p>
<h2><a class="header" href="#171---recursos-de-orientação-a-objeto" id="171---recursos-de-orientação-a-objeto">17.1 - Recursos de orientação a objeto</a></h2>
<p>Python é uma linguagem de <a href="17-classes-e-metodos/12-glossario.html#programa%C3%A7%C3%A3o-orientada-a-objeto">programação orientada a objeto</a>, ou seja, ela oferece recursos de programação orientada a objeto que tem a seguintes características:</p>
<ul>
<li>
<p>Os programas incluem definições de classes e métodos.</p>
</li>
<li>
<p>A maior parte dos cálculos é expressa em termos de operações em objetos.</p>
</li>
<li>
<p>Os objetos muitas vezes representam coisas no mundo real, e os métodos muitas vezes correspondem às formas em que as coisas no mundo real interagem.</p>
</li>
</ul>
<p>Por exemplo, a classe <code>Time</code> definida no Capítulo 16 corresponde à forma como as pessoas registram a hora do dia, e as funções que definimos correspondem aos tipos de coisas que as pessoas fazem com os horários. De forma similar, as classes <code>Point</code> e <code>Rectangle</code> no Capítulo 15 correspondem aos conceitos matemáticos de ponto e retângulo.</p>
<p>Por enquanto, não aproveitamos os recursos que o Python oferece para programação orientada a objeto. Esses recursos não são estritamente necessários; a maioria deles oferece uma sintaxe alternativa para coisas que já fizemos. No entanto, em muitos casos, a alternativa é mais concisa e representa de forma mais exata a estrutura do programa.</p>
<p>Por exemplo, em <code>Time1.py</code> não há nenhuma conexão óbvia entre a definição de classe e as definições de função que seguem. Com um pouco de atenção, é evidente que cada função recebe pelo menos um objeto Time como argumento.</p>
<p>Essa observação é a motivação para usar métodos; um <a href="17-classes-e-metodos/12-glossario.html#m%C3%A9todo">método</a> é uma função associada a determinada classe. Vimos métodos de string, listas, dicionários e tuplas. Neste capítulo definiremos métodos para tipos definidos pelo programador.</p>
<p>Métodos são semanticamente o mesmo que funções, mas há duas diferenças sintáticas:</p>
<ul>
<li>
<p>Os métodos são definidos dentro de uma definição de classe para tornar clara a relação entre a classe e o método.</p>
</li>
<li>
<p>A sintaxe para invocar um método é diferente da sintaxe para chamar uma função.</p>
</li>
</ul>
<p>Nas próximas seções tomaremos as funções dos dois capítulos anteriores e as transformaremos em métodos. Essa transformação é puramente mecânica; você pode fazê-la seguindo uma série de passos. Se estiver à vontade para fazer a conversão entre uma forma e outra, sempre poderá escolher a melhor forma para contemplar os seus objetivos.</p>
<h2><a class="header" href="#172---exibição-de-objetos" id="172---exibição-de-objetos">17.2 - Exibição de objetos</a></h2>
<p>No Capítulo 16 definimos uma classe chamada Time em “Time”, na página 231, e você escreveu uma função denominada <code>print_time</code>:</p>
<pre><code class="language-python">class Time:
    &quot;&quot;&quot;Represents the time of day.&quot;&quot;&quot;

def print_time(time):
    print('%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second))
</code></pre>
<p>Para chamar esta função, você precisa passar um objeto Time como argumento:</p>
<pre><code class="language-python">&gt;&gt;&gt; start = Time()
&gt;&gt;&gt; start.hour = 9
&gt;&gt;&gt; start.minute = 45
&gt;&gt;&gt; start.second = 00
&gt;&gt;&gt; print_time(start)
09:45:00
</code></pre>
<p>Para fazer de <code>print_time</code> um <a href="17-classes-e-metodos/12-glossario.html#m%C3%A9todo">método</a>, tudo o que precisamos fazer é mover a definição da função para dentro da definição da classe. Note a alteração na endentação:</p>
<pre><code class="language-python">class Time:
    def print_time(time):
        print('%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second))
</code></pre>
<p>Agora há duas formas de chamar <code>print_time</code>. A primeira forma (e menos comum) é usar a sintaxe de função:</p>
<pre><code class="language-python">&gt;&gt;&gt; Time.print_time(start)
09:45:00
</code></pre>
<p>Nesse uso da notação de ponto, Time é o nome da classe, e <code>print_time</code> é o nome do método. <code>start</code> é passado como um parâmetro.</p>
<p>A segunda forma (e mais concisa) é usar a sintaxe de método:</p>
<pre><code class="language-python">&gt;&gt;&gt; start.print_time()
09:45:00
</code></pre>
<p>Nesse uso da notação de ponto, <code>print_time</code> é o nome do método (novamente), e <code>start</code> é o objeto no qual o método é invocado, que se chama de <a href="17-classes-e-metodos/12-glossario.html#sujeito">sujeito</a>. Assim como em uma sentença, onde o sujeito é o foco da escrita, o sujeito de uma invocação de método é o foco do método.</p>
<p>Dentro do método, o sujeito é atribuído ao primeiro parâmetro, portanto, neste caso, <code>start</code> é atribuído a <code>time</code>.</p>
<p>Por convenção, o primeiro parâmetro de um método chama-se <code>self</code>, então seria mais comum escrever <code>print_time</code> desta forma:</p>
<pre><code class="language-python">class Time:
    def print_time(self):
        print('%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second))
</code></pre>
<p>A razão dessa convenção é uma metáfora implícita:</p>
<ul>
<li>
<p>A sintaxe de uma chamada de função, <code>print_time(start)</code>, sugere que a função é o agente ativo. Ela diz algo como: “Ei, <code>print_time</code>! Aqui está um objeto para você exibir”.</p>
</li>
<li>
<p>Na [programação orientada a objeto](12-glossario.md#programação-orientada a-objeto), os objetos são os agentes ativos. Uma invocação de método <code>como start.print_time()</code> diz: “Ei, <code>start</code>! Por favor, exiba-se”.</p>
</li>
</ul>
<p>Essa mudança de perspectiva pode ser mais polida, mas não é óbvio que seja útil. Nos exemplos que vimos até agora, pode não ser. Porém, às vezes, deslocar a responsabilidade das funções para os objetos permite escrever funções (ou métodos) mais versáteis e facilita a manutenção e reutilização do código.</p>
<p>Como exercício, reescreva <code>time_to_int</code> (de “Prototipação versus planejamento”, na página 234) como um método. Você pode ficar tentado a reescrever <code>int_to_time</code> como um método também, mas isso não faz muito sentido porque não haveria nenhum objeto sobre o qual invocá-lo.</p>
<h2><a class="header" href="#173---outro-exemplo" id="173---outro-exemplo">17.3 - Outro exemplo</a></h2>
<p>Aqui está uma versão de increment (de “Modificadores”, na página 233) reescrita como <a href="17-classes-e-metodos/12-glossario.html#m%C3%A9todo">método</a>:</p>
<pre><code class="language-python"># dentro da classe Time:
    def increment(self, seconds):
        seconds += self.time_to_int()
        return int_to_time(seconds)
</code></pre>
<p>Essa versão assume que <code>time_to_int</code> seja escrita como método. Além disso, observe que é uma função pura, não um modificador.</p>
<p>É assim que eu invocaria increment:</p>
<pre><code class="language-python">&gt;&gt;&gt; start.print_time()
09:45:00
&gt;&gt;&gt; end = start.increment(1337)
&gt;&gt;&gt; end.print_time()
10:07:17
</code></pre>
<p>O <a href="17-classes-e-metodos/12-glossario.html#sujeito">sujeito</a>, start, é atribuído ao primeiro parâmetro, self. O argumento, 1337, é atribuído ao segundo parâmetro, seconds.</p>
<p>Esse mecanismo pode ser confuso, especialmente se você fizer um erro. Por exemplo, se invocar increment com dois argumentos, recebe:</p>
<pre><code class="language-python">&gt;&gt;&gt; end = start.increment(1337, 460)
TypeError: increment() takes 2 positional arguments but 3 were given
</code></pre>
<p>A mensagem de erro é inicialmente confusa, porque há só dois argumentos entre parênteses. No entanto, o sujeito também é considerado um argumento, então, somando tudo, são três.</p>
<p>A propósito, um <a href="17-classes-e-metodos/12-glossario.html#argumento-posicional">argumento posicional</a> é o que não tem um nome de parâmetro; isto é, não é um argumento de palavra-chave. Nesta chamada da função:</p>
<pre><code class="language-python">sketch(parrot, cage, dead=True)
</code></pre>
<p>parrot e cage são posicionais, e dead é um argumento de palavra-chave.</p>
<h2><a class="header" href="#174---um-exemplo-mais-complicado" id="174---um-exemplo-mais-complicado">17.4 - Um exemplo mais complicado</a></h2>
<p>Reescrever <code>is_after</code> (de “Time”, na página 231) é ligeiramente mais complicado, porque ela recebe dois objetos Time como parâmetros. Nesse caso, a convenção é denominar o primeiro parâmetro self e o segundo parâmetro other:</p>
<pre><code class="language-python"># dentro da classe Time:

    def is_after(self, other):
        return self.time_to_int() &gt; other.time_to_int()
</code></pre>
<p>Para usar este <a href="17-classes-e-metodos/12-glossario.html#m%C3%A9todo">método</a>, você deve invocá-lo para um objeto e passar outro como argumento:</p>
<pre><code class="language-python">&gt;&gt;&gt; end.is_after(start)
True
</code></pre>
<p>Uma vantagem desta sintaxe é que é quase literal em inglês: “o fim é depois da partida?”.</p>
<h2><a class="header" href="#175---método-init" id="175---método-init">17.5 - Método init</a></h2>
<p>O <a href="17-classes-e-metodos/12-glossario.html#m%C3%A9todo">método</a> <code>__init__</code> (abreviação da palavra em inglês para “inicialização”) é um método especial, invocado quando um objeto é instanciado. Seu nome completo é <code>__init__</code> (dois caracteres de sublinhado, seguidos de init, e mais dois sublinhados). Um método <code>__init__</code> da classe Time pode ser algo assim:</p>
<pre><code class="language-python"># dentro da classe Time:

    def __init__(self, hour=0, minute=0, second=0):
        self.hour = hour
        self.minute = minute
        self.second = second
</code></pre>
<p>É comum que os parâmetros de <code>__init__</code> tenham os mesmos nomes que os atributos. A instrução</p>
<pre><code class="language-python">        self.hour = hour
</code></pre>
<p>guarda o valor do parâmetro <code>hour</code> como um atributo de <code>self</code>.</p>
<p>Os parâmetros são opcionais, então, se você chamar Time sem argumentos, recebe os valores padrão:</p>
<pre><code class="language-python">&gt;&gt;&gt; time = Time()
&gt;&gt;&gt; time.print_time()
00:00:00
</code></pre>
<p>Se incluir um argumento, ele define hour.</p>
<pre><code class="language-python">&gt;&gt;&gt; time = Time (9)
&gt;&gt;&gt; time.print_time()
09:00:00
</code></pre>
<p>Se fornecer dois argumentos, hour e minute serão definidos:</p>
<pre><code class="language-python">&gt;&gt;&gt; time = Time(9, 45)
&gt;&gt;&gt; time.print_time()
09:45:00
</code></pre>
<p>E se você fornecer três argumentos, os três valores serão definidos.</p>
<p>Como exercício, escreva um método init da classe Point que receba x e y como parâmetros opcionais e os relacione aos atributos correspondentes.</p>
<h2><a class="header" href="#176---método-__str__" id="176---método-__str__">17.6 - Método <code>__str__</code></a></h2>
<p><code>__str__</code> é um <a href="17-classes-e-metodos/12-glossario.html#m%C3%A9todo">método</a> especial, como <code>__init__</code>, usado para retornar uma representação de string de um objeto.</p>
<p>Por exemplo, aqui está um método str para objetos Time:</p>
<pre><code class="language-python"># dentro da classe Time:

    def __str__(self):
        return '%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second)
</code></pre>
<p>Ao exibir um objeto com print, o Python invoca o método str:</p>
<pre><code class="language-python">&gt;&gt;&gt; time = Time(9, 45)
&gt;&gt;&gt; print(time)
09:45:00
</code></pre>
<p>Quando escrevo uma nova classe, quase sempre começo escrevendo <code>__init__</code>, o que facilita a instanciação de objetos, e <code>__str__</code>, que é útil para a depuração.</p>
<p>Como exercício, escreva um método str da classe Point. Crie um objeto Point e exiba-o.</p>
<h2><a class="header" href="#177---sobrecarga-de-operadores" id="177---sobrecarga-de-operadores">17.7 - Sobrecarga de operadores</a></h2>
<p>Ao definir outros métodos especiais, você pode especificar o comportamento de operadores nos tipos definidos pelo programador. Por exemplo, se você definir um <a href="17-classes-e-metodos/12-glossario.html#m%C3%A9todo">método</a> chamado <code>__add__</code> para a classe Time de Time, pode usar o operador + em objetos Time.</p>
<p>A definição pode ser assim:</p>
<pre><code class="language-python"># dentro da classe Time:

    def __add__(self, other):
        seconds = self.time_to_int() + other.time_to_int()
        return int_to_time(seconds)
</code></pre>
<p>Você pode usá-lo assim:</p>
<pre><code class="language-python">&gt;&gt;&gt; start = Time(9, 45)
&gt;&gt;&gt; duration = Time(1, 35)
&gt;&gt;&gt; print(start + duration)
11:20:00
</code></pre>
<p>Ao aplicar o operador + a objetos Time, o Python invoca <code>__add__</code>. Ao exibir o resultado, o Python invoca <code>__str__</code>. Ou seja, há muita coisa acontecendo nos bastidores!</p>
<p>Alterar o comportamento de um operador para que funcione com tipos definidos pelo programador chama-se sobrecarga de operadores. Para cada operador no Python há um método especial correspondente, como <code>__add__</code>. Para obter mais informações, veja <a href="http://docs.python.org/3/reference/datamodel.html#specialnames">http://docs.python.org/3/reference/datamodel.html#specialnames</a>.</p>
<p>Como exercício, escreva um método add para a classe Point.</p>
<h2><a class="header" href="#178---despacho-por-tipo" id="178---despacho-por-tipo">17.8 - Despacho por tipo</a></h2>
<p>Na seção anterior, acrescentamos dois objetos Time, mas você também pode querer acrescentar um número inteiro a um objeto Time. A seguir, veja uma versão de <code>__add__</code>, que verifica o tipo de other e invoca <code>add_time</code> ou increment:</p>
<pre><code class="language-python"># dentro da classe Time:
    def __add__(self, other):
        if isinstance(other, Time):
            return self.add_time(other)
        else:
            return self.increment(other)

    def add_time(self, other):
        seconds = self.time_to_int() + other.time_to_int()
        return int_to_time(seconds)

    def increment(self, seconds):
        seconds += self.time_to_int()
        return int_to_time(seconds)
</code></pre>
<p>A função construída isinstance recebe um valor e um objeto de classe e retorna True se o valor for uma instância da classe.</p>
<p>Se other for um objeto Time, <code>__add__</code> invoca <code>add_time</code>. Do contrário, assume que o parâmetro seja um número e invoca increment. Essa operação chama-se <a href="17-classes-e-metodos/12-glossario.html#despacho-por-tipo">despacho por tipo</a> porque despacha a operação a métodos diferentes, baseados no tipo dos argumentos.</p>
<p>Veja exemplos que usam o operador <code>+</code> com tipos diferentes:</p>
<pre><code class="language-python">&gt;&gt;&gt; start = Time(9, 45)
&gt;&gt;&gt; duration = Time(1, 35)
&gt;&gt;&gt; print(start + duration)
11:20:00
&gt;&gt;&gt; print(start + 1337)
10:07:17
</code></pre>
<p>Infelizmente, esta implementação da adição não é comutativa. Se o número inteiro for o primeiro operando, você recebe</p>
<pre><code class="language-python">&gt;&gt;&gt; print(1337 + start)
TypeError: unsupported operand type(s) for +: 'int' and 'instance'
</code></pre>
<p>O problema é que, em vez de pedir ao objeto Time que adicione um número inteiro, o Python está pedindo que um número inteiro adicione um objeto Time, e ele não sabe como fazer isso. Entretanto, há uma solução inteligente para este problema: o <a href="17-classes-e-metodos/12-glossario.html#m%C3%A9todo">método</a> especial <code>__radd__</code>, que significa “adição à direita”. Esse método é invocado quando um objeto Time aparece no lado direito do operador +. Aqui está a definição:</p>
<pre><code class="language-python"># dentro da classe Time:
    def __radd__(self, other):
        return self.__add__(other)
</code></pre>
<p>E é assim que ele é usado:</p>
<pre><code class="language-python">&gt;&gt;&gt; print(1337 + start)
10:07:17
</code></pre>
<p>Como exercício, escreva um método add para Points que funcione com um objeto Point ou com uma tupla:</p>
<ul>
<li>
<p>Se o segundo operando for um Point, o método deve retornar um novo Point cuja coordenada x é a soma das coordenadas x dos operandos, e o mesmo se aplica às coordenadas de y.</p>
</li>
<li>
<p>Se o segundo operando for uma tupla, o método deve adicionar o primeiro elemento da tupla à coordenada de x e o segundo elemento à coordenada de y, retornando um novo Point com o resultado.</p>
</li>
</ul>
<h2><a class="header" href="#179---polimorfismo" id="179---polimorfismo">17.9 - Polimorfismo</a></h2>
<p>O <a href="17-classes-e-metodos/12-glossario.html#despacho-por-tipo">despacho por tipo</a> é útil, mas (felizmente) nem sempre é necessário. Muitas vezes, você pode evitá-lo escrevendo funções que funcionem corretamente para argumentos de tipos diferentes.</p>
<p>Muitas das funções que escrevemos para strings também funcionam para outros tipos de sequência. Por exemplo, em “Um dicionário como uma coleção de contadores”, na página 163, usamos histogram para contar o número de vezes que cada letra aparece numa palavra:</p>
<pre><code class="language-python">def histogram(s):
    d = dict()
    for c in s:
        if c not in d:
            d[c] = 1
        else:
            d[c] = d[c] + 1
    return d
</code></pre>
<p>Essa função também funciona com listas, tuplas e até dicionários, desde que os elementos de s sejam hashable, então eles podem ser usados como chaves em d:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = ['spam', 'egg', 'spam', 'spam', 'bacon', 'spam']
&gt;&gt;&gt; histogram(t)
{'bacon': 1, 'egg': 1, 'spam': 4}
</code></pre>
<p>As funções que funcionam com vários tipos chamam-se polimórficas. O polimorfismo pode facilitar a reutilização do código. Por exemplo, a função integrada sum, que adiciona os elementos de uma sequência, funciona só se os elementos da sequência forem compatíveis com adição.</p>
<p>Como os objetos Time oferecem o <a href="17-classes-e-metodos/12-glossario.html#m%C3%A9todo">método</a> add, eles funcionam com sum:</p>
<pre><code class="language-python">&gt;&gt;&gt; t1 = Time(7, 43)
&gt;&gt;&gt; t2 = Time(7, 41)
&gt;&gt;&gt; t3 = Time(7, 37)
&gt;&gt;&gt; total = sum([t1, t2, t3])
&gt;&gt;&gt; print(total)
23:01:00
</code></pre>
<p>Em geral, se todas as operações dentro de uma função forem compatíveis com um dado tipo, não haverá problemas.</p>
<p>O melhor tipo de polimorfismo é o não intencional, quando você descobre que uma função que já escreveu pode ser aplicada a um tipo para o qual ela não tinha planejada.</p>
<h2><a class="header" href="#1710---interface-e-implementação" id="1710---interface-e-implementação">17.10 - Interface e implementação</a></h2>
<p>Uma das metas do projeto orientado a objeto é facilitar a manutenção do programa, para que você possa mantê-lo funcionando quando outras partes do sistema forem alteradas, e também poder alterar o programa para satisfazer novas condições.</p>
<p>Um princípio de projeto que ajuda a atingir essa meta é manter as interfaces separadas das implementações. Para objetos, isso quer dizer que os métodos que uma classe oferece não devem depender de como os atributos são representados.</p>
<p>Por exemplo, neste capítulo desenvolvemos uma classe que representa uma hora do dia. Os métodos fornecidos por esta classe incluem time_to_int, is_after e add_time.</p>
<p>Podemos implementar esses métodos de várias formas. Os detalhes da implementação dependem de como representamos as horas. Neste capítulo, os atributos de um objeto Time são hour, minute e second.</p>
<p>Como alternativa, podemos substituir esses atributos por um número inteiro único que represente o número de segundos desde a meia-noite. Essa implementação faria com que alguns métodos, como is_after, fossem mais fáceis de escrever, mas dificultaria o uso de outros métodos.</p>
<p>Pode acontecer que, depois de implementar uma nova classe, você descubra uma implementação melhor. Se outras partes do programa estiverem usando a sua classe, mudar a interface pode ser trabalhoso e induzir a erros.</p>
<p>No entanto, se projetou a interface cuidadosamente, pode alterar a implementação sem mudar a interface, e não será preciso mudar outras partes do programa.</p>
<h2><a class="header" href="#1711---depuração" id="1711---depuração">17.11 - Depuração</a></h2>
<p>É legal acrescentar atributos a objetos em qualquer ponto da execução de um programa, mas se você tiver objetos do mesmo tipo que não têm os mesmos atributos, é fácil cometer erros. É uma boa ideia inicializar todos os atributos de um objeto no <a href="17-classes-e-metodos/12-glossario.html#m%C3%A9todo">método</a> init.</p>
<p>Caso não tenha certeza se um objeto tem um determinado atributo, você pode usar a função integrada hasattr (ver “Depuração”, na página 236).</p>
<p>Outra forma de acessar atributos é com a função integrada vars, que recebe um objeto e retorna um dicionário que mapeia os nomes dos atributos (como strings) aos seus valores:</p>
<pre><code class="language-python">&gt;&gt;&gt; p = Point(3, 4)
&gt;&gt;&gt; vars(p)
{'y': 4, 'x': 3}
</code></pre>
<p>Para facilitar a depuração, pode ser útil usar esta função:</p>
<pre><code class="language-python">def print_attributes(obj):
    for attr in vars(obj):
        print(attr, getattr(obj, attr))
</code></pre>
<p><code>print_attributes</code> atravessa o dicionário e imprime cada nome de atributo e o seu valor correspondente.</p>
<p>A função integrada getattr recebe um objeto e um nome de atributo (como uma string) e devolve o valor do atributo.</p>
<h2><a class="header" href="#1712---glossário" id="1712---glossário">17.12 - Glossário</a></h2>
<h5><a class="header" href="#linguagem-orientada-a-objeto" id="linguagem-orientada-a-objeto">linguagem orientada a objeto</a></h5>
<p>    Linguagem que fornece recursos, como tipos definidos pelo programador e métodos, que facilitam a programação orientada a objeto.</p>
<h5><a class="header" href="#programação-orientada-a-objeto" id="programação-orientada-a-objeto">programação orientada a objeto</a></h5>
<p>    Estilo de programação na qual os dados e as operações que os manipulam são organizadas em classes e métodos.</p>
<h5><a class="header" href="#método-1" id="método-1">método</a></h5>
<p>    Função criada dentro de uma definição de classe e invocada em instâncias desta classe.</p>
<h5><a class="header" href="#sujeito" id="sujeito">sujeito</a></h5>
<p>    Objeto sobre o qual um método é invocado.</p>
<h5><a class="header" href="#argumento-posicional" id="argumento-posicional">argumento posicional</a></h5>
<p>    Argumento que não inclui um nome de parâmetro, portanto não é um argumento de palavra-chave.</p>
<h5><a class="header" href="#sobrecarga-de-operador" id="sobrecarga-de-operador">sobrecarga de operador</a></h5>
<p>    Alteração do comportamento de um operador como + para que funcione com um tipo definido pelo programador.</p>
<h5><a class="header" href="#despacho-por-tipo" id="despacho-por-tipo">despacho por tipo</a></h5>
<p>    Modelo de programação que invoca funções diferentes dependendo do tipo do operando.</p>
<h5><a class="header" href="#polimórfico" id="polimórfico">polimórfico</a></h5>
<p>    Pertinente a uma função que pode funcionar com mais de um tipo.</p>
<h5><a class="header" href="#ocultamento-de-informação" id="ocultamento-de-informação">ocultamento de informação</a></h5>
<p>    Princípio segundo o qual a interface fornecida por um objeto não deve depender da sua implementação, especialmente em relação à representação dos seus atributos.</p>
<h2><a class="header" href="#1713---exercícios" id="1713---exercícios">17.13 - Exercícios</a></h2>
<h3><a class="header" href="#exercício-171" id="exercício-171">Exercício 17.1</a></h3>
<p>Baixe o código deste capítulo em <a href="http://thinkpython2.com/code/Time2.py">http://thinkpython2.com/code/Time2.py</a>. Altere os atributos de Time para que um número inteiro único represente os segundos decorridos desde a meia-noite. Então altere os métodos (e a função int_to_time) para funcionar com a nova implementação. Você não deve modificar o código de teste em main. Ao terminar, a saída deve ser a mesma que antes.</p>
<p>Solução: <a href="http://thinkpython2.com/code/Time2_soln.py">http://thinkpython2.com/code/Time2_soln.py</a>.</p>
<h3><a class="header" href="#exercício-172" id="exercício-172">Exercício 17.2</a></h3>
<p>Este exercício é uma história com moral sobre um dos erros mais comuns e difíceis de encontrar no Python. Escreva uma definição de classe chamada Kangaroo com os seguintes métodos:</p>
<ol>
<li>
<p>Um <a href="17-classes-e-metodos/12-glossario.html#m%C3%A9todo">método</a> <code>__init__</code> que inicialize um atributo chamado <code>pouch_contents</code>  em uma lista vazia.</p>
</li>
<li>
<p>Um método chamado <code>put_in_pouch</code> que receba um objeto de qualquer tipo e o acrescente a <code>pouch_contents</code>.</p>
</li>
<li>
<p>Um método <code>__str__</code> que retorne uma representação de string do objeto Kangaroo e os conteúdos de pouch (bolsa).</p>
</li>
</ol>
<p>Teste o seu código criando dois objetos Kangaroo, atribuindo-os a variáveis chamadas kanga e roo, e então acrescentando roo ao conteúdo da bolsa de kanga.</p>
<p>Baixe <a href="http://thinkpython2.com/code/BadKangaroo.py">http://thinkpython2.com/code/BadKangaroo.py</a>. Ele contém uma solução para o problema anterior com um defeito bem grande e bem feio. Encontre e corrija o defeito.</p>
<p>Se não conseguir achar a solução, você pode baixar <a href="http://thinkpython2.com/code/GoodKangaroo.py">http://thinkpython2.com/code/GoodKangaroo.py</a>, que explica o problema e demonstra uma solução.</p>
<h1><a class="header" href="#capítulo-18-herança" id="capítulo-18-herança">Capítulo 18: Herança</a></h1>
<p>O termo mais associado com a programação orientada a objeto é <a href="18-heranca/11-glossario.html#heran%C3%A7a">herança</a>. A herança é a capacidade de definir uma nova classe que seja uma versão modificada de uma classe existente. Neste capítulo demonstrarei a herança usando classes que representam jogos de cartas, baralhos e mãos de pôquer.</p>
<p>Se você não joga pôquer, pode ler sobre ele em <a href="http://en.wikipedia.org/wiki/Poker">http://en.wikipedia.org/wiki/Poker</a>, mas não é necessário; vou dizer tudo o que precisa saber para os exercícios.</p>
<p>Os exemplos de código deste capítulo estão disponíveis em <a href="http://thinkpython2.com/code/Card.py">http://thinkpython2.com/code/Card.py</a>.</p>
<h2><a class="header" href="#181---objetos-card" id="181---objetos-card">18.1 - Objetos Card</a></h2>
<p>Há 52 cartas em um baralho, e cada uma pertence a 1 dos 4 naipes e a 1 dos 13 valores. Os naipes são espadas, copas, ouros e paus (no bridge, em ordem descendente). A ordem dos valores é ás, 2, 3, 4, 5, 6, 7, 8, 9, 10, valete, dama e rei. Dependendo do jogo que estiver jogando, um ás pode ser mais alto que o rei ou mais baixo que 2.</p>
<p>Se quiséssemos definir um novo objeto para representar uma carta de jogo, os atributos óbvios seriam rank (valor) e suit (naipe). Mas não é tão óbvio qual tipo de atributo deveriam ser. Uma possibilidade é usar strings com palavras como 'Spade' (Espadas) para naipes e 'Queen' (Dama) para valores. Um problema com esta implementação é que não seria fácil comparar cartas para ver qual valor ou naipe tem classificação mais alta em relação aos outros.</p>
<p>Uma alternativa é usar números inteiros para <a href="18-heranca/11-glossario.html#codificar">codificar</a> os valores e os naipes. Neste contexto, “codificar” significa que vamos definir um mapeamento entre números e naipes, ou entre números e valores. Este tipo de codificação não tem nada a ver com criptografia.</p>
<p>Por exemplo, esta tabela mostra os naipes e os códigos de número inteiro correspondentes:</p>
<pre><code>Spades (Espadas)     ↦ 3
Hearts (Copas)       ↦ 2
Diamonds (Ouros)     ↦ 1
Clubs (Paus)         ↦ 0
</code></pre>
<p>Este código facilita a comparação entre as cartas; como naipes mais altos mapeiam a números mais altos, podemos comparar naipes aos seus códigos.</p>
<p>O mapeamento de valores é até óbvio; cada um dos valores numéricos é mapeado ao número inteiro correspondente, e para cartas com figuras:</p>
<pre><code>Jack (Valete)       ↦ 11
Queen (Dama)        ↦ 12
King (Rei)          ↦ 13
</code></pre>
<p>Estou usando o símbolo <code>↦</code> para deixar claro que esses mapeamentos não são parte do programa em Python. Eles são parte do projeto do programa, mas não aparecem explicitamente no código.</p>
<p>A definição de classe para Card (carta) é assim:</p>
<pre><code class="language-python">class Card:
    &quot;&quot;&quot;Represents a standard playing card.&quot;&quot;&quot;
    def __init__(self, suit=0, rank=2):
        self.suit = suit
        self.rank = rank
</code></pre>
<p>Como sempre, o método <code>__init__</code> recebe um parâmetro opcional de cada atributo. A carta padrão é 2 de paus.</p>
<p>Para criar um Card, você chama Card com o naipe e valor desejados:</p>
<pre><code class="language-python">queen_of_diamonds = Card(1, 12)
</code></pre>
<h2><a class="header" href="#182---atributos-de-classe" id="182---atributos-de-classe">18.2 - Atributos de classe</a></h2>
<p>Para exibir objetos Card de uma forma que as pessoas possam ler com facilidade, precisamos de um mapeamento dos códigos de número inteiro aos naipes e valores correspondentes. Uma forma natural de fazer isso é com listas de strings. Atribuímos essas listas a atributos de classe:</p>
<pre><code class="language-python"># dentro da classe Card:

    suit_names = ['Clubs', 'Diamonds', 'Hearts', 'Spades']
    rank_names = [None, 'Ace', '2', '3', '4', '5', '6', '7',
                  '8', '9', '10', 'Jack', 'Queen', 'King']

    def __str__(self):
        return '%s of %s' % (Card.rank_names[self.rank],
                             Card.suit_names[self.suit])
</code></pre>
<p>Variáveis como <code>suit_names</code> e <code>rank_names</code>, que são definidas dentro de uma classe, mas fora de qualquer método, chamam-se atributos de classe porque são associadas com o objeto de classe Card.</p>
<p>Este termo as distingue de variáveis como <code>suit</code> e <code>rank</code>, chamadas de atributos de instância porque são associados com determinada instância.</p>
<p>Ambos os tipos de atributo são acessados usando a notação de ponto. Por exemplo, em <code>__str__</code>, <code>self</code> é um objeto <code>Card</code>, e <code>self.rank</code> é o seu valor. De forma semelhante, Card é um objeto de classe, e <code>Card.rank_names</code> é uma lista de strings associadas à essa classe.</p>
<p>Cada carta tem seu próprio suit e rank, mas há só uma cópia de suit_names e rank_names.</p>
<p>Juntando tudo, a expressão <code>Card.rank_names[self.rank]</code> significa “use o rank (valor) do atributo do objeto self como um índice na lista rank_names da classe Card e selecione a string adequada”.</p>
<p>O primeiro elemento de rank_names é None, porque não há nenhuma carta com valor zero. Incluindo None para ocupar uma variável, conseguimos fazer um belo mapeamento onde o índice 2 é associado à string '2', e assim por diante. Para evitar ter que usar esse truque, poderíamos usar um dicionário em vez de uma lista.</p>
<p>Com os métodos que temos por enquanto, podemos criar e exibir cartas:</p>
<pre><code class="language-python">&gt;&gt;&gt; card1 = Card(2, 11)
&gt;&gt;&gt; print(card1)
Jack of Hearts
</code></pre>
<p>A Figura 18.1 é um diagrama do objeto de classe Card e uma instância de Card. Card é um objeto de classe; seu tipo é type. card1 é uma instância de Card, então seu tipo é Card. Para economizar espaço, não incluí o conteúdo de suit_names e rank_names.</p>
<p><img src="18-heranca//fig/tnkp_1801.png" alt="Figura 18.1 – Diagrama de objetos: classe Card e card1, uma instância de Card" />.
<br><em>Figura 18.1 – Diagrama de objetos: classe</em> <code>Card</code> <em>e</em> <code>card1</code>, <em>uma instância de</em> <code>Card</code>.</p>
<h2><a class="header" href="#183---comparação-de-cartas" id="183---comparação-de-cartas">18.3 - Comparação de cartas</a></h2>
<p>Para tipos integrados, há operadores relacionais (<code>&lt;</code>, <code>&gt;</code>, <code>==</code> etc) que comparam valores e determinam quando um é maior, menor ou igual a outro. Para tipos definidos pelo programador, podemos ignorar o comportamento dos operadores integrados fornecendo um método denominado <code>__lt__</code>, que representa “menos que”.</p>
<p><code>__lt__</code> recebe dois parâmetros, <code>self</code> e <code>other</code>, e <code>True</code> se self for estritamente menor que <code>other</code>.</p>
<p>A ordem correta das cartas não é óbvia. Por exemplo, qual é melhor, o 3 de paus ou o 2 de ouros? Uma tem o valor mais alto, mas a outra tem um naipe mais alto. Para comparar cartas, é preciso decidir o que é mais importante, o valor ou o naipe.</p>
<p>A resposta pode depender de que jogo você está jogando, mas, para manter a simplicidade, vamos fazer a escolha arbitrária de que o naipe é mais importante, então todas as cartas de espadas são mais importantes que as de ouros, e assim por diante.</p>
<p>Com isto decidido, podemos escrever <code>__lt__</code>:</p>
<pre><code class="language-python"># dentro da classe Card:

    def __lt__(self, other):
        # conferir os naipes
        if self.suit &lt; other.suit: return True
        if self.suit &gt; other.suit: return False

        # os naipes são os mesmos... conferir valores
        return self.rank &lt; other.rank
</code></pre>
<p>Você pode escrever isso de forma mais concisa usando uma comparação de tuplas:</p>
<pre><code class="language-python"># dentro da classe Card:

    def __lt__(self, other):
        t1 = self.suit, self.rank
        t2 = other.suit, other.rank
        return t1 &lt; t2
</code></pre>
<p>Como exercício, escreva um método <code>__lt__</code> para objetos Time. Você pode usar uma comparação de tuplas, mas também pode usar a comparação de números inteiros.</p>
<h2><a class="header" href="#184---baralhos" id="184---baralhos">18.4 - Baralhos</a></h2>
<p>Agora que temos Card, o próximo passo é definir Deck (baralho). Como um baralho é composto de cartas, é natural que um baralho contenha uma lista de cartas como atributo.</p>
<p>Veja a seguir uma definição de classe para <code>Deck</code>. O método init cria o atributo cards e gera o conjunto padrão de 52 cartas:</p>
<pre><code class="language-python">class Deck:
    def __init__(self):
        self.cards = []
        for suit in range(4):
            for rank in range(1, 14):
                card = Card(suit, rank)
                self.cards.append(card)
</code></pre>
<p>A forma mais fácil de preencher o baralho é com um loop aninhado. O loop exterior enumera os naipes de 0 a 3. O loop interior enumera os valores de 1 a 13. Cada iteração cria um novo Card com o naipe e valor atual, e a acrescenta a self.cards.</p>
<h2><a class="header" href="#185---exibição-do-baralho" id="185---exibição-do-baralho">18.5 - Exibição do baralho</a></h2>
<p>Aqui está um método <strong>str</strong> para Deck:</p>
<pre><code class="language-python"># dentro da classe Deck:

    def __str__(self):
        res = []
        for card in self.cards:
            res.append(str(card))
        return '\n'.join(res)
</code></pre>
<p>Este método demonstra uma forma eficiente de acumular uma string grande: a criação de uma lista de strings e a utilização do método de string join. A função integrada str invoca o método <code>__str__</code> em cada carta e retorna a representação da string.</p>
<p>Como invocamos join em um caractere newline, as cartas são separadas por quebras de linha. O resultado é esse:</p>
<pre><code class="language-python">&gt;&gt;&gt; deck = Deck()
&gt;&gt;&gt; print(deck)
Ace of Clubs
2 of Clubs
3 of Clubs
...
10 of Spades
Jack of Spades
Queen of Spades
King of Spades
</code></pre>
<p>Embora o resultado apareça em 52 linhas, na verdade ele é uma string longa com quebras de linha.</p>
<h2><a class="header" href="#186---adição-remoção-embaralhamento-e-classificação" id="186---adição-remoção-embaralhamento-e-classificação">18.6 - Adição, remoção, embaralhamento e classificação</a></h2>
<p>Para lidar com as cartas, gostaríamos de ter um método que removesse uma carta do baralho e a devolvesse. O método de lista pop oferece uma forma conveniente de fazer isso:</p>
<pre><code class="language-python"># dentro da classe Deck:

    def pop_card(self):
        return self.cards.pop()
</code></pre>
<p>Como pop retira a última carta na lista, estamos lidando com o fundo do baralho.</p>
<p>Para adicionar uma carta, podemos usar o método de lista append:</p>
<pre><code class="language-python"># dentro da classe Deck:

    def add_card(self, card):
        self.cards.append(card)
</code></pre>
<p>Um método como esse, que usa outro método sem dar muito trabalho, às vezes é chamado de <a href="18-heranca/11-glossario.html#folheado">folheado</a>. A metáfora vem do trabalho em madeira, onde o folheado é uma camada fina de madeira de boa qualidade colada à superfície de uma madeira mais barata para melhorar a aparência.</p>
<p>Nesse caso, <code>add_card</code> é um método “fino” que expressa uma operação de lista em termos adequados a baralhos. Ele melhora a aparência ou interface da implementação.</p>
<p>Em outro exemplo, podemos escrever um método Deck denominado shuffle, usando a função shuffle do módulo random:</p>
<pre><code class="language-python"># dentro da classe Deck:

    def shuffle(self):
        random.shuffle(self.cards)
</code></pre>
<p>Não se esqueça de importar random.</p>
<p>Como exercício, escreva um método de Deck chamado sort, que use o método de lista sort para classificar as cartas em um Deck. sort usa o método <code>__lt__</code> que definimos para determinar a ordem.</p>
<h2><a class="header" href="#187---herança" id="187---herança">18.7 - Herança</a></h2>
<p>A <a href="18-heranca/11-glossario.html#heran%C3%A7a">herança</a> é a capacidade de definir uma nova classe que seja uma versão modificada de uma classe existente. Como exemplo, digamos que queremos que uma classe represente uma “mão”, isto é, as cartas mantidas por um jogador. Uma mão é semelhante a um baralho: ambos são compostos por uma coleção de cartas, e ambos exigem operações como adicionar e remover cartas.</p>
<p>Uma mão também é diferente de um baralho; há operações que queremos para mãos que não fazem sentido para um baralho. Por exemplo, no pôquer poderíamos comparar duas mãos para ver qual ganha. No bridge, poderíamos calcular a pontuação de uma mão para fazer uma aposta.</p>
<p>Essa relação entre classes – semelhante, mas diferente – adequa-se à herança. Para definir uma nova classe que herda algo de uma classe existente, basta colocar o nome da classe existente entre parênteses:</p>
<pre><code class="language-python">class Hand(Deck):
    &quot;&quot;&quot;Represents a hand of playing cards.&quot;&quot;&quot;
</code></pre>
<p>Esta definição indica que Hand herda de Deck; isso significa que podemos usar métodos como pop_card e add_card para Hand bem como para Deck.</p>
<p>Quando uma nova classe herda de uma existente, a existente chama-se pai e a nova classe chama-se filho.</p>
<p>Neste exemplo, Hand herda <code>__init__</code> de Deck, mas na verdade não faz o que queremos: em vez de preencher a mão com 52 cartas novas, o método init de Hand deve inicializar card com uma lista vazia.</p>
<p>Se fornecermos um método init na classe Hand, ele ignora o da classe Deck:</p>
<pre><code class="language-python"># dentro da classe Hand:

    def __init__(self, label=''):
        self.cards = []
        self.label = label
</code></pre>
<p>Ao criar Hand, o Python invoca este método init, não o de Deck.</p>
<pre><code class="language-python">&gt;&gt;&gt; hand = Hand('new hand')
&gt;&gt;&gt; hand.cards
[]
&gt;&gt;&gt; hand.label
'new hand'
</code></pre>
<p>Outros métodos são herdados de Deck, portanto podemos usar <code>pop_card</code> e <code>add_card</code> para lidar com uma carta:</p>
<pre><code class="language-python">&gt;&gt;&gt; deck = Deck()
&gt;&gt;&gt; card = deck.pop_card()
&gt;&gt;&gt; hand.add_card(card)
&gt;&gt;&gt; print(hand)
King of Spades
</code></pre>
<p>Um próximo passo natural seria encapsular este código em um método chamado <code>move_cards</code>:</p>
<pre><code class="language-python"># dentro da classe Deck:

    def move_cards(self, hand, num):
        for i in range(num):
            hand.add_card(self.pop_card())
</code></pre>
<p><code>move_cards</code> recebe dois argumentos, um objeto Hand e o número de cartas com que vai lidar. Ele altera tanto self como hand e retorna None.</p>
<p>Em alguns jogos, as cartas são movidas de uma mão a outra, ou de uma mão de volta ao baralho. É possível usar <code>move_cards</code> para algumas dessas operações: self pode ser um Deck ou Hand, e hand, apesar do nome, também pode ser um Deck.</p>
<p>A herança é um recurso útil. Alguns programas que poderiam ser repetitivos sem herança podem ser escritos de forma mais elegante com ela. A herança pode facilitar a reutilização de código, já que você pode personalizar o comportamento de classes pais sem ter que alterá-las. Em alguns casos, a estrutura de herança reflete a estrutura natural do problema, o que torna o projeto mais fácil de entender.</p>
<p>De outro lado, a herança pode tornar os programas difíceis de ler. Quando um método é invocado, às vezes não está claro onde encontrar sua definição. O código relevante pode ser espalhado por vários módulos. Além disso, muitas das coisas que podem ser feitas usando a herança podem ser feitas sem elas, às vezes, até de forma melhor.</p>
<h2><a class="header" href="#188---diagramas-de-classe" id="188---diagramas-de-classe">18.8 - Diagramas de classe</a></h2>
<p>Por enquanto vimos diagramas de pilha, que mostram o estado de um programa e diagramas de objeto, que mostram os atributos de um objeto e seus valores. Esses diagramas representam um retrato da execução de um programa, então eles mudam no decorrer da execução do programa.</p>
<p>Eles também são altamente detalhados; para alguns objetivos, detalhados demais. Um <a href="18-heranca/11-glossario.html#diagrama-de-classe">diagrama de classe</a> é uma representação mais abstrata da estrutura de um programa. Em vez de mostrar objetos individuais, ele mostra classes e as relações entre elas.</p>
<p>Há vários tipos de relações entre as classes:</p>
<ul>
<li>
<p>Os objetos de uma classe podem conter referências a objetos em outra classe. Por exemplo, cada Rectangle contém uma referência a um Point, e cada Deck contém referências a muitos Cards. Esse tipo de relação chama-se composição. É uma relação do tipo HAS-A (tem um), com a ideia de “um Rectangle tem um Point”.</p>
</li>
<li>
<p>Uma classe pode herdar de outra. Esta relação chama-se IS-A (é um), com a ideia de “um Hand é um tipo de Deck”.</p>
</li>
<li>
<p>Uma classe pode depender de outra no sentido de que os objetos em uma classe possam receber objetos na segunda classe como parâmetros ou usar esses objetos como parte de um cálculo. Este tipo de relação chama-se <a href="18-heranca/11-glossario.html#depend%C3%AAncia">dependência</a>.</p>
</li>
</ul>
<p>Um diagrama de classe é uma representação gráfica dessas relações. Por exemplo, a Figura 18.2 mostra as relações entre Card, Deck e Hand.</p>
<p><img src="18-heranca//fig/tnkp_1802.png" alt="Figura 18.2 – Diagrama de classes" />.
<br><em>Figura 18.2 – Diagrama de classes.</em></p>
<p>A flecha com um triângulo oco representa uma <a href="18-heranca/11-glossario.html#rela%C3%A7%C3%A3o-IS-A">relação IS-A</a>; nesse caso, indica que Hand herda de Deck.</p>
<p>A ponta de flecha padrão representa uma <a href="18-heranca/11-glossario.html#rela%C3%A7%C3%A3o-HAS-A">relação HAS-A</a>; nesse caso, um Deck tem referências a objetos Card.</p>
<p>A estrela <strong>*</strong>  perto da ponta de flecha indica a <a href="18-heranca/11-glossario.html#multiplicidade">multiplicidade</a>; ela indica quantos Cards um Deck tem. Uma multiplicidade pode ser um número simples como 52, um intervalo como 5..7 ou uma estrela, que indica que um Deck pode ter qualquer número de Cards.</p>
<p>Não há nenhuma dependência neste diagrama. Elas normalmente apareceriam com uma flecha tracejada. Ou, se houver muitas dependências, às vezes elas são omitidas.</p>
<p>Um diagrama mais detalhado poderia mostrar que um Deck na verdade contém uma lista de Cards, mas os tipos integrados como lista e dict não são normalmente incluídos em diagramas de classe.</p>
<h2><a class="header" href="#189---encapsulamento-de-dados" id="189---encapsulamento-de-dados">18.9 - Encapsulamento de dados</a></h2>
<p>Os capítulos anteriores demonstram um plano de desenvolvimento que poderíamos chamar de “projeto orientado a objeto”. Identificamos os objetos de que precisamos – como Point, Rectangle e Time – e definimos classes para representá-los. Em cada caso há uma correspondência óbvia entre o objeto e alguma entidade no mundo real (ou, pelo menos, no mundo matemático).</p>
<p>Mas, às vezes, é menos óbvio quais objetos você precisa e como eles devem interagir. Nesse caso é necessário um plano de desenvolvimento diferente. Da mesma forma em que descobrimos interfaces de função por encapsulamento e generalização, podemos descobrir interfaces de classe por <a href="18-heranca/11-glossario.html#encapsulamento-de-dados">encapsulamento de dados</a>.</p>
<p>A análise de Markov, de “Análise de Markov”, na página 200, apresenta um bom exemplo. Se baixar o meu código em <a href="http://thinkpython2.com/code/markov.py">http://thinkpython2.com/code/markov.py</a>, você vai ver que ele usa duas variáveis globais – suffix_map e prefix – que são lidas e escritas a partir de várias funções.</p>
<pre><code class="language-python">suffix_map = {}
prefix = ()
</code></pre>
<p>Como essas variáveis são globais, só podemos executar uma análise de cada vez. Se lermos dois textos, seus prefixos e sufixos seriam acrescentados às mesmas estruturas de dados (o que geraria textos interessantes).</p>
<p>Para executar análises múltiplas e guardá-las separadamente, podemos encapsular o estado de cada análise em um objeto. É assim que fica:</p>
<pre><code class="language-python">class Markov:
    def __init__(self):
        self.suffix_map = {}
        self.prefix = ()
</code></pre>
<p>Em seguida, transformamos as funções em métodos. Por exemplo, aqui está process_word:</p>
<pre><code class="language-python">def process_word(self, word, order=2):
    if len(self.prefix) &lt; order:
        self.prefix += (word)
        return
    try:
        self.suffix_map[self.prefix].append(word)
    except KeyError:
        # se não houver entradas deste prefixo, crie uma.
        self.suffix_map[self.prefix] = [word]

    self.prefix = shift(self.prefix, word)
</code></pre>
<p>Transformar um programa como esse – alterando o projeto sem mudar o comportamento – é outro exemplo de refatoração (veja “Refatoração”, na página 70).</p>
<p>Este exemplo sugere um plano de desenvolvimento para projetar objetos e métodos:</p>
<ol>
<li>
<p>Comece escrevendo funções que leiam e criem variáveis globais (quando necessário).</p>
</li>
<li>
<p>Uma vez que o programa esteja funcionando, procure associações entre variáveis globais e funções que as usem.</p>
</li>
<li>
<p>Encapsule variáveis relacionadas como atributos de objeto.</p>
</li>
<li>
<p>Transforme as funções associadas em métodos da nova classe.</p>
</li>
</ol>
<p>Como exercício, baixe o meu código de Markov de <a href="http://thinkpython2.com/code/markov.py">http://thinkpython2.com/code/markov.py</a> e siga os passos descritos acima para encapsular as variáveis globais como atributos de uma nova classe chamada Markov.</p>
<p>Solução: <a href="http://thinkpython2.com/code/Markov.py">http://thinkpython2.com/code/Markov.py</a> (observe o M maiúsculo).</p>
<h2><a class="header" href="#1810---depuração" id="1810---depuração">18.10 - Depuração</a></h2>
<p>A <a href="18-heranca/11-glossario.html#heran%C3%A7a">herança</a> pode dificultar a depuração porque quando você invoca um método em um objeto, pode ser difícil compreender qual método será invocado.</p>
<p>Suponha que esteja escrevendo uma função que funcione com objetos Hand. Você gostaria que ela funcionasse com todos os tipos de Hand, como PokerHands, BridgeHands etc. Se invocar um método como shuffle, poderá receber o que foi definido em Deck, mas se alguma das subclasses ignorar este método, você receberá outra versão. Este comportamento pode ser bom, mas também confuso.</p>
<p>A qualquer momento em que não esteja seguro a respeito do fluxo de execução do seu programa, a solução mais simples é acrescentar instruções de exibição no início dos métodos em questão. Se Deck.shuffle exibir uma mensagem que diz algo como Running Deck.shuffle, então no decorrer da execução do programa ele monitora seu fluxo.</p>
<p>Uma alternativa é usar esta função, que recebe um objeto e um nome de método (como uma string) e retorna a classe que fornece a definição do método:</p>
<pre><code class="language-python">def find_defining_class(obj, meth_name):
    for ty in type(obj).mro():
        if meth_name in ty.__dict__:
            return ty
</code></pre>
<p>Aqui está um exemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; hand = Hand()
&gt;&gt;&gt; find_defining_class(hand, 'shuffle')
&lt;class 'Card.Deck'&gt;
</code></pre>
<p>Então o método shuffle deste Hand é o de Deck.</p>
<p><code>find_defining_class</code> usa o método mro para obter a lista de objetos de classe (tipos) onde os métodos serão procurados. “MRO” significa “ordem de resolução do método”, que é a sequência de classes que o Python pesquisa para “descobrir” um nome de método.</p>
<p>Aqui está uma sugestão de projeto: quando você ignora um método, a interface do novo método deve ser a mesma que a do antigo. Ela deve receber os mesmos parâmetros, retornar o mesmo tipo e obedecer às mesmas precondições e pós-condições. Se seguir esta regra, você descobrirá que qualquer função projetada para funcionar com uma instância de uma classe pai, como Deck, também funcionará com instâncias de classes filho como Hand e PokerHand.</p>
<p>Se violar esta regra, o que se chama de “princípio de substituição de Liskov”, seu código cairá como (desculpe) um castelo de cartas.</p>
<h2><a class="header" href="#1811---glossário" id="1811---glossário">18.11 - Glossário</a></h2>
<h5><a class="header" href="#codificar" id="codificar">codificar</a></h5>
<p>    Representar um conjunto de valores usando outro conjunto de valores construindo um mapeamento entre eles.</p>
<h5><a class="header" href="#atributo-de-classe" id="atributo-de-classe">atributo de classe</a></h5>
<p>    Atributo associado a um objeto de classe. Os atributos de classe são definidos dentro de uma definição de classe, mas fora de qualquer método.</p>
<h5><a class="header" href="#atributo-de-instância" id="atributo-de-instância">atributo de instância</a></h5>
<p>    Atributo associado a uma instância de uma classe.</p>
<h5><a class="header" href="#folheado" id="folheado">folheado</a></h5>
<p>    Método ou função que apresenta uma interface diferente para outra função sem fazer muitos cálculos.</p>
<h5><a class="header" href="#herança" id="herança">herança</a></h5>
<p>    Capacidade de definir uma nova classe que seja uma versão modificada de uma classe definida anteriormente.</p>
<h5><a class="header" href="#classe-pai" id="classe-pai">classe-pai</a></h5>
<p>    Classe da qual uma classe-filho herda.</p>
<h5><a class="header" href="#classe-filho" id="classe-filho">classe-filho</a></h5>
<p>    Nova classe criada por herança de uma classe existente; também chamada de “subclasse”.</p>
<h5><a class="header" href="#relação-is-a" id="relação-is-a">relação IS-A</a></h5>
<p>    Relação entre uma classe-filho e sua classe-pai. Também chamada de herança.</p>
<h5><a class="header" href="#relação-has-a" id="relação-has-a">relação HAS-A</a></h5>
<p>    Relação entre duas classes onde as instâncias de uma classe contêm referências a instâncias da outra. Também chamada de composição.</p>
<h5><a class="header" href="#dependência" id="dependência">dependência</a></h5>
<p>    Relação entre duas classes onde as instâncias de uma classe usam instâncias de outra classe, mas não as guardam como atributos.</p>
<h5><a class="header" href="#diagrama-de-classe" id="diagrama-de-classe">diagrama de classe</a></h5>
<p>    Diagrama que mostra as classes em um programa e as relações entre elas.</p>
<h5><a class="header" href="#multiplicidade" id="multiplicidade">multiplicidade</a></h5>
<p>    Notação em um diagrama de classe que mostra, para uma relação HAS-A, quantas referências a instâncias da outra classe podem existir.</p>
<h5><a class="header" href="#encapsulamento-de-dados" id="encapsulamento-de-dados">encapsulamento de dados</a></h5>
<p>    Plano de desenvolvimento de programa que envolve um protótipo usando variáveis globais e uma versão final que transforma as variáveis globais em atributos de instância.</p>
<h2><a class="header" href="#1812---exercícios" id="1812---exercícios">18.12 - Exercícios</a></h2>
<h3><a class="header" href="#exercício-181" id="exercício-181">Exercício 18.1</a></h3>
<p>Para o seguinte programa, desenhe um <a href="18-heranca/11-glossario.html#diagrama-de-classe">diagrama de classe</a> UML que mostre estas classes e as relações entre elas.</p>
<pre><code class="language-python">class PingPongParent:
    pass

class Ping(PingPongParent):
    def __init__(self, pong):
        self.pong = pong

class Pong(PingPongParent):
    def __init__(self, pings=None):
        if pings is None:
            self.pings = []
        else:
            self.pings = pings
    def add_ping(self, ping):
        self.pings.append(ping)

pong = Pong()
ping = Ping(pong)
pong.add_ping(ping)
</code></pre>
<h3><a class="header" href="#exercício-182" id="exercício-182">Exercício 18.2</a></h3>
<p>Escreva um método Deck chamado <code>deal_hands</code> que receba dois parâmetros: o número de mãos e o número de cartas por mão. Ele deve criar o número adequado de objetos Hand, lidar com o número adequado de cartas por mão e retornar uma lista de Hands.</p>
<h3><a class="header" href="#exercício-183" id="exercício-183">Exercício 18.3</a></h3>
<p>A seguir, as mãos possíveis no pôquer, em ordem crescente de valor e ordem decrescente de probabilidade:</p>
<h5><a class="header" href="#par" id="par">par</a></h5>
<p>    Duas cartas com o mesmo valor.</p>
<h5><a class="header" href="#dois-pares" id="dois-pares">dois pares</a></h5>
<p>    Dois pares de cartas com o mesmo valor.</p>
<h5><a class="header" href="#trinca" id="trinca">trinca</a></h5>
<p>    Três cartas com o mesmo valor.</p>
<h5><a class="header" href="#sequência-1" id="sequência-1">sequência</a></h5>
<p>    Cinco cartas com valores em sequência (os ases podem ser altos ou baixos, então Ace-2-3-4-5 é uma sequência, assim como 10-Jack-Queen-King-Ace, mas Queen-King-Ace-2-3 não é)</p>
<h5><a class="header" href="#flush" id="flush">flush</a></h5>
<p>    Cinco cartas com o mesmo naipe.</p>
<h5><a class="header" href="#full-house" id="full-house">full house</a></h5>
<p>    Três cartas com um valor, duas cartas com outro.</p>
<h5><a class="header" href="#quadra" id="quadra">quadra</a></h5>
<p>    Quatro cartas com o mesmo valor.</p>
<h5><a class="header" href="#straight-flush" id="straight-flush">straight flush</a></h5>
<p>    Cinco cartas em sequência (como definido acima) e com o mesmo naipe.</p>
<p>A meta desses exercícios é estimar a probabilidade de ter estas várias mãos.</p>
<ol>
<li>Baixe os seguintes arquivos de <a href="http://thinkpython2.com/code:">http://thinkpython2.com/code:</a></li>
</ol>
<ul>
<li>
<p><code>Card.py</code>: Versão completa das classes Card, Deck e Hand deste capítulo.</p>
</li>
<li>
<p><code>PokerHand.py</code>: Uma implementação incompleta de uma classe que representa uma mão de pôquer e código para testá-la.</p>
</li>
</ul>
<ol start="2">
<li>
<p>Se executar PokerHand.py, você verá que o programa cria mãos de pôquer com 7 cartas e verifica se alguma delas contém um flush. Leia este código com atenção antes de continuar.</p>
</li>
<li>
<p>Acrescente métodos a PokerHand.py chamados <code>has_pair</code>, <code>has_twopair</code>, etc. que retornem True ou False conforme a mão cumpra os critérios em questão. Seu código deve funcionar corretamente para “mãos” que contenham qualquer número de cartas (embora 5 e 7 sejam as quantidades mais comuns).</p>
</li>
<li>
<p>Escreva um método chamado classify que descubra a classificação do valor mais alto para uma mão e estabeleça o atributo label em questão. Por exemplo, uma mão de 7 cartas poderia conter um flush e um par; ela deve ser marcada como “flush”.</p>
</li>
<li>
<p>Quando se convencer de que os seus métodos de classificação estão funcionando, o próximo passo deve ser estimar as probabilidades de várias mãos. Escreva uma função em PokerHand.py que embaralhe cartas, divida-as em mãos, classifique as mãos e conte o número de vezes em que várias classificações aparecem.</p>
</li>
<li>
<p>Exiba uma tabela das classificações e suas probabilidades. Execute seu programa com números cada vez maiores de mãos até que os valores de saída convirjam a um grau razoável de exatidão. Compare seus resultados com os valores em <a href="http://en.wikipedia.org/wiki/Hand_rankings">http://en.wikipedia.org/wiki/Hand_rankings</a>.</p>
</li>
</ol>
<p>Solução: <a href="http://thinkpython2.com/code/PokerHandSoln.py">http://thinkpython2.com/code/PokerHandSoln.py</a>.</p>
<h1><a class="header" href="#capítulo-19-extra" id="capítulo-19-extra">Capítulo 19: Extra</a></h1>
<p>Uma das minhas metas com este livro é ensinar o mínimo possível de Python. Quando havia duas formas de fazer algo, escolhia uma e evitava mencionar a outra. Ou, às vezes, usava a segunda como exercício.</p>
<p>Agora quero voltar a algumas coisas boas que ficaram para trás. O Python oferece vários recursos que não são realmente necessários – você pode escrever um bom código sem eles – mas com eles é possível escrever um código mais conciso, legível ou eficiente e, às vezes, todos os três.</p>
<h2><a class="header" href="#191---expressões-condicionais" id="191---expressões-condicionais">19.1 - Expressões condicionais</a></h2>
<p>Vimos instruções condicionais em “Execução condicional”, na página 78. As instruções condicionais muitas vezes são usadas para escolher um entre dois valores; por exemplo:</p>
<pre><code class="language-python">if x &gt; 0:
    y = math.log(x)
else:
    y = float('nan')
</code></pre>
<p>Esta instrução verifica se x é positivo. Nesse caso, ela calcula math.log. Do contrário, math.log causaria um ValueError. Para evitar interromper o programa, geramos um “NaN”, que é um valor de ponto flutuante especial que representa um “Não número”.</p>
<p>Podemos escrever essa instrução de forma mais concisa usando uma <a href="19-extra/10-glossario.html#express%C3%A3o-condicional">expressão condicional</a>:</p>
<pre><code class="language-python">y = math.log(x) if x &gt; 0 else float('nan')
</code></pre>
<p>Você quase pode ler esta linha como se tivesse sido escrita em inglês: “y recebe log-x se x for maior que 0; do contrário, ele recebe NaN”.</p>
<p>As funções recursivas por vezes podem ser reescritas usando expressões condicionais. Por exemplo, aqui está uma versão recursiva de factorial:</p>
<pre><code class="language-python">def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)
</code></pre>
<p>Podemos reescrevê-la assim:</p>
<pre><code class="language-python">def factorial(n):
    return 1 if n == 0 else n * factorial(n-1)
</code></pre>
<p>Outro uso de expressões condicionais é lidar com argumentos opcionais. Por exemplo, aqui está o método init de GoodKangaroo (veja o Exercício 17.2):</p>
<pre><code class="language-python">def __init__(self, name, contents=None):
    self.name = name
    if contents == None:
        contents = []
    self.pouch_contents = contents
</code></pre>
<p>Podemos reescrevê-lo assim:</p>
<pre><code class="language-python">def __init__(self, name, contents=None):
    self.name = name
    self.pouch_contents = [] if contents == None else contents
</code></pre>
<p>Em geral, é possível substituir uma instrução condicional por uma expressão condicional se ambos os ramos contiverem expressões simples que sejam retornadas ou atribuídas à mesma variável.</p>
<h2><a class="header" href="#192---abrangência-de-listas" id="192---abrangência-de-listas">19.2 - Abrangência de listas</a></h2>
<p>Em “Mapeamento, filtragem e redução”, na página 147, vimos os padrões de filtragem e mapeamento. Por exemplo, esta função toma uma lista de strings, mapeia o método de string capitalize aos elementos, e retorna uma nova lista de strings:</p>
<pre><code class="language-python">def capitalize_all(t):
    res = []
    for s in t:
        res.append(s.capitalize())
    return res
</code></pre>
<p>Podemos escrever isso de forma mais concisa usando abrangência de listas (list comprehension):</p>
<pre><code class="language-python">def capitalize_all(t):
    return [s.capitalize() for s in t]
</code></pre>
<p>Os operadores de colchete indicam que estamos construindo uma nova lista. A expressão dentro dos colchetes especifica os elementos da lista, e a cláusula for indica qual sequência estamos atravessando.</p>
<p>A sintaxe da abrangência de listas é um pouco esquisita porque a variável de loop, s nesse exemplo, aparece na expressão antes de chegarmos à definição.</p>
<p>Abrangências de listas também podem ser usadas para filtragem. Por exemplo, esta função só seleciona os elementos de t que são maiúsculos, e retorna uma nova lista:</p>
<pre><code class="language-python">def only_upper(t):
    res = []
    for s in t:
        if s.isupper():
            res.append(s)
    return res
</code></pre>
<p>Podemos reescrevê-la usando abrangência de listas:</p>
<pre><code class="language-python">def only_upper(t):
    return [s for s in t if s.isupper()]
</code></pre>
<p>Abrangências de listas são concisas e fáceis de ler, pelo menos para expressões simples. E são normalmente mais rápidas que os loops for equivalentes, às vezes muito mais rápidas. Então, se você ficar irritado comigo por não ter mencionado isso antes, eu entendo.</p>
<p>Porém, em minha defesa, as abrangências de listas são mais difíceis de depurar porque não é possível ter instruções de exibição dentro do loop. Sugiro que você as use só se o cálculo for simples o suficiente para que acerte já de primeira. E para principiantes isso significa nunca.</p>
<h2><a class="header" href="#193---expressões-geradoras" id="193---expressões-geradoras">19.3 - Expressões geradoras</a></h2>
<p>Expressões geradoras são semelhantes às abrangências de listas, mas com parênteses em vez de colchetes:</p>
<pre><code class="language-python">&gt;&gt;&gt; g = (x**2 for x in range(5))
&gt;&gt;&gt; g
&lt;generator object &lt;genexpr&gt; at 0x7f4c45a786c0&gt;
</code></pre>
<p>O resultado é um objeto gerador que sabe como fazer iterações por uma sequência de valores. No entanto, ao contrário de uma abrangência de listas, ele não calcula todos os valores de uma vez; espera pelo pedido. A função integrada next recebe o próximo valor do gerador:</p>
<pre><code class="language-python">&gt;&gt;&gt; next(g)
0
&gt;&gt;&gt; next(g)
1
</code></pre>
<p>Quando você chega no fim da sequência, next cria uma exceção StopIteration. Também é possível usar um loop for para fazer a iteração pelos valores:</p>
<pre><code class="language-python">&gt;&gt;&gt; for val in g:
...     print(val)
4
9
16
</code></pre>
<p>O objeto gerador monitora a posição em que está na sequência, portanto o loop for continua de onde next parou. Uma vez que o gerador se esgotar, ele continua criando StopException:</p>
<pre><code class="language-python">&gt;&gt;&gt; next(g)
StopIteration
</code></pre>
<p>As expressões geradoras muitas vezes são usadas com funções como sum, max e min:</p>
<pre><code class="language-python">&gt;&gt;&gt; sum(x**2 for x in range(5))
30
</code></pre>
<h2><a class="header" href="#194---any-e-all" id="194---any-e-all">19.4 - any e all</a></h2>
<p>O Python tem uma função integrada, any, que recebe uma sequência de valores booleanos e retorna True se algum dos valores for True. Ela funciona em listas:</p>
<pre><code class="language-python">&gt;&gt;&gt; any([False, False, True])
True
</code></pre>
<p>Entretanto, muitas vezes é usada com expressões geradoras:</p>
<pre><code class="language-python">&gt;&gt;&gt; any(letter == 't' for letter in 'monty')
True
</code></pre>
<p>Esse exemplo não é muito útil porque faz a mesma coisa que o operador in. Porém, podemos usar any para reescrever algumas das funções de pesquisa que escrevemos em “Busca”, na página 136. Por exemplo, poderíamos escrever avoids dessa forma:</p>
<pre><code class="language-python">def avoids(word, forbidden):
    return not any(letter in forbidden for letter in word)
</code></pre>
<p>A função quase pode ser lida como uma frase em inglês: “word evita forbidden se não houver nenhuma letra proibida em word”.</p>
<p>Usar <code>any</code> com uma <a href="19-extra/10-glossario.html#express%C3%A3o-geradora">expressão geradora</a> é eficiente porque ela retorna imediatamente se encontrar um valor True, então não é preciso avaliar a sequência inteira.</p>
<p>O Python oferece outra função integrada, <code>all</code>, que retorna True se todos os elementos da sequência forem True. Como exercício, use all para reescrever <code>uses_all</code> de “Busca”, na página 136.</p>
<h2><a class="header" href="#195---conjuntos" id="195---conjuntos">19.5 - Conjuntos</a></h2>
<p>Na seção “Subtração de dicionário”, da página 198, uso dicionários para encontrar as palavras que aparecem em um documento, mas não numa lista de palavras. A função que escrevi recebe d1, que contém as palavras do documento como chaves e d2, que contém a lista de palavras. Ela retorna um dicionário que contém as chaves de d1 que não estão em d2:</p>
<pre><code class="language-python">def subtract(d1, d2):
    res = dict()
    for key in d1:
        if key not in d2:
            res[key] = None
    return res
</code></pre>
<p>Em todos esses dicionários, os valores não são None porque nunca os usamos. O resultado é que desperdiçamos espaço de armazenamento.</p>
<p>O Python fornece outro tipo integrado, chamado set (conjunto), que se comporta como uma coleção de chaves de dicionário sem valores. Acrescentar elementos a um conjunto é rápido; assim como verificar a adesão. E os conjuntos fornecem métodos e operadores para calcular operações de conjuntos.</p>
<p>Por exemplo, a subtração de conjuntos está disponível como um método chamado difference ou como um operador, -. Portanto, podemos reescrever subtract desta forma:</p>
<pre><code class="language-python">def subtract(d1, d2):
    return set(d1) - set(d2)
</code></pre>
<p>O resultado é um conjunto em vez de um dicionário, mas, para operações como iteração, o comportamento é o mesmo.</p>
<p>Alguns exercícios neste livro podem ser feitos de forma concisa e eficiente com conjuntos. Por exemplo, aqui está uma solução para has_duplicates, do Exercício 10.7, que usa um dicionário:</p>
<pre><code class="language-python">def has_duplicates(t):
    d = {}
    for x in t:
        if x in d:
            return True
        d[x] = True
    return False
</code></pre>
<p>Quando um elemento aparece pela primeira vez, ele é acrescentado ao dicionário. Se o mesmo elemento aparece novamente, a função retorna True.</p>
<p>Usando conjuntos, podemos escrever a mesma função dessa forma:</p>
<pre><code class="language-python">def has_duplicates(t):
    return len(set(t)) &lt; len(t)
</code></pre>
<p>Um elemento só pode aparecer em um conjunto uma vez, portanto, se um elemento em t aparecer mais de uma vez, o conjunto será menor que t. Se não houver duplicatas, o conjunto terá o mesmo tamanho que t.</p>
<p>Também podemos usar conjuntos para fazer alguns exercícios no Capítulo 9. Por exemplo, aqui está uma versão de uses_only com um loop:</p>
<pre><code class="language-python">def uses_only(word, available):
    for letter in word:
        if letter not in available:
            return False
    return True
</code></pre>
<p><code>uses_only</code> verifica se todas as cartas em word estão em available. Podemos reescrevê-la assim:</p>
<pre><code class="language-python">def uses_only(word, available):
    return set(word) &lt;= set(available)
</code></pre>
<p>O operador <code>&lt;=</code> verifica se um conjunto é um subconjunto ou outro, incluindo a possibilidade de que sejam iguais, o que é verdade se todas as letras de word aparecerem em available.</p>
<p>Como exercício, reescreva avoids usando conjuntos.</p>
<h2><a class="header" href="#196---contadores" id="196---contadores">19.6 - Contadores</a></h2>
<p>Um contador é como um conjunto, exceto que se um elemento aparecer mais de uma vez, o contador registra quantas vezes ele aparece. Se tiver familiaridade com a ideia matemática de um <a href="19-extra/10-glossario.html#multiconjunto">multiconjunto</a> (multiset), um contador é uma forma natural de representar um multiconjunto.</p>
<p>Contadores são definidos em um módulo padrão chamado <code>collections</code>, portanto é preciso importá-lo. Você pode inicializar um contador com uma string, lista ou alguma outra coisa que seja compatível com iteração:</p>
<pre><code class="language-python">&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; count = Counter('parrot')
&gt;&gt;&gt; count
Counter({'r': 2, 't': 1, 'o': 1, 'p': 1, 'a': 1})
</code></pre>
<p>Os contadores comportam-se como dicionários de muitas formas; eles mapeiam cada chave ao número de vezes que aparece. Como em dicionários, as chaves têm de ser hashable.</p>
<p>Ao contrário de dicionários, os contadores não causam uma exceção se você acessar um elemento que não aparece. Em vez disso, retornam 0:</p>
<pre><code class="language-python">&gt;&gt;&gt; count['d']
0
</code></pre>
<p>Podemos usar contadores para reescrever <code>is_anagram</code> do Exercício 10.6:</p>
<pre><code class="language-python">def is_anagram(word1, word2):
    return Counter(word1) == Counter(word2)
</code></pre>
<p>Se duas palavras forem anagramas, elas contêm as mesmas letras com as mesmas contagens, então seus contadores são equivalentes.</p>
<p>Os contadores oferecem métodos e operadores para executar operações similares às dos conjuntos, incluindo adição, subtração, união e intersecção. E eles fornecem um método muitas vezes útil, most_common, que retorna uma lista de pares frequência-valor, organizados do mais ao menos comum:</p>
<pre><code class="language-python">&gt;&gt;&gt; count = Counter('parrot')
&gt;&gt;&gt; for val, freq in count.most_common(3):
...     print(val, freq)
r 2
p 1
a 1
</code></pre>
<h2><a class="header" href="#197---defaultdict" id="197---defaultdict">19.7 - defaultdict</a></h2>
<p>O módulo <code>collections</code> também tem <code>defaultdict</code>, que se parece com um dicionário, exceto pelo fato de que se você acessar uma chave que não existe, um novo valor pode ser gerado automaticamente.</p>
<p>Quando você cria um defaultdict, fornece uma função usada para criar valores. Uma função usada para criar objetos às vezes é chamada de factory (fábrica). As funções integradas que criam listas, conjuntos e outros tipos podem ser usadas como fábricas:</p>
<pre><code class="language-python">&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; d = defaultdict(list)
</code></pre>
<p>Note que o argumento é list, que é um objeto de classe, não list(), que é uma nova lista. A função que você fornece não é chamada a menos que você acesse uma chave que não existe:</p>
<pre><code class="language-python">&gt;&gt;&gt; t = d['new key']
&gt;&gt;&gt; t
[]
</code></pre>
<p>A nova lista, que estamos chamando de t, também é adicionada ao dicionário. Então, se alterarmos t, a mudança aparece em d:</p>
<pre><code class="language-python">&gt;&gt;&gt; t.append('new value')
&gt;&gt;&gt; d
defaultdict(&lt;class 'list'&gt;, {'new key': ['new value']})
</code></pre>
<p>Se estiver fazendo um dicionário de listas, você pode escrever um código mais simples usando defaultdict. Na minha solução para o Exercício 12.2, que você pode ver em <a href="http://thinkpython2.com/code/anagram_sets.py">http://thinkpython2.com/code/anagram_sets.py</a>, faço um dicionário que mapeia uma string organizada de letras a uma lista de palavras que pode ser soletrada com essas letras. Por exemplo, 'opst' mapeia para a lista <code>['opts', 'post', 'pots', 'spot', 'stop', 'tops']</code>.</p>
<p>Aqui está o código original:</p>
<pre><code class="language-python">def all_anagrams(filename):
    d = {}
    for line in open(filename):
        word = line.strip().lower()
        t = signature(word)
        if t not in d:
            d[t] = [word]
        else:
            d[t].append(word)
    return d
</code></pre>
<p>Isso pode ser simplificado usando setdefault, que você poderia ter usado no Exercício 11.2:</p>
<pre><code class="language-python">def all_anagrams(filename):
    d = {}
    for line in open(filename):
        word = line.strip().lower()
        t = signature(word)
        d.setdefault(t, []).append(word)
    return d
</code></pre>
<p>O problema dessa solução é que ela faz uma lista nova a cada vez, mesmo que não seja necessário. Para listas, isso não é grande coisa, mas se a função fábrica for complicada, poderia ser.</p>
<p>Podemos evitar este problema e simplificar o código usando um defaultdict:</p>
<pre><code class="language-python">def all_anagrams(filename):
    d = defaultdict(list)
    for line in open(filename):
        word = line.strip().lower()
        t = signature(word)
        d[t].append(word)
    return d
</code></pre>
<p>A minha solução para o Exercício 18.3, que você pode baixar em <a href="http://thinkpython2.com/code/PokerHandSoln.py">http://thinkpython2.com/code/PokerHandSoln.py</a>, usa setdefault na função <code>has_straightflush</code>. O problema dessa solução é criar um objeto Hand cada vez que passa pelo loop, seja ele necessário ou não. Como exercício, reescreva-a usando um defaultdict.</p>
<h2><a class="header" href="#198---tuplas-nomeadas" id="198---tuplas-nomeadas">19.8 - Tuplas nomeadas</a></h2>
<p>Muitos objetos simples são basicamente coleções de valores relacionados. Por exemplo, o objeto Point, definido no Capítulo 15, contém dois números, x e y. Ao definir uma classe como essa, normalmente você começa com um método init e um método str:</p>
<pre><code class="language-python">class Point:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y
    def __str__(self):
        return '(%g, %g)' % (self.x, self.y)
</code></pre>
<p>É muito código para transmitir pouca informação. O Python tem uma forma mais concisa de dizer a mesma coisa:</p>
<pre><code class="language-python">from collections import namedtuple
Point = namedtuple('Point', ['x', 'y'])
</code></pre>
<p>O primeiro argumento é o nome da classe que você quer criar. O segundo é uma lista dos atributos que o objeto Point deve ter, como strings. O valor de retorno de namedtuple é um objeto de classe:</p>
<pre><code class="language-python">&gt;&gt;&gt; Point
&lt;class '__main__.Point'&gt;
</code></pre>
<p>Point fornece automaticamente métodos como <code>__init__</code> e <code>__str__</code> então não é preciso escrevê-los.</p>
<p>Para criar um objeto Point, você usa a classe Point como uma função:</p>
<pre><code class="language-python">&gt;&gt;&gt; p = Point(1, 2)
&gt;&gt;&gt; p
Point(x=1, y=2)
</code></pre>
<p>O método <code>__init__</code> atribui os argumentos a atributos usando os nomes que você forneceu. O método <code>__str__</code> exibe uma representação do objeto Point e seus atributos.</p>
<p>Você pode acessar os elementos da tupla nomeada pelo nome:</p>
<pre><code class="language-python">&gt;&gt;&gt; p.x, p.y
(1, 2)
</code></pre>
<p>Mas também pode tratar uma tupla nomeada como uma tupla:</p>
<pre><code class="language-python">&gt;&gt;&gt; p[0], p[1]
(1, 2)
&gt;&gt;&gt; x, y = p
&gt;&gt;&gt; x, y
(1, 2)
</code></pre>
<p>Tuplas nomeadas fornecem uma forma rápida de definir classes simples. O problema é que classes simples não ficam sempre simples. Mais adiante você poderá decidir que quer acrescentar métodos a uma tupla nomeada. Nesse caso, você poderá definir uma nova classe que herde da tupla nomeada:</p>
<pre><code class="language-python">class Pointier(Point):
    # adicionar mais métodos aqui
</code></pre>
<p>Ou poderá mudar para uma definição de classe convencional.</p>
<h2><a class="header" href="#199---reunindo-argumentos-de-palavra-chave" id="199---reunindo-argumentos-de-palavra-chave">19.9 - Reunindo argumentos de palavra-chave</a></h2>
<p>Em “Tuplas com argumentos de comprimento variável”, na página 181, vimos como escrever uma função que reúne seus argumentos em uma tupla:</p>
<pre><code class="language-python">def printall(*args):
    print(args)
</code></pre>
<p>Você pode chamar esta função com qualquer número de argumentos posicionais (isto é, argumentos que não têm palavras-chave):</p>
<pre><code class="language-python">&gt;&gt;&gt; printall(1, 2.0, '3')
(1, 2.0, '3')
</code></pre>
<p>Porém, o operador <code>*</code> não reúne argumentos de palavra-chave:</p>
<pre><code class="language-python">&gt;&gt;&gt; printall(1, 2.0, third='3')
TypeError: printall() got an unexpected keyword argument 'third'
</code></pre>
<p>Para reunir argumentos de palavra-chave, você pode usar o operador <code>**</code>:</p>
<pre><code class="language-python">def printall(*args, **kwargs):
    print(args, kwargs)
</code></pre>
<p>Você pode chamar o parâmetro de coleta de palavra-chave, como quiser, mas <code>kwargs</code> é uma escolha comum. O resultado é um dicionário que mapeia palavras-chave a valores:</p>
<pre><code class="language-python">&gt;&gt;&gt; printall(1, 2.0, third='3')
(1, 2.0) {'third': '3'}
</code></pre>
<p>Se tiver um dicionário de palavras-chave e valores, pode usar o operador de dispersão, <code>**</code>, para chamar uma função:</p>
<pre><code class="language-python">&gt;&gt;&gt; d = dict(x=1, y=2)
&gt;&gt;&gt; Point(**d)
Point(x=1, y=2)
</code></pre>
<p>Sem o operador de dispersão, a função trataria d como um único argumento posicional, e então atribuiria d a x e se queixaria porque não há nada para atribuir a y:</p>
<pre><code class="language-python">&gt;&gt;&gt; d = dict(x=1, y=2)
&gt;&gt;&gt; Point(d)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: __new__() missing 1 required positional argument: 'y'
</code></pre>
<p>Quando estiver trabalhando com funções com um grande número de parâmetros, muitas vezes é útil criar dicionários e passá-los como argumentos para especificar as opções usadas com maior frequência.</p>
<h2><a class="header" href="#1910---glossário" id="1910---glossário">19.10 - Glossário</a></h2>
<h5><a class="header" href="#expressão-condicional" id="expressão-condicional">expressão condicional</a></h5>
<p>    Expressão que contém um de dois valores, dependendo de uma condição.</p>
<h5><a class="header" href="#abrangência-de-lista-list-comprehension" id="abrangência-de-lista-list-comprehension">abrangência de lista (list comprehension)</a></h5>
<p>    Expressão com um loop for entre colchetes que produz uma nova lista.</p>
<h5><a class="header" href="#expressão-geradora" id="expressão-geradora">expressão geradora</a></h5>
<p>    Uma expressão com um loop for entre parênteses que produz um objeto gerador.</p>
<h5><a class="header" href="#multiconjunto" id="multiconjunto">multiconjunto</a></h5>
<p>    Entidade matemática que representa um mapeamento entre os elementos de um conjunto e o número de vezes que aparecem.</p>
<h5><a class="header" href="#fábrica-factory" id="fábrica-factory">fábrica (factory)</a></h5>
<p>    Função normalmente passada como parâmetro, usada para criar objetos.</p>
<h2><a class="header" href="#1911---exercícios" id="1911---exercícios">19.11 - Exercícios</a></h2>
<h3><a class="header" href="#exercício-191" id="exercício-191">Exercício 19.1</a></h3>
<p>Esta é uma função que calcula o coeficiente binominal recursivamente:</p>
<pre><code class="language-python">def binomial_coeff(n, k):
    &quot;&quot;&quot;Compute the binomial coefficient &quot;n choose k&quot;.

    n: number of trials
    k: number of successes
    returns: int

    &quot;&quot;&quot;
    if k == 0:
        return 1
    if n == 0:
        return 0
    res = binomial_coeff(n-1, k) + binomial_coeff(n-1, k-1)

    return res
</code></pre>
<p>Reescreva o corpo da função usando expressões condicionais aninhadas.</p>
<p>Uma observação: esta função não é muito eficiente porque acaba calculando os mesmos valores várias vezes. Você pode torná-lo mais eficiente com memos (veja “Memos”, na página 169). No entanto, vai ver que é mais difícil usar memos se escrevê-la usando expressões condicionais.</p>
<h1><a class="header" href="#apêndice-a-depuração" id="apêndice-a-depuração">Apêndice A: Depuração</a></h1>
<p>Durante a depuração, você deve distinguir entre tipos diferentes de erros para rastreá-los mais rapidamente:</p>
<ul>
<li>
<p>Erros de sintaxe são descobertos pelo interpretador quando ele está traduzindo o código-fonte para código de bytes. Eles indicam que há algo errado com a estrutura do programa. Exemplo: a omissão dos dois pontos no fim de uma instrução def gera a mensagem um tanto redundante SyntaxError: invalid syntax.</p>
</li>
<li>
<p>Erros de tempo de execução são produzidos pelo interpretador se algo der errado durante a execução do programa. A maior parte das mensagens de erro de tempo de execução inclui informações sobre onde o erro ocorreu e o que as funções estavam fazendo. Exemplo: a recursividade infinita eventualmente leva ao erro de tempo de execução maximum recursion depth exceeded.</p>
</li>
<li>
<p>Erros semânticos são problemas com um programa que é executado sem produzir mensagens de erro, mas que não faz a coisa certa. Exemplo: uma expressão que não pode ser avaliada na ordem esperada, produzindo um resultado incorreto.</p>
</li>
</ul>
<p>O primeiro passo da depuração é compreender com que tipo de erro você está lidando. Embora as próximas seções sejam organizadas pelo tipo de erro, algumas técnicas são aplicáveis em mais de uma situação.</p>
<h2><a class="header" href="#a1---erros-de-sintaxe" id="a1---erros-de-sintaxe">A.1 - Erros de sintaxe</a></h2>
<p>Os erros de sintaxe normalmente são fáceis de corrigir, uma vez que você descubra quais são. Infelizmente, as mensagens de erro muitas vezes não são úteis. As mensagens mais comuns são SyntaxError: invalid syntax e SyntaxError: invalid token, e nenhuma das duas é muito informativa.</p>
<p>Por outro lado, a mensagem diz onde no programa o problema ocorreu. E, na verdade, diz a você onde o Python notou um problema, que é não necessariamente onde o erro está. Às vezes, o erro está antes da posição da mensagem de erro, muitas vezes na linha precedente.</p>
<p>Se estiver construindo o programa incrementalmente, você terá uma boa ideia sobre onde encontrar o erro. Estará na última linha que acrescentou.</p>
<p>Se estiver copiando o código de um livro, comece comparando com atenção o seu código e o do livro. Verifique cada caractere. Ao mesmo tempo, lembre-se de que o livro pode estar errado, então, se vir algo que parece um erro de sintaxe, pode ser mesmo.</p>
<p>Aqui estão algumas formas de evitar os erros de sintaxe mais comuns:</p>
<ol>
<li>
<p>Confira se não está usando uma palavra-chave do Python para um nome de variável.</p>
</li>
<li>
<p>Verifique se há dois pontos no fim do cabeçalho de cada instrução composta, incluindo instruções for, while, if e def.</p>
</li>
<li>
<p>Confira se as strings no código têm as aspas correspondentes. Verifique se todas as aspas são retas, em vez de curvas.</p>
</li>
<li>
<p>Se tiver strings com várias linhas com aspas triplas (simples ou duplas), confira se fechou a string adequadamente. Uma string não fechada pode causar um erro de invalid token no fim do seu programa, ou pode tratar a parte seguinte do programa como uma string até chegar à string seguinte. No segundo caso, o programa pode nem produzir uma mensagem de erro!</p>
</li>
<li>
<p>Um operador inicial aberto – <code>(</code>, <code>{</code> ou <code>[</code> – faz o Python continuar até a linha seguinte, como se esta fosse parte da instrução atual. Geralmente, um erro ocorre quase imediatamente na linha seguinte.</p>
</li>
<li>
<p>Confira se há o clássico <code>=</code> em vez do <code>==</code> dentro de uma condicional.</p>
</li>
<li>
<p>Verifique a endentação para ter certeza de que está alinhada como deveria. O Python pode lidar com espaços e tabulações, mas, se misturá-los, isso pode causar problemas. A melhor forma de evitar esse problema é usar um editor de texto que identifique o Python e gere endentação consistente.</p>
</li>
<li>
<p>Se há caracteres não ASCII no código (incluindo strings e comentários), isso pode causar problemas, embora o Python 3 normalmente lide com caracteres não ASCII. Tenha cuidado se colar texto de uma página web ou outra fonte.</p>
</li>
</ol>
<p>Se nada funcionar, vá para a próxima seção...</p>
<h3><a class="header" href="#a11---continuo-fazendo-alterações-e-não-faz-nenhuma-diferença" id="a11---continuo-fazendo-alterações-e-não-faz-nenhuma-diferença">A.1.1 - Continuo fazendo alterações e não faz nenhuma diferença</a></h3>
<p>Se o interpretador disser que há um erro e você não o encontra, pode ser que você e o interpretador não estejam olhando para o mesmo código. Verifique o seu ambiente de programação para ter certeza de que o programa que está editando é o mesmo que o Python está tentando executar.</p>
<p>Se não estiver certo, tente pôr um erro de sintaxe óbvio e deliberado no início do programa. Agora execute-o novamente. Se o interpretador não encontrar o novo erro, você não está executando o novo código.</p>
<p>Há alguns culpados prováveis:</p>
<ul>
<li>
<p>Você editou o arquivo e esqueceu de salvar as alterações antes de executá-lo novamente. Alguns ambientes de programação fazem isso para você, mas alguns não fazem.</p>
</li>
<li>
<p>Você mudou o nome do arquivo, mas ainda está executando o nome antigo.</p>
</li>
<li>
<p>Algo no seu ambiente de desenvolvimento está configurado incorretamente.</p>
</li>
<li>
<p>Se estiver escrevendo um módulo e usando import, confira se não usou o mesmo nome no seu módulo que os dos módulos padrão do Python.</p>
</li>
<li>
<p>Se você estiver usando import para ler um módulo, lembre-se de que é preciso reiniciar o interpretador ou usar reload para ler um arquivo alterado. Se importar o módulo novamente, ele não faz nada.</p>
</li>
</ul>
<p>Se já esgotou as possibilidades e não conseguiu descobrir o que está acontecendo, uma abordagem é começar novamente com um programa como “Hello, World!”, para ter certeza de que consegue executar um programa conhecido. Então, gradualmente acrescente as partes do programa original ao novo.</p>
<h2><a class="header" href="#a2---erros-de-tempo-de-execução" id="a2---erros-de-tempo-de-execução">A.2 - Erros de tempo de execução</a></h2>
<p>Uma vez que o seu programa esteja sintaticamente correto, o Python pode lê-lo e, pelo menos, começar a executá-lo. O que poderia dar errado?</p>
<h3><a class="header" href="#a21---meu-programa-não-faz-nada" id="a21---meu-programa-não-faz-nada">A.2.1 - Meu programa não faz nada</a></h3>
<p>Este problema é mais comum quando o seu arquivo é composto de funções e classes, mas na verdade não invoca uma função para começar a execução. Isso pode ser intencional se você só planeja importar este módulo para fornecer classes e funções.</p>
<p>Se não for intencional, tenha certeza de que há uma chamada de função no programa, e que o fluxo de execução o alcança (veja “Fluxo da execução” a seguir).</p>
<h3><a class="header" href="#a22---meu-programa-trava" id="a22---meu-programa-trava">A.2.2 - Meu programa trava</a></h3>
<p>Se um programa parar e parecer que não está fazendo nada, ele está “travado”. Muitas vezes isso significa que está preso em um loop ou recursão infinita.</p>
<ul>
<li>
<p>Se houver determinado loop que você suspeita ser o problema, acrescente uma instrução print imediatamente antes do loop que diga “entrando no loop”, e outra imediatamente depois que diga “saindo do loop”.
<br><br>Execute o programa. Se receber a primeira mensagem e a segunda não, você tem um loop infinito. Vá à seção “Loop infinito” mais adiante.</p>
</li>
<li>
<p>Na maior parte do tempo, a recursividade infinita fará com que o programa seja executado durante algum tempo e então gere um erro “RuntimeError: Maximum recursion depth exceeded”. Se isso acontecer, vá à seção “Recursividade infinita” mais adiante.
<br><br>Se não estiver recebendo este erro, mas suspeita que há um problema com um método ou função recursiva, você ainda pode usar as técnicas da seção “Recursividade infinita”.</p>
</li>
<li>
<p>Se nenhum desses passos funcionar, comece a testar outros loops e outras funções e métodos recursivos.</p>
</li>
<li>
<p>Se isso não funcionar, então é possível que você não entenda o fluxo de execução do seu programa. Vá à seção “Fluxo de execução” mais adiante.</p>
</li>
</ul>
<h4><a class="header" href="#loop-infinito-1" id="loop-infinito-1">Loop infinito</a></h4>
<p>Se você acha que há um loop infinito e talvez saiba qual loop está causando o problema, acrescente uma instrução print no fim do loop que exiba os valores das variáveis na condição e o valor da condição.</p>
<p>Por exemplo:</p>
<pre><code class="language-python">while x &gt; 0 and y &lt; 0 :
    # faz algo com x
    # faz algo com y
    print('x: ', x)
    print('y: ', y)
    print(&quot;condition: &quot;, (x &gt; 0 and y &lt; 0))
</code></pre>
<p>Agora, quando executar o programa, você verá três linhas de saída para cada vez que o programa passar pelo loop. Na última vez que passar pelo loop, a condição deve ser False. Se o loop continuar, você poderá ver os valores de x e y, e compreender porque não estão sendo atualizados corretamente.</p>
<h4><a class="header" href="#recursividade-infinita-1" id="recursividade-infinita-1">Recursividade infinita</a></h4>
<p>Na maioria das vezes, a recursividade infinita faz o programa rodar durante algum tempo e então produzir um erro de &quot;Maximum recursion depth exceeded&quot;.</p>
<p>Se suspeitar que uma função está causando recursividade infinita, confira se há um caso-base. Deve haver alguma condição que faz a função retornar sem fazer uma invocação recursiva. Do contrário, você terá que repensar o algoritmo e identificar um caso-base.</p>
<p>Se houver um caso-base, mas o programa não parece alcançá-lo, acrescente uma instrução print no início da função para exibir os parâmetros. Agora, quando executar o programa, você verá algumas linhas de saída cada vez que a função for invocada, e verá os valores dos parâmetros. Se os parâmetros não estiverem se movendo em direção ao caso-base, você terá algumas ideias sobre a razão disso.</p>
<h4><a class="header" href="#fluxo-de-execução-1" id="fluxo-de-execução-1">Fluxo de execução</a></h4>
<p>Se não tiver certeza de como o fluxo de execução está se movendo pelo seu programa, acrescente instruções print ao começo de cada função com uma mensagem como “entrada na função foo”, onde foo é o nome da função.</p>
<p>Agora, quando executar o programa, ele exibirá cada função que for invocada.</p>
<h3><a class="header" href="#a23---quando-executo-o-programa-recebo-uma-exceção" id="a23---quando-executo-o-programa-recebo-uma-exceção">A.2.3 - Quando executo o programa recebo uma exceção</a></h3>
<p>Se algo der errado durante o tempo de execução, o Python exibe uma mensagem que inclui o nome da exceção, a linha do programa onde o problema ocorreu, e um traceback.</p>
<p>O traceback identifica a função que está rodando atualmente, e a função que a chamou, assim como a função que chamou esta, e assim por diante. Em outras palavras, ele traça a sequência de chamadas de função que fez com que você chegasse onde está, incluindo o número da linha no seu arquivo onde cada chamada ocorreu.</p>
<p>O primeiro passo é examinar o lugar no programa onde o erro ocorreu e ver se consegue compreender o que aconteceu. Esses são alguns dos erros de tempo de execução mais comuns:</p>
<h4><a class="header" href="#nameerror" id="nameerror">NameError</a></h4>
<p>Você está tentando usar uma variável que não existe no ambiente atual. Confira se o nome está escrito corretamente e de forma consistente. E lembre-se de que as variáveis locais são locais; você não pode se referir a elas a partir do exterior da função onde são definidas.</p>
<h4><a class="header" href="#typeerror" id="typeerror">TypeError</a></h4>
<p>Há várias causas possíveis:</p>
<ul>
<li>
<p>Você está tentando usar um valor de forma inadequada. Exemplo: indexar uma string, lista ou tupla com algo diferente de um número inteiro.</p>
</li>
<li>
<p>Não há correspondência entre os itens em uma string de formatação e os itens passados para conversão. Isso pode acontecer se o número de itens não tiver correspondência ou uma conversão inválida for chamada.</p>
</li>
<li>
<p>Você está passando o número incorreto de argumentos a uma função. Para métodos, olhe para a definição do método e verifique se o primeiro parâmetro é self. Então olhe para a invocação do método; confira se está invocando o método a um objeto com o tipo correto e fornecendo os outros argumentos corretamente.</p>
</li>
</ul>
<h4><a class="header" href="#keyerror" id="keyerror">KeyError</a></h4>
<p>Você está tentando acessar um elemento de um dicionário usando uma chave que o dicionário não contém. Se as chaves forem strings, lembre-se de que letras maiúsculas são diferentes de minúsculas.</p>
<h4><a class="header" href="#attributeerror" id="attributeerror">AttributeError</a></h4>
<p>Você está tentando acessar um atributo ou método que não existe. Verifique a ortografia! Você pode usar a função integrada vars para listar os atributos que existem mesmo.</p>
<p>Se um AttributeError indicar que um objeto é do tipo NoneType, fica subentendido que é None. Então o problema não é o nome do atributo, mas o objeto.</p>
<p>Pode ser que o objeto seja none porque você se esqueceu de retornar um valor de uma função; se chegar ao fim de uma função sem chegar a uma instrução return, ela retorna None. Outra causa comum é usar o resultado de um método de lista, como sort, que retorne None.</p>
<h4><a class="header" href="#indexerror" id="indexerror">IndexError</a></h4>
<p>O índice que você está usando para acessar uma lista, string ou tupla é maior que o seu comprimento menos um. Imediatamente antes do local do erro, acrescente uma instrução print para exibir o valor do índice e o comprimento do array. O array é do tamanho certo? O índice tem o valor certo?</p>
<p>O depurador do Python (pdb) é útil para rastrear exceções porque permite examinar o estado do programa imediatamente antes do erro. Você pode ler sobre o pdb em <a href="https://docs.python.org/3/library/pdb.html">https://docs.python.org/3/library/pdb.html</a>.</p>
<h3><a class="header" href="#a24---acrescentei-tantas-instruções-print-que-fui-inundado-pelos-resultados" id="a24---acrescentei-tantas-instruções-print-que-fui-inundado-pelos-resultados">A.2.4 - Acrescentei tantas instruções print que fui inundado pelos resultados</a></h3>
<p>Um dos problemas com a utilização de instruções print para a depuração é que você pode terminar enterrado pelos resultados. Há duas formas de prosseguir: simplifique a saída ou simplifique o programa.</p>
<p>Para simplificar a saída, você pode retirar ou transformar as instruções print que não estão ajudando em comentários, ou combiná-las, ou formatar a saída para que seja mais fácil de entender.</p>
<p>Para simplificar o programa, há várias coisas que você pode fazer. Em primeiro lugar, reduza o problema no qual o programa está trabalhando. Por exemplo, se está fazendo uma busca em uma lista, procure em uma lista pequena. Se o programa receber entradas do usuário, dê a entrada mais simples possível que cause o problema.</p>
<p>Em segundo lugar, limpe o programa. Retire o código morto e reorganize o programa para torná-lo o mais fácil possível de ler. Por exemplo, se você suspeitar que o problema está em uma parte profundamente aninhada do programa, tente reescrever aquela parte com uma estrutura mais simples. Se suspeitar de uma função grande, tente quebrá-la em funções menores para testá-las separadamente.</p>
<p>Muitas vezes, o próprio processo de encontrar o caso de teste mínimo leva você ao problema. Se descobrir que um programa funciona em uma situação, mas não em outra, isso dá uma pista sobre o que está acontecendo.</p>
<p>De forma similar, reescrever uma parte do código pode ajudar a encontrar erros sutis. Se fizer uma alteração que você ache que não vai afetar o programa, mas que acabe afetando, isso pode ajudá-lo.</p>
<h2><a class="header" href="#a3---erros-semânticos" id="a3---erros-semânticos">A.3 - Erros semânticos</a></h2>
<p>De algumas formas, os erros semânticos são os mais difíceis de depurar, porque o interpretador não fornece nenhuma informação sobre qual é o problema. Só você sabe o que o programa deve fazer.</p>
<p>O primeiro passo é fazer uma conexão entre o texto do programa e o comportamento que está vendo. Você precisa de uma hipótese sobre o que o programa está fazendo de fato. Uma das coisas que torna isso difícil é que os computadores são rápidos.</p>
<p>Pode ser que você queira diminuir a velocidade do programa para ser equivalente à humana; com alguns depuradores é possível fazer isso. No entanto, o tempo que leva para inserir instruções print bem colocadas muitas vezes é curto em comparação ao da configuração do depurador, inserção e remoção de marcações e colocação do “compasso” do programa onde o erro está ocorrendo.</p>
<h3><a class="header" href="#a31---meu-programa-não-funciona" id="a31---meu-programa-não-funciona">A.3.1 - Meu programa não funciona</a></h3>
<p>Você deve se perguntar o seguinte:</p>
<ul>
<li>
<p>Há algo que o programa deveria fazer, mas que não parece acontecer? Encontre a seção do código que executa a função em questão e confira se está sendo executada quando você acha que deveria.</p>
</li>
<li>
<p>Algo está acontecendo, mas não o que deveria? Encontre o código no seu programa que executa a função em questão e veja se está sendo executada na hora errada.</p>
</li>
<li>
<p>Uma seção do código está produzindo um efeito que não é o esperado? Tenha certeza de que entende o código em questão, especialmente se envolver funções ou métodos de outros módulos do Python. Leia a documentação das funções que chama. Teste-as escrevendo casos de teste simples e verificando os resultados.</p>
</li>
</ul>
<p>Para programar, é preciso ter um modelo mental de como os programas funcionam. Se escrever um programa que não faz o que espera, muitas vezes o problema não está no programa, está no seu modelo mental.</p>
<p>A melhor forma de corrigir o seu modelo mental é quebrar o programa nos seus componentes (normalmente as funções e métodos) e testar cada componente em separado. Uma vez que encontre a discrepância entre o seu modelo e a realidade, poderá resolver o problema.</p>
<p>Naturalmente, você deveria construir e testar componentes conforme desenvolva o programa. Assim, se encontrar um problema, deve haver só uma pequena quantidade de código novo que não sabe se está correto.</p>
<h3><a class="header" href="#a32---tenho-uma-baita-expressão-cabeluda-e-ela-não-faz-o-que-espero" id="a32---tenho-uma-baita-expressão-cabeluda-e-ela-não-faz-o-que-espero">A.3.2 - Tenho uma baita expressão cabeluda e ela não faz o que espero</a></h3>
<p>Escrever expressões complexas é ótimo enquanto são legíveis, mas elas podem ser difíceis de depurar. Muitas vezes é uma boa ideia quebrar uma expressão complexa em uma série de atribuições a variáveis temporárias.</p>
<p>Por exemplo:</p>
<pre><code class="language-python">self.hands[i].addCard(self.hands[self.findNeighbor(i)].popCard())
</code></pre>
<p>A expressão pode ser reescrita assim:</p>
<pre><code class="language-python">neighbor = self.findNeighbor(i)
pickedCard = self.hands[neighbor].popCard()
self.hands[i].addCard(pickedCard)
</code></pre>
<p>A versão explícita é mais fácil de ler porque os nomes das variáveis oferecem documentação adicional, e é mais fácil de depurar porque você pode verificar os tipos das variáveis intermediárias e exibir seus valores.</p>
<p>Outro problema que pode ocorrer com grandes expressões é que a ordem da avaliação pode não ser o que você espera. Por exemplo, se estiver traduzindo a expressão <img src="/fig/p242f1.png" alt="Fórmula – x / (2 * pi) em notação matemática" />. para o Python, poderia escrever:</p>
<pre><code class="language-python">y = x / 2 * math.pi
</code></pre>
<p>Isso não está correto porque a multiplicação e a divisão têm a mesma precedência e são avaliadas da esquerda para a direita. Então, é assim que essa expressão é calculada: xπ/2.</p>
<p>Uma boa forma de depurar expressões é acrescentar parênteses para tornar a ordem da avaliação explícita:</p>
<pre><code class="language-python">y = x / (2 * math.pi)
</code></pre>
<p>Sempre que não tiver certeza sobre a ordem da avaliação, use parênteses. Além de o programa ficar correto (quanto à execução do que era pretendido), ele também será mais legível para outras pessoas que não memorizaram a ordem de operações.</p>
<h3><a class="header" href="#a33---tenho-uma-função-que-não-retorna-o-que-espero" id="a33---tenho-uma-função-que-não-retorna-o-que-espero">A.3.3 - Tenho uma função que não retorna o que espero</a></h3>
<p>Se tiver uma instrução return com uma expressão complexa, não há possibilidade de exibir o resultado antes do retorno. Novamente, você pode usar uma variável temporária. Por exemplo, em vez de:</p>
<pre><code class="language-python">return self.hands[i].removeMatches()
</code></pre>
<p>você poderia escrever:</p>
<pre><code class="language-python">count = self.hands[i].removeMatches()
return count
</code></pre>
<p>Agora você tem a oportunidade de exibir o valor de count antes do retorno.</p>
<h3><a class="header" href="#a34---estou-perdido-e-preciso-de-ajuda" id="a34---estou-perdido-e-preciso-de-ajuda">A.3.4 - Estou perdido e preciso de ajuda</a></h3>
<p>Em primeiro lugar, afaste-se do computador por alguns minutos. Computadores emitem ondas que afetam o cérebro, causando estes sintomas:</p>
<ul>
<li>
<p>frustração e raiva;</p>
</li>
<li>
<p>crenças supersticiosas (“o computador me odeia”) e pensamento mágico (“o programa só funciona quando uso o meu chapéu virado para trás”);</p>
</li>
<li>
<p>programação aleatória (a tentativa de programar escrevendo todos os programas possíveis e escolhendo aquele que faz a coisa certa).</p>
</li>
</ul>
<p>Se estiver sofrendo algum desses sintomas, levante-se e dê uma volta. Quando se acalmar, pense no programa. O que ele está fazendo? Quais são algumas causas possíveis para esse comportamento? Quando foi a última vez que tinha um programa funcionando, e o que fez depois disso?</p>
<p>Às vezes leva tempo para encontrar um erro. Com frequência encontro erros quando estou longe do computador e deixo a minha mente vagar. Os melhores lugares para encontrar erros são os trens, o chuveiro e a cama, logo antes de adormecer.</p>
<h3><a class="header" href="#a35---sério-preciso-mesmo-de-ajuda" id="a35---sério-preciso-mesmo-de-ajuda">A.3.5 - Sério, preciso mesmo de ajuda</a></h3>
<p>Acontece. Mesmo os melhores programadores ocasionalmente empacam. Pode ocorrer de você trabalhar tanto em um programa que não consegue enxergar o erro. Precisa de outro par de olhos.</p>
<p>Antes de trazer mais alguém, não se esqueça de se preparar. Seu programa deve ser o mais simples possível, e deve estar funcionando com a menor entrada possível que cause o erro. Deve ter instruções print nos lugares adequados (e a saída que produzem deve ser compreensível). Você deve entender o problema o suficiente para descrevê-lo de forma concisa.</p>
<p>Ao trazer alguém para ajudar, lembre-se de dar as informações de que a pessoa possa precisar:</p>
<ul>
<li>
<p>Se houver uma mensagem de erro, qual é e que parte do programa indica?</p>
</li>
<li>
<p>Qual foi a última coisa que fez antes de este erro ocorrer? Quais foram as últimas linhas de código que escreveu, ou qual é o novo caso de teste que falhou?</p>
</li>
<li>
<p>O que tentou até agora e o que aprendeu?</p>
</li>
</ul>
<p>Quando encontrar o erro, pense por um segundo no que poderia ter feito para encontrá-lo mais rápido. Na próxima vez em que vir algo similar, poderá encontrar o erro mais rapidamente.</p>
<p>Lembre-se, a meta não é só fazer o programa funcionar. A meta é aprender como fazer o programa funcionar.</p>
<h1><a class="header" href="#apêndice-b-análise-de-algoritmos" id="apêndice-b-análise-de-algoritmos">Apêndice B: Análise de algoritmos</a></h1>
<p>Este apêndice é um excerto editado de Think Complexity, por Allen B. Downey, também publicado pela O’Reilly Media (2012). Depois de ler este livro aqui, pode ser uma boa ideia lê-lo também.</p>
<p>Análise de algoritmos é um ramo da Ciência da Computação que estuda o desempenho de algoritmos, especialmente suas exigências de tempo de execução e requisitos de espaço. Veja <a href="http://en.wikipedia.org/wiki/Analysis_of_algorithms">http://en.wikipedia.org/wiki/Analysis_of_algorithms</a>.</p>
<p>A meta prática da análise de algoritmos é prever o desempenho de algoritmos diferentes para guiar decisões de projeto.</p>
<p>Durante a campanha presidencial dos Estados Unidos de 2008, pediram ao candidato Barack Obama para fazer uma entrevista de emprego improvisada quando visitou a Google. O diretor executivo, Eric Schmidt, brincou, pedindo a ele “a forma mais eficiente de classificar um milhão de números inteiros de 32 bits”. Aparentemente, Obama tinha sido alertado porque respondeu na hora: “Creio que a ordenação por bolha (bubble sort) não seria a escolha certa”. Veja <a href="http://bit.ly/1MpIwTf">http://bit.ly/1MpIwTf</a>.</p>
<p>Isso é verdade: a ordenação por bolha é conceitualmente simples, mas lenta para grandes conjuntos de dados. A resposta que Schmidt procurava provavelmente é “ordenação radix” <a href="http://en.wikipedia.org/wiki/Radix_sort">(radix sort)</a>[2].</p>
<p>A meta da análise de algoritmos é fazer comparações significativas entre algoritmos, mas há alguns problemas:</p>
<ul>
<li>
<p>O desempenho relativo dos algoritmos pode depender de características do hardware; então um algoritmo pode ser mais rápido na Máquina A, e outro na Máquina B. A solução geral para este problema é especificar um modelo de máquina e analisar o número de passos ou operações que um algoritmo exige sob um modelo dado.</p>
</li>
<li>
<p>O desempenho relativo pode depender dos detalhes do conjunto de dados. Por exemplo, alguns algoritmos de ordenação rodam mais rápido se os dados já foram parcialmente ordenados; outros algoritmos rodam mais devagar neste caso. Uma forma comum de evitar este problema é analisar o pior caso. Às vezes é útil analisar o desempenho de casos médios, mas isso é normalmente mais difícil, e pode não ser óbvio qual conjunto de casos deve ser usado para a média.</p>
</li>
<li>
<p>O desempenho relativo também depende do tamanho do problema. Um algoritmo de ordenação que é rápido para pequenas listas pode ser lento para longas listas. A solução habitual para este problema é expressar o tempo de execução (ou o número de operações) como uma função do tamanho de problema e funções de grupo em categorias que dependem de sua velocidade de crescimento quando o tamanho de problema aumenta.</p>
</li>
</ul>
<p>Uma coisa boa sobre este tipo de comparação é que ela é própria para a classificação simples de algoritmos. Por exemplo, se souber que o tempo de execução do algoritmo A tende a ser proporcional ao tamanho da entrada n, e o algoritmo B tende a ser proporcional a \( n^2 \), então espero que A seja mais rápido que B, pelo menos para valores grandes de n.</p>
<p>Esse tipo de análise tem algumas desvantagens, mas falaremos disso mais adiante.</p>
<h2><a class="header" href="#b1---ordem-de-crescimento" id="b1---ordem-de-crescimento">B.1 - Ordem de crescimento</a></h2>
<p>Vamos supor que você analisou dois algoritmos e expressou seus tempos de execução em relação ao tamanho da entrada: o algoritmo A leva 100n+1 passos para resolver um problema com o tamanho n; o algoritmo B leva \( n^2 + n + 1 \) passos.</p>
<p>A tabela seguinte mostra o tempo de execução desses algoritmos para tamanhos de problema diferentes:</p>
<table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>Tamanho da entrada</td><td>Tempo de execução do algoritmo A</td><td>Tempo de execução do algoritmo B</td></tr>
<tr><td>10</td><td>1 001</td><td>111</td></tr>
<tr><td>100</td><td>10 001</td><td>10 101</td></tr>
<tr><td>1 000</td><td>100 001</td><td>1 001 001</td></tr>
<tr><td>10 000</td><td>1 000 001</td><td>&gt; 1010</td></tr>
</tbody></table>
<p>Ao chegar em n=10, o algoritmo A parece bem ruim; ele é quase dez vezes mais longo que o algoritmo B. No entanto, para n=100 eles são bem parecidos, e, para valores maiores, A é muito melhor.</p>
<p>A razão fundamental é que para grandes valores de n, qualquer função que contenha um termo \( n^2 \) será mais rápida que uma função cujo termo principal seja n. O termo principal é o que tem o expoente mais alto.</p>
<p>Para o algoritmo A, o termo principal tem um grande coeficiente, 100, que é a razão de B ser melhor que A para um valor pequeno de n. Entretanto, apesar dos coeficientes, sempre haverá algum valor de n em que \( an^2 &gt; bn \), para valores de a e b.</p>
<p>O mesmo argumento se aplica aos termos que não são principais. Mesmo se o tempo de execução do algoritmo A fosse n+1000000, ainda seria melhor que o algoritmo B para um valor suficientemente grande de n.</p>
<p>Em geral, esperamos que um algoritmo com um termo principal menor seja um algoritmo melhor para grandes problemas, mas, para problemas menores, pode haver um ponto de desvio onde outro algoritmo seja melhor. A posição do ponto de desvio depende dos detalhes dos algoritmos, das entradas e do hardware; então, ele é normalmente ignorado para os propósitos da análise algorítmica. Porém, isso não significa que você pode se esquecer dele.</p>
<p>Se dois algoritmos tiverem o mesmo termo principal de ordem, é difícil dizer qual é melhor; mais uma vez, a resposta depende dos detalhes. Assim, para a análise algorítmica, funções com o mesmo termo principal são consideradas equivalentes, mesmo se tiverem coeficientes diferentes.</p>
<p>Uma ordem de crescimento é um conjunto de funções cujo comportamento de crescimento é considerado equivalente. Por exemplo, 2n, 100n e n+1 pertencem à mesma ordem de crescimento, que se escreve \( O(n) \) em notação Grande-O e muitas vezes é chamada de linear, porque cada função no conjunto cresce linearmente em relação a n.</p>
<p>Todas as funções com o termo principal \( n^2 \) pertencem a \( O(n^2) \); elas são chamadas de quadráticas.</p>
<p>A tabela seguinte mostra algumas ordens de crescimento mais comuns na análise algorítmica, em ordem crescente de complexidade.</p>
<table><thead><tr><th>Ordem de crescimento</th><th>Nome</th></tr></thead><tbody>
<tr><td>\( O(1) \)</td><td>constante</td></tr>
<tr><td>\( O(\log_b n) \)</td><td>logarítmica (para qualquer b)</td></tr>
<tr><td>\( O(n) \)</td><td>linear</td></tr>
<tr><td>\( O(n \log_b n) \)</td><td>log-linear</td></tr>
<tr><td>\( O(n^2)  \)</td><td>quadrática</td></tr>
<tr><td>\( O(n^3) \)</td><td>cúbica</td></tr>
<tr><td>\( O(c^n) \)</td><td>exponencial (para qualquer c)</td></tr>
</tbody></table>
<p>Para os termos logarítmicos, a base do logaritmo não importa; a alteração de bases é o equivalente da multiplicação por uma constante, o que não altera a ordem de crescimento. De forma similar, todas as funções exponenciais pertencem à mesma ordem de crescimento, apesar da base do expoente. As funções exponenciais crescem muito rapidamente, então os algoritmos exponenciais só são úteis para pequenos problemas.</p>
<h3><a class="header" href="#exercício-b1" id="exercício-b1">Exercício B.1</a></h3>
<p>Leia a página da Wikipédia sobre a notação Grande-O (Big-Oh notation) em <a href="http://en.wikipedia.org/wiki/Big_O_notation">http://en.wikipedia.org/wiki/Big_O_notation</a> e responda às seguintes perguntas:</p>
<p>1. Qual é a ordem de crescimento de \( n^3 + n^2 \)? E de \( 1000000n^3 + n^2 \)? Ou de \( n^3 + 1000000n^2 \)?</p>
<p>2. Qual é a ordem de crescimento de \( (n^2 + n) . (n + 1) \)? Antes de começar a multiplicar, lembre-se de que você só precisa do termo principal.</p>
<p>3. Se f está em \( O(g) \), para alguma função não especificada g, o que podemos dizer de af+b?</p>
<p>4. Se f1 e f2 estão em \( O(g) \), o que podemos dizer a respeito de f1 + f2?</p>
<p>5. Se f1 está em \( O(g) \) e f2 está em \( O(h) \), o que podemos dizer a respeito de f1 + f2?</p>
<p>6. Se f1 está em \( O(g) \) e f2 é O(h) \), o que podemos dizer a respeito de f1 . f2?</p>
<p>Programadores que se preocupam com o desempenho muitas vezes consideram esse tipo de análise difícil de engolir. A razão para isso é: às vezes os coeficientes e os termos não principais fazem muita diferença. Os detalhes do hardware, a linguagem de programação e as características da entrada fazem grande diferença. E para pequenos problemas, o comportamento assintótico é irrelevante.</p>
<p>Porém, se mantiver essas questões em mente, a análise algorítmica pode ser uma ferramenta útil. Pelo menos para grandes problemas, os “melhores” algoritmos são normalmente melhores, e, às vezes, muito melhores. A diferença entre dois algoritmos com a mesma ordem de crescimento é normalmente um fator constante, mas a diferença entre um bom algoritmo e um algoritmo ruim é ilimitada!</p>
<h2><a class="header" href="#b2---análise-de-operações-básicas-do-python" id="b2---análise-de-operações-básicas-do-python">B.2 - Análise de operações básicas do Python</a></h2>
<p>No Python, a maior parte das operações aritméticas tem um tempo constante; a multiplicação normalmente leva mais tempo que a adição e a subtração, e a divisão leva até mais tempo, mas esses tempos de execução não dependem da magnitude dos operandos. Os números inteiros muito grandes são uma exceção; nesse caso, o tempo de execução aumenta com o número de dígitos.</p>
<p>Operações de indexação – ler ou escrever elementos em uma sequência ou dicionário – também têm tempo constante, não importa o tamanho da estrutura de dados.</p>
<p>Um loop for que atravesse uma sequência ou dicionário é normalmente linear, desde que todas as operações no corpo do loop sejam de tempo constante. Por exemplo, somar os elementos de uma lista é linear:</p>
<pre><code class="language-python">total = 0
for x in t:
    total += x
</code></pre>
<p>A função integrada sum também é linear porque faz a mesma coisa, mas tende a ser mais rápida porque é uma implementação mais eficiente; na linguagem da análise algorítmica, tem um coeficiente principal menor.</p>
<p>Via de regra, se o corpo de um loop está em \( O(na) \), então o loop inteiro está em \( O(na + 1) \). A exceção é se você puder mostrar que o loop encerra depois de um número constante de iterações. Se um loop é executado k vezes, não importa o valor de n, então o loop está em \( O(na) \), mesmo para valores grandes de k.</p>
<p>A multiplicação por k não altera a ordem de crescimento, nem a divisão. Então, se o corpo de um loop está em \( O(na) \) e é executado n/k vezes, o loop está em \( O(na + 1) \), mesmo para valores grandes de k.</p>
<p>A maior parte das operações de strings e tuplas são lineares, exceto a indexação e len, que são de tempo constante. As funções integradas min e max são lineares. O tempo de execução de uma operação de fatia é proporcional ao comprimento da saída, mas não depende do tamanho da entrada.</p>
<p>A concatenação de strings é linear; o tempo de execução depende da soma dos comprimentos dos operandos.</p>
<p>Todos os métodos de string são lineares, mas se os comprimentos das strings forem limitados por uma constante – por exemplo, operações em caracteres únicos – são consideradas de tempo constante. O método de string join é linear; o tempo de execução depende do comprimento total das strings.</p>
<p>A maior parte dos métodos de lista são lineares, mas há algumas exceções:</p>
<ul>
<li>
<p>A soma de um elemento ao fim de uma lista é de tempo constante em média; quando o espaço acaba, ela ocasionalmente é copiada a uma posição maior, mas o tempo total de operações n é \( O(n) \), portanto o tempo médio de cada operação é \( O(1) \).</p>
</li>
<li>
<p>A remoção de um elemento do fim de uma lista é de tempo constante.</p>
</li>
<li>
<p>A ordenação é \( O(n \log n) \).</p>
</li>
</ul>
<p>A maior parte das operações e métodos de dicionário são de tempo constante, mas há algumas exceções:</p>
<ul>
<li>
<p>O tempo de execução de update é proporcional ao tamanho do dicionário passado como parâmetro, não o dicionário que está sendo atualizado.</p>
</li>
<li>
<p>keys, values e items são de tempo constante porque retornam iteradores. Porém, se fizer um loop pelos iteradores, o loop será linear.</p>
</li>
</ul>
<p>O desempenho de dicionários é um dos milagres menores da ciência da computação. Vemos como funcionam em “Hashtables”, na página 302.</p>
<h3><a class="header" href="#exercício-b2" id="exercício-b2">Exercício B.2</a></h3>
<p>Leia a página da Wikipédia sobre algoritmos de ordenação em <a href="http://en.wikipedia.org/wiki/Sorting_algorithm">http://en.wikipedia.org/wiki/Sorting_algorithm</a> e responda às seguintes perguntas:</p>
<p>1. O que é um “tipo de comparação”? Qual é a melhor opção nos casos de pior cenário de ordem de crescimento para um tipo de comparação? Qual é a melhor opção nos casos de pior cenário de ordem de crescimento para qualquer algoritmo de ordenação?</p>
<p>2. Qual é a ordem de crescimento do tipo bolha, e por que Barack Obama acha que “não é a escolha certa”?</p>
<p>3. Qual é a ordem de crescimento do tipo radix? Quais são as precondições necessárias para usá-la?</p>
<p>4. O que é um tipo estável e qual é sua importância na prática?</p>
<p>5. Qual é o pior algoritmo de ordenação (que tenha um nome)?</p>
<p>6. Que algoritmo de ordenação a biblioteca C usa? Que algoritmo de ordenação o Python usa? Esses algoritmos são estáveis? Você pode ter que pesquisar no Google para encontrar essas respostas.</p>
<ol start="7">
<li>Muitos dos tipos de não comparação são lineares, então, por que o Python usa um tipo de comparação \( O(n \log n) \)?</li>
</ol>
<h2><a class="header" href="#b3---análise-de-algoritmos-de-busca" id="b3---análise-de-algoritmos-de-busca">B.3 - Análise de algoritmos de busca</a></h2>
<p>Uma busca é um algoritmo que recebe uma coleção e um item de objetivo e determina se o objetivo está na coleção, muitas vezes retornando o índice do objetivo.</p>
<p>O algoritmo de busca mais simples é uma “busca linear”, que atravessa os itens da coleção em ordem, parando se encontrar o objetivo. No pior caso, ele tem que atravessar a coleção inteira, então o tempo de execução é linear.</p>
<p>O operador in para sequências usa uma busca linear; assim como métodos de string como find e count.</p>
<p>Se os elementos da sequência estiverem em ordem, você pode usar uma busca por bisseção, que é \( O(\log n) \). A busca por bisseção é semelhante ao algoritmo que você poderia usar para procurar uma palavra em um dicionário (um dicionário de papel, não a estrutura de dados). Em vez de começar no início e verificar cada item em ordem, você começa com o item do meio e verifica se a palavra que está procurando vem antes ou depois. Se vier antes, então procura na primeira metade da sequência. Se não, procura na segunda metade. Seja como for, você corta o número de itens restantes pela metade.</p>
<p>Se a sequência tiver um milhão de itens, serão necessários cerca de 20 passos para encontrar a palavra ou concluir que não está lá. Então é aproximadamente 50 mil vezes mais rápido que uma busca linear.</p>
<p>A busca por bisseção pode ser muito mais rápida que a busca linear, mas é preciso que a sequência esteja em ordem, o que pode exigir trabalho extra.</p>
<p>Há outra estrutura de dados chamada hashtable, que é até mais rápida – você pode fazer uma busca em tempo constante – e ela não exige que os itens estejam ordenados. Os dicionários do Python são implementados usando hashtables e é por isso a maior parte das operações de dicionário, incluindo o operador in, são de tempo constante.</p>
<h2><a class="header" href="#b4---hashtables" id="b4---hashtables">B.4 - Hashtables</a></h2>
<p>Para explicar como hashtables funcionam e por que o seu desempenho é tão bom, começo com uma implementação simples de um mapa e vou melhorá-lo gradualmente até que seja uma hashtable.</p>
<p>Uso o Python para demonstrar essas implementações, mas, na vida real, eu não escreveria um código como esse no Python; bastaria usar um dicionário! Assim, para o resto deste capítulo, você tem que supor que os dicionários não existem e que quer implementar uma estrutura de dados que faça o mapa de chaves a valores. As operações que precisa implementar são:</p>
<h5><a class="header" href="#addk-v" id="addk-v">add(k, v)</a></h5>
<p>    Insere um novo item que mapeia a chave k ao valor v. Com um dicionário de Python, <code>d</code>, essa operação é escrita <code>d[k] = v</code>.</p>
<h5><a class="header" href="#getk" id="getk">get(k)</a></h5>
<p>    Procura e devolve o valor que corresponde à chave k. Com um dicionário de Python, <code>d</code>, esta operação é escrita <code>d[k]</code> ou <code>d.get(k)</code>.</p>
<p>Por enquanto, vou supor que cada chave só apareça uma vez. A implementação mais simples desta interface usa uma lista de tuplas, onde cada tupla é um par chave-valor:</p>
<pre><code class="language-python">class LinearMap:

    def __init__(self):
        self.items = []

    def add(self, k, v):
        self.items.append((k, v))

    def get(self, k):
        for key, val in self.items:
            if key == k:
                return val
        raise KeyError
</code></pre>
<p><code>add</code> acrescenta uma tupla chave-valor à lista de itens, o que tem tempo constante.</p>
<p><code>get</code> usa um loop for para buscar na lista: se encontrar a chave-alvo, retorna o valor correspondente; do contrário, exibe um KeyError. Então get é linear.</p>
<p>Uma alternativa é manter uma lista ordenada por chaves. Assim, get poderia usar uma busca por bisseção, que é \( O(\log n) \). Porém, inserir um novo item no meio de uma lista é linear, então isso pode não ser a melhor opção. Há outras estruturas de dados que podem implementar <code>add</code> e <code>get</code> em tempo logarítmico, mas isso não é tão bom como tempo constante, então vamos continuar.</p>
<p>Uma forma de melhorar <code>LinearMap</code> é quebrar a lista de pares chave-valor em listas menores. Aqui está uma implementação chamada <code>BetterMap</code>, que é uma lista de cem LinearMaps. Como veremos em um segundo, a ordem de crescimento para get ainda é linear, mas <code>BetterMap</code> é um passo no caminho em direção a hashtables:</p>
<pre><code class="language-python">class BetterMap:

    def __init__(self, n=100):
        self.maps = []
        for i in range(n):
            self.maps.append(LinearMap())

    def find_map(self, k):
        index = hash(k) % len(self.maps)
        return self.maps[index]

    def add(self, k, v):
        m = self.find_map(k)
        m.add(k, v)

    def get(self, k):
        m = self.find_map(k)
        return m.get(k)

</code></pre>
<p><code>__init__</code> cria uma lista de n LinearMaps.</p>
<p><code>find_map</code> é usada por add e get para saber em qual mapa o novo item deve ir ou em qual mapa fazer a busca.</p>
<p><code>find_map</code> usa a função integrada hash, que recebe quase qualquer objeto do Python e retorna um número inteiro. Uma limitação desta implementação é que ela só funciona com chaves hashable. Tipos mutáveis como listas e dicionários não são hashable.</p>
<p>Objetos hashable considerados equivalentes retornam o mesmo valor hash, mas o oposto não é necessariamente verdade: dois objetos com valores diferentes podem retornar o mesmo valor hash.</p>
<p><code>find_map</code> usa o operador módulo para manter os valores hash no intervalo de 0 a len(self.maps), então o resultado é um índice legal na lista. Naturalmente, isso significa que muitos valores hash diferentes serão reunidos no mesmo índice. Entretanto, se a função hash dispersar as coisas de forma consistente (que é o que as funções hash foram projetadas para fazer), então esperamos ter n/100 itens por <code>LinearMap</code>.</p>
<p>Como o tempo de execução de <code>LinearMap.get</code> é proporcional ao número de itens, esperamos que <code>BetterMap</code> seja aproximadamente cem vezes mais rápido que <code>LinearMap</code>. A ordem de crescimento ainda é linear, mas o coeficiente principal é menor. Isto é bom, mas não tão bom quanto uma hashtable.</p>
<p>Aqui (finalmente) está a ideia crucial que faz hashtables serem rápidas: se puder limitar o comprimento máximo de LinearMaps, <code>LinearMap.get</code> é de tempo constante. Tudo o que você precisa fazer é rastrear o número de itens e quando o número de itens por <code>LinearMap</code> exceder o limite, alterar o tamanho da hashtable acrescentando LinearMaps.</p>
<p>Aqui está uma implementação de uma hashtable:</p>
<pre><code class="language-python">class HashMap:
    def __init__(self):
        self.maps = BetterMap(2)
        self.num = 0
    def get(self, k):
        return self.maps.get(k)
    def add(self, k, v):
        if self.num == len(self.maps.maps):
            self.resize()
        self.maps.add(k, v)
        self.num += 1
    def resize(self):
        new_maps = BetterMap(self.num * 2)
        for m in self.maps.maps:
            for k, v in m.items:
                new_maps.add(k, v)
        self.maps = new_maps
</code></pre>
<p>Cada <code>HashMap</code> contém um <code>BetterMap</code>; <code>__init__</code> inicia com apenas dois LinearMaps e inicializa num, que monitora o número de itens.</p>
<p>get apenas despacha para <code>BetterMap</code>. O verdadeiro trabalho acontece em add, que verifica o número de itens e o tamanho de <code>BetterMap</code>: se forem iguais, o número médio de itens por <code>LinearMap</code> é um, então resize é chamada.</p>
<p>resize faz um novo <code>BetterMap</code> duas vezes maior que o anterior, e então “redispersa” os itens do mapa antigo no novo.</p>
<p>A redispersão é necessária porque alterar o número de LinearMaps muda o denominador do operador módulo em <code>find_map</code>. Isso significa que alguns objetos que costumavam ser dispersos no mesmo <code>LinearMap</code> serão separados (que é o que queríamos, certo?).</p>
<p>A redispersão é linear, então resize é linear, o que pode parecer ruim, já que prometi que add seria de tempo constante. Entretanto, lembre-se de que não temos que alterar o tamanho a cada vez, então add normalmente é de tempo constante e só ocasionalmente linear. O volume total de trabalho para executar add n vezes é proporcional a n, então o tempo médio de cada add é de tempo constante!</p>
<p>Para ver como isso funciona, pense como seria começar com uma HashTable vazia e inserir uma série de itens. Começamos com dois LinearMaps, então as duas primeiras inserções são rápidas (não é necessário alterar o tamanho). Digamos que elas tomem uma unidade do trabalho cada uma. A próxima inserção exige uma alteração de tamanho, então temos de redispersar os dois primeiros itens (vamos chamar isso de mais duas unidades de trabalho) e então acrescentar o terceiro item (mais uma unidade). Acrescentar o próximo item custa uma unidade, então o total, por enquanto, é de seis unidades de trabalho para quatro itens.</p>
<p>O próximo add custa cinco unidades, mas os três seguintes são só uma unidade cada um, então o total é de 14 unidades para as primeiras oito inserções.</p>
<p>O próximo add custa nove unidades, mas então podemos inserir mais sete antes da próxima alteração de tamanho, então o total é de 30 unidades para as primeiras 16 inserções.</p>
<p>Depois de 32 inserções, o custo total é de 62 unidades, e espero que você esteja começando a ver um padrão. Depois de n inserções, nas quais n é uma potência de dois, o custo total é de 2n-2 unidades, então o trabalho médio por inserção é um pouco menos de duas unidades. Quando n é uma potência de dois, esse é o melhor caso; para outros valores de n, o trabalho médio é um pouco maior, mas isso não é importante. O importante é que seja \( O(1) \).</p>
<p>A Figura 21.1 mostra graficamente como isso funciona. Cada bloco representa uma unidade de trabalho. As colunas mostram o trabalho total para cada inserção na ordem da esquerda para a direita: os primeiros dois adds custam uma unidade, o terceiro custa três unidades etc.</p>
<p><img src="/fig/tnkp_2101.png" alt="Figura B.1 – O custo de inserções em uma hashtable" />.
<br><em>Figura B.1 – O custo de inserções em uma hashtable.</em></p>
<p>O trabalho extra de redispersão aparece como uma sequência de torres cada vez mais altas com um aumento de espaço entre elas. Agora, se derrubar as torres, espalhando o custo de alterar o tamanho por todas as inserções, poderá ver graficamente que o custo total depois de n inserções é de 2n − 2.</p>
<p>Uma característica importante deste algoritmo é que quando alteramos o tamanho da HashTable, ela cresce geometricamente; isto é, multiplicamos o tamanho por uma constante. Se você aumentar o tamanho aritmeticamente – somando um número fixo de cada vez – o tempo médio por add é linear.</p>
<p>Você pode baixar minha implementação de <code>HashMap</code> em <a href="http://thinkpython2.com/code/Map.py">http://thinkpython2.com/code/Map.py</a>, mas lembre-se de que não há razão para usá-la; se quiser um mapa, basta usar um dicionário do Python.</p>
<h2><a class="header" href="#b5---glossário" id="b5---glossário">B.5 - Glossário</a></h2>
<h5><a class="header" href="#análise-de-algoritmos" id="análise-de-algoritmos">análise de algoritmos</a></h5>
<p>    Forma de comparar algoritmos quanto às suas exigências de espaço e/ou tempo de execução.</p>
<h5><a class="header" href="#modelo-de-máquina" id="modelo-de-máquina">modelo de máquina</a></h5>
<p>    Representação simplificada de um computador usada para descrever algoritmos.</p>
<h5><a class="header" href="#pior-caso" id="pior-caso">pior caso</a></h5>
<p>    Entrada que faz um dado algoritmo rodar mais lentamente (ou exigir mais espaço).</p>
<h5><a class="header" href="#termo-principal" id="termo-principal">termo principal</a></h5>
<p>    Em um polinômio, o termo com o expoente mais alto.</p>
<h5><a class="header" href="#ponto-de-desvio" id="ponto-de-desvio">ponto de desvio</a></h5>
<p>    Tamanho do problema em que dois algoritmos exigem o mesmo tempo de execução ou espaço.</p>
<h5><a class="header" href="#ordem-de-crescimento" id="ordem-de-crescimento">ordem de crescimento</a></h5>
<p>    Conjunto de funções em que todas crescem em uma forma considerada equivalente para os propósitos da análise de algoritmos. Por exemplo, todas as funções que crescem linearmente pertencem à mesma ordem de crescimento.</p>
<h5><a class="header" href="#notação-grande-o-big-oh-notation" id="notação-grande-o-big-oh-notation">notação Grande-O (Big-Oh notation)</a></h5>
<p>    Notação para representar uma ordem de crescimento; por exemplo, \( O(n) \) representa o conjunto de funções que crescem linearmente.</p>
<h5><a class="header" href="#linear" id="linear">linear</a></h5>
<p>    Algoritmo cujo tempo de execução é proporcional ao tamanho do problema, pelo menos para grandes tamanhos de problema.</p>
<h5><a class="header" href="#quadrático" id="quadrático">quadrático</a></h5>
<p>    Algoritmo cujo tempo de execução é proporcional a \( n^2 \), onde n é uma medida de tamanho do problema.</p>
<h5><a class="header" href="#busca-2" id="busca-2">busca</a></h5>
<p>    Problema de localizar um elemento de uma coleção (como uma lista ou dicionário) ou de decidir que não está presente.</p>
<h5><a class="header" href="#hashtable-1" id="hashtable-1">hashtable</a></h5>
<p>    Estrutura de dados que representa uma coleção de pares chave-valor e executa buscas em tempo constante.</p>
<p>[1] popen foi descartado, ou seja, devemos parar de usá-lo e começar a usar o módulo subprocess. Entretanto, para casos simples, eu considero subprocess mais complicado que o necessário. Então vou continuar usando popen até que o removam.</p>
<p>[2] Mas se fizerem uma pergunta como essa em uma entrevista, creio que a melhor resposta é “A forma mais rápida de classificar um milhão de números inteiros é usar qualquer função de ordenação oferecida pela linguagem que estou usando. Se o desempenho é bom o suficiente para a grande maioria das aplicações, mas a minha aplicação acabasse sendo lenta demais, eu usaria algum recurso para investigar onde o tempo está sendo gasto. Se parecesse que um algoritmo mais rápido teria um efeito significativo sobre o desempenho, então procuraria uma boa implementação do tipo radix”.</p>
<h1><a class="header" href="#colofão" id="colofão">Colofão</a></h1>
<p><a href="https://novatec.com.br/livros/pense-em-python/"><img src="fig/Capa_PenseEmPython332x461-borda.png" align="right" style="margin-left: 30px;"></a></p>
<p>O animal na capa de Pense em Python é um papagaio-da-carolina, também conhecido como periquito-da-carolina (Conuropsis carolinensis). Este papagaio habitava o sudeste dos Estados Unidos e foi o único papagaio continental a habitar regiões acima do norte do México. Um dia, vivia no norte, em locais tão distantes quanto Nova Iorque e os Grandes Lagos, embora fosse encontrado principalmente na região da Flórida às Carolinas.</p>
<p>O papagaio-da-carolina era quase todo verde com a cabeça amarela e, na maturidade, tinha uma coloração laranja na testa e na face. Seu tamanho médio variava de 31 a 33 cm. Tinha uma voz alta, ruidosa e palrava constantemente enquanto se alimentava. Habitava troncos de árvores ocos perto de brejos e barrancos. O papagaio-da-carolina era um animal muito gregário, que vivia em pequenos grupos os quais podiam chegar a várias centenas quando se alimentavam.</p>
<p>Infelizmente, essas áreas de alimentação muitas vezes eram as plantações de agricultores, que disparavam nos pássaros para mantê-los longe das plantas. A natureza social dos pássaros fazia com que eles voassem ao resgate de qualquer papagaio ferido, permitindo aos agricultores derrubar bandos inteiros de cada vez. Além disso, suas penas eram usadas para embelezar chapéus de senhoras, e alguns papagaios eram mantidos como mascotes. Uma combinação desses fatores levou o papagaio-da-carolina a tornar-se raro no fim dos anos 1800, e as doenças de aves domésticas podem ter contribuído para diminuir seu número. Pelos anos 1920, a espécie estava extinta.</p>
<p>Hoje, há mais de 700 espécimes de papagaios-da-carolina conservados em museus no mundo inteiro.</p>
<p>Muitos dos animais nas capas de livros da O’Reilly estão em perigo de extinção; todos eles são importantes para o mundo. Para saber mais sobre como você pode ajudar, acesse animals.oreilly.com. A imagem da capa é do livro Johnson’s Natural History.</p>
<h2><a class="header" href="#sobre-o-autor" id="sobre-o-autor">Sobre o autor</a></h2>
<p>Allen Downey é professor de Ciência da Computação no Olin College of Engineering. Ele já ensinou no Wellesley College, Colby College e na U.C. Berkeley. É doutor em Ciência da Computação pela U.C. Berkeley e mestre e graduado pelo MIT.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
